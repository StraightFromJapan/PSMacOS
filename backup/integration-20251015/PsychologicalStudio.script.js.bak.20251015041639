document.addEventListener("DOMContentLoaded", function () {
    // Offline Storage Manager for Psychological Studio
    class OfflineStorageManager {
        constructor() {
            this.storageKey = 'psychological-studio-data';
            this.projectKey = 'psychological-studio-projects';
            this.settingsKey = 'psychological-studio-settings';
            this.audioKey = 'psychological-studio-audio';
        }

        // Save project data
        saveProject(projectName, projectData) {
            try {
                const projects = this.getProjects();
                projects[projectName] = {
                    ...projectData,
                    timestamp: Date.now(),
                    version: '2.0'
                };
                localStorage.setItem(this.projectKey, JSON.stringify(projects));
                console.log(`Project "${projectName}" saved offline`);
                return true;
            } catch (error) {
                console.error('Failed to save project:', error);
                return false;
            }
        }

        // Load project
        loadProject(projectName) {
            try {
                const projects = this.getProjects();
                return projects[projectName] || null;
            } catch (error) {
                console.error('Failed to load project:', error);
                return null;
            }
        }

        // Get all projects
        getProjects() {
            try {
                const projects = localStorage.getItem(this.projectKey);
                return projects ? JSON.parse(projects) : {};
            } catch (error) {
                console.error('Failed to get projects:', error);
                return {};
            }
        }

        // Delete project
        deleteProject(projectName) {
            try {
                const projects = this.getProjects();
                delete projects[projectName];
                localStorage.setItem(this.projectKey, JSON.stringify(projects));
                console.log(`Project "${projectName}" deleted`);
                return true;
            } catch (error) {
                console.error('Failed to delete project:', error);
                return false;
            }
        }

        // Save app settings
        saveSettings(settings) {
            try {
                localStorage.setItem(this.settingsKey, JSON.stringify({
                    ...settings,
                    timestamp: Date.now()
                }));
                return true;
            } catch (error) {
                console.error('Failed to save settings:', error);
                return false;
            }
        }

        // Load app settings
        loadSettings() {
            try {
                const settings = localStorage.getItem(this.settingsKey);
                return settings ? JSON.parse(settings) : {};
            } catch (error) {
                console.error('Failed to load settings:', error);
                return {};
            }
        }

        // Save audio data as base64
        saveAudioData(audioName, audioBlob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    try {
                        const audioData = {
                            name: audioName,
                            data: reader.result,
                            timestamp: Date.now(),
                            size: audioBlob.size,
                            type: audioBlob.type
                        };
                        
                        const existingAudio = this.getAudioData();
                        existingAudio[audioName] = audioData;
                        localStorage.setItem(this.audioKey, JSON.stringify(existingAudio));
                        console.log(`Audio "${audioName}" saved offline`);
                        resolve(true);
                    } catch (error) {
                        console.error('Failed to save audio:', error);
                        reject(error);
                    }
                };
                reader.onerror = reject;
                reader.readAsDataURL(audioBlob);
            });
        }

        // Get audio data
        getAudioData(audioName = null) {
            try {
                const audioData = localStorage.getItem(this.audioKey);
                const data = audioData ? JSON.parse(audioData) : {};
                return audioName ? data[audioName] : data;
            } catch (error) {
                console.error('Failed to get audio data:', error);
                return audioName ? null : {};
            }
        }

        // Convert base64 audio back to blob
        audioDataToBlob(audioData) {
            try {
                const byteCharacters = atob(audioData.data.split(',')[1]);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                return new Blob([byteArray], { type: audioData.type });
            } catch (error) {
                console.error('Failed to convert audio data to blob:', error);
                return null;
            }
        }

        // Get storage usage info
        getStorageInfo() {
            try {
                const projects = this.getProjects();
                const audio = this.getAudioData();
                const settings = this.loadSettings();
                
                let totalSize = 0;
                Object.values(audio).forEach(audioData => {
                    totalSize += audioData.size || 0;
                });
                
                return {
                    projects: Object.keys(projects).length,
                    audioFiles: Object.keys(audio).length,
                    totalAudioSize: totalSize,
                    settings: Object.keys(settings).length
                };
            } catch (error) {
                console.error('Failed to get storage info:', error);
                return { projects: 0, audioFiles: 0, totalAudioSize: 0, settings: 0 };
            }
        }

        // Clear all data
        clearAllData() {
            try {
                localStorage.removeItem(this.projectKey);
                localStorage.removeItem(this.settingsKey);
                localStorage.removeItem(this.audioKey);
                console.log('All offline data cleared');
                return true;
            } catch (error) {
                console.error('Failed to clear data:', error);
                return false;
            }
        }

        // Export all data for backup
        exportAllData() {
            try {
                const data = {
                    projects: this.getProjects(),
                    settings: this.loadSettings(),
                    audio: this.getAudioData(),
                    exportDate: new Date().toISOString(),
                    version: '2.0'
                };
                return JSON.stringify(data, null, 2);
            } catch (error) {
                console.error('Failed to export data:', error);
                return null;
            }
        }

        // Import data from backup
        importData(jsonData) {
            try {
                const data = JSON.parse(jsonData);
                if (data.projects) localStorage.setItem(this.projectKey, JSON.stringify(data.projects));
                if (data.settings) localStorage.setItem(this.settingsKey, JSON.stringify(data.settings));
                if (data.audio) localStorage.setItem(this.audioKey, JSON.stringify(data.audio));
                console.log('Data imported successfully');
                return true;
            } catch (error) {
                console.error('Failed to import data:', error);
                return false;
            }
        }
    }

// ---------- Embedded Arrangement Integration (App mode) ----------
(function(){
    let _psArrangementMounted = false;
    let _psArrangementContainer = null;
    let _psArrangementScriptLoaded = false;

    function createArrangementContainer() {
        if (_psArrangementContainer) return _psArrangementContainer;
        _psArrangementContainer = document.createElement('div');
        _psArrangementContainer.id = 'ps-embedded-arrangement';
        _psArrangementContainer.style.position = 'fixed';
        _psArrangementContainer.style.top = '0';
        _psArrangementContainer.style.left = '0';
        _psArrangementContainer.style.width = '100%';
        _psArrangementContainer.style.height = '100%';
        _psArrangementContainer.style.zIndex = '99999';
        _psArrangementContainer.style.background = '#000';
        _psArrangementContainer.style.display = 'none';
        document.body.appendChild(_psArrangementContainer);
        return _psArrangementContainer;
    }

    async function fetchText(url) {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) throw new Error(`Failed to fetch ${url}: ${res.status}`);
        return await res.text();
    }

    async function mountArrangementUI() {
        if (_psArrangementMounted) return _psArrangementContainer;
        const container = createArrangementContainer();

        // Create an iframe to host arrangement.html to avoid CSS/JS collisions
        const iframe = document.createElement('iframe');
        iframe.id = 'ps-arrangement-iframe';
        iframe.src = './arrangement.html?ps_access=1'; // pass token via query as fallback
        iframe.style.width = '100%';
        iframe.style.height = '100%';
        iframe.style.border = 'none';
        iframe.style.display = 'block';
        // Allow microphone/camera if needed (optional)
        iframe.allow = 'microphone; camera; autoplay;';

        container.innerHTML = ''; // clear any previous
        container.appendChild(iframe);
        _psArrangementMounted = true;

        // Listen for postMessage from iframe (e.g., back button)
        window.addEventListener('message', (ev) => {
            if (!ev.data) return;
            if (ev.data === 'ps-arrangement-close') {
                hideArrangement();
            }
        });

        return container;
    }

    function showArrangement() {
        createArrangementContainer();
        _psArrangementContainer.style.display = 'block';
        document.documentElement.style.overflow = 'hidden';
    }

    function hideArrangement() {
        if (!_psArrangementContainer) return;
        _psArrangementContainer.style.display = 'none';
        document.documentElement.style.overflow = '';
    }

    async function ensureArrangementScriptLoaded() {
        // No-op when using iframe approach; arrangement runs inside its own context.
        return Promise.resolve();
    }

    // Wire the Arrangement button
    document.addEventListener('DOMContentLoaded', () => {
        const arrBtn = document.getElementById('arrangementButton');
        if (!arrBtn) return;
        arrBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            try {
                await mountArrangementUI();
                await ensureArrangementScriptLoaded();
                showArrangement();
            } catch (err) {
                console.error('Could not open Arrangement:', err);
                alert('Failed to open Arrangement. See console for details.');
            }
        });

        // Allow Back to Studio button inside arrangement to hide the embedded UI
        document.body.addEventListener('click', (ev) => {
            if (!ev.target) return;
            const el = ev.target.closest && ev.target.closest('#arr-back');
            if (el && _psArrangementContainer && _psArrangementContainer.style.display === 'block') {
                hideArrangement();
            }
        });
    });
})();

    // Initialize offline storage manager
    const offlineStorage = new OfflineStorageManager();

    let currentSampleForPopup = null;
    let longPressTimer = null;
    let isLongPress = false;
    let eqCanvas = null;
    let eqCtx = null;
    const MAX_EQ_POINTS = 12;
    let isDraggingEqBand = false;
    let draggedPoint = null;
    let isCreatingNewPoint = false;
    let waveformAnalyzer = null;
    let waveformAnimationId = null;
    let waveformHistory = [];
    const waveformHistorySize = 100;
    let originalEffects = null;
    let temporaryEffects = null;
    let recordedBlob = null;
    const recordedBlobs = {};
    const uploadStatusPerSample = {};
    const recordStatusPerSample = {};
    const uploadedFileNames = {};
    let pianoRollData = {};
    let isPreviewingPianoRoll = false;
    let pianoRollPreviewNodes = {};
    let currentPianoRollSample = null;
    let pianoRollLoopInterval = null;
    let pianoRollNoteLength = 1;
    let pianoRollCellCache = {}; // Performance: Cache cell elements for instant access
    let pianoRollFilterNodes = {
        lowShelf: null,
        highShelf: null,
        peaking1: null,
        peaking2: null,
        peaking3: null,
        delay: null,
        delayFeedback: null
    };
    let pianoRollVisualizer = null;
    let pianoRollVisualizerCtx = null;
    let pianoRollVisualizerAnalyzer = null;
    let pianoRollVisualizerAnimationId = null;
    let pianoRollVisualizerHistory = [];
    const pianoRollVisualizerHistorySize = 100;
    let pianoRollPreviewActiveVoices = {};
    let sampleSelectionPopup = null;
    let currentSampleForSelection = null;
    let sampleSelectionStart = 0;
    let sampleSelectionEnd = 0;
    let sampleSelectionZoomLevel = 1;
    let sampleSelectionWaveformBuffer = null;
    let sampleSelectionPreviewSource = null;
    let sampleSelectionPreviewGain = null;
    let isPreviewingSelection = false;
    let audioContext;
    let isPlaying = false;
    let isRecording = false;
    let tempo = 120;
    let highTempo = 0;
    let longLoopTempo = 120;
    let beatDuration = 60 / tempo;
    let barDuration = beatDuration * 4;
    let nextBarTime = 0;
    let lookahead = 25;
    let scheduleAheadTime = .1;
    let timerId = null;
    let mediaRecorder;
    let recordedChunks = [];
    let recordingStartTime;
    let recordingDuration = 0;
    let recordingDestination = null;
    let microphoneMediaRecorder = null;
    let microphoneMediaStream = null;
    let microphoneRecordedChunks = [];
    let isMicrophoneRecording = false;
    let masterStartTime = 0;
    let masterCurrentBar = 0;
    let masterTempo = tempo;
    let tempoChangeTime = 0;
    let tempoHistory = [];
    let masterBarGrid = {
        startTime: 0,
        duration: barDuration,
        nextStartTime: barDuration
    };
    
    // Bar Counter Variables
    let barCounterStartTime = 0;
    let barCounterInterval = null;
    let currentBar = 0;
    let currentBeat = 0;
    let totalBeatsElapsed = 0; // Track total beats regardless of tempo changes
    let lastCounterUpdateTime = 0;
    
    // Mobile detection and performance optimizations
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                     ('ontouchstart' in window) || 
                     (navigator.maxTouchPoints > 0);
    
    // Mobile-specific optimizations
    if (isMobile) {
        // Reduce lookahead for better mobile performance
        lookahead = 25; // Reduced from default
        // Disable some expensive features on mobile
        document.documentElement.classList.add('mobile-optimized');
    }
    
    // Piano roll virtualization variables
    let pianoRollVirtualization = {
        enabled: isMobile, // Enable virtualization on mobile by default
        visibleRows: 20, // Number of rows to render at once
        visibleCols: 16, // Number of columns to render at once
        rowHeight: 20, // Height of each row in pixels
        colWidth: 20, // Width of each column in pixels
        scrollTop: 0,
        scrollLeft: 0,
        startRow: 0,
        endRow: 0,
        startCol: 0,
        endCol: 0,
        containerHeight: 0,
        containerWidth: 0,
        totalRows: 84,
        totalCols: 16,
        scrollThrottleTimer: null,
        renderThrottleTimer: null
    };
    
    // Function to toggle virtualization (for testing/debugging)
    function togglePianoRollVirtualization() {
        pianoRollVirtualization.enabled = !pianoRollVirtualization.enabled;
        console.log(`Piano roll virtualization ${pianoRollVirtualization.enabled ? 'enabled' : 'disabled'}`);
        
        // Re-initialize piano roll if it exists
        if (currentSampleForPopup && document.querySelector(".piano-roll-grid")) {
            initPianoRoll();
        }
    }
    
    // Expose toggle function globally for debugging
    window.togglePianoRollVirtualization = togglePianoRollVirtualization;
    let loopLength = 1;
    let longLoopLength = 1;
    const currentPlaying = {};
    const effectsPopup = document.createElement("div");
    effectsPopup.className = "effects-popup";
    effectsPopup.style.display = "none";
    const style = document.createElement("style");
    style.textContent = `
        .audio-button.active.no-sample {
            background-color: #333333 !important;
            color: white !important;
        }
        .audio-button.active.no-sample .loop-indicator {
            background-color: #555555 !important;
        }
        
        /* Dark grey slider styling */
        input[type="range"] {
            background-color: #444444 !important;
            height: 8px;
            border-radius: 4px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #af4c93ff;
            cursor: pointer;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #af4c4cff;
            cursor: pointer;
        }
        
        /* Custom indicator styling - changed to almost black */
        .custom-indicator {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 10px;
            height: 10px;
            background-color: #111111 !important;
            border-radius: 50%;
            z-index: 2;
            box-shadow: 0 0 3px rgba(0,0,0,0.5);
        }
        
        /* Piano roll styling */
        .piano-roll-container {
            display: flex;
            flex-direction: column;
            height: 400px;
            margin-top: 10px;
            position: relative;
            order: 10;
            overflow: hidden; /* Contain the bar numbers within the container */
        }
        
        .piano-roll-scrollable {
            display: flex;
            flex: 1;
            overflow-y: auto;
            overflow-x: auto;
            position: relative;
        }
        
        .piano-keys {
            width: 40px;
            background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
            flex-shrink: 0;
            position: sticky;
            left: 0;
            z-index: 10;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.3);
        }
        
        .piano-key {
            height: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #aaa;
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .piano-key.white {
            background: linear-gradient(135deg, #3a3a3a 0%, #2a2a2a 100%);
            color: #ddd;
        }
        
        .piano-key.black {
            background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
            color: #fff;
            height: 12px;
            margin: 4px 0;
            z-index: 2;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .piano-key:hover {
            background: linear-gradient(135deg, #4a4a4a 0%, #3a3a3a 100%);
            box-shadow: inset 0 0 8px rgba(255, 255, 255, 0.1);
        }
        
        .piano-key.active {
            background: linear-gradient(135deg, #4CAF50 0%, #2E7D32 100%);
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.6), inset 0 2px 4px rgba(255, 255, 255, 0.2);
        }
        
        .piano-roll-grid-container {
            flex-grow: 1;
            position: relative;
            overflow: visible;
            min-height: 100%;
            background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
            border-radius: 8px;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .piano-roll-grid {
            position: relative;
            top: auto;
            left: auto;
            background: linear-gradient(135deg, #2c2c2c 0%, #1e1e1e 100%);
            display: grid;
            grid-auto-rows: 20px;
            width: 100%;
            height: auto;
            min-height: 1680px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }
        
        .piano-roll-cell {
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            position: relative;
            min-width: 20px;
            background: #2a2a2a;
            /* Removed transition for mobile performance */
        }
        
        /* Disable hover effects on mobile for better performance */
        @media (hover: hover) and (pointer: fine) {
            .piano-roll-cell:hover {
                background: #3a3a3a;
            }
        }
        
        .piano-roll-cell.bar-start {
              border-left: 3px solid #111;
        }
        
        .piano-roll-cell.bar-end {
              border-right: 3px solid #111;
        }
        
        .piano-roll-cell.active {
            background: #DC143C;
            height: 20px;
            margin-top: auto;
            margin-bottom: auto;
            border: 1px solid #B22222;
            /* Removed expensive animation and shadows for mobile performance */
        }
        
        .piano-roll-cell.note-long {
            background: #DC143C;
            border: 1px solid #B22222;
            /* Removed expensive shadows for mobile performance */
        }
        
        /* Only enable pulse animation on desktop for better mobile performance */
        @media (hover: hover) and (pointer: fine) {
            .piano-roll-cell.active {
                animation: pulse 2s infinite;
                box-shadow: 0 0 8px rgba(220, 20, 60, 0.6);
            }
            
            @keyframes pulse {
                0% { box-shadow: 0 0 8px rgba(220, 20, 60, 0.6); }
                50% { box-shadow: 0 0 12px rgba(220, 20, 60, 0.8); }
                100% { box-shadow: 0 0 8px rgba(220, 20, 60, 0.6); }
            }
        }
        
        /* Mobile-specific optimizations */
        .mobile-optimized .piano-roll-cell {
            /* Reduce border complexity on mobile */
            border-right: 1px solid rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .mobile-optimized .piano-roll-cell.active {
            /* Simplified active state for mobile */
            background: #DC143C;
            border: 1px solid #B22222;
            /* No animations or shadows on mobile */
        }
        
        .mobile-optimized .piano-roll-cell.note-long {
            background: #DC143C;
            border: 1px solid #B22222;
        }
        
        /* Optimize piano roll container for mobile */
        .mobile-optimized .piano-roll-container {
            /* Reduce shadow complexity */
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }
        
        /* Optimize piano keys for mobile */
        .mobile-optimized .piano-key {
            /* Reduce transition complexity */
            transition: background-color 0.1s ease;
        }
        
        .piano-roll-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
            color: white;
        }
        
        .piano-roll-sound-source {
            display: flex;
            align-items: center;
        }
        
        .piano-roll-sound-source label {
            margin-right: 10px;
            color: white;
        }
        
        .piano-roll-sound-source select {
            color: white;
            background-color: #333;
            border: 1px solid #555;
            padding: 5px;
        }
        
        .piano-roll-preview-controls {
            display: flex;
            gap: 10px;
        }
        
        .piano-roll-preview-controls button {
            color: white;
            background-color: #4CAF50;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .piano-roll-preview-controls button:hover {
            background-color: #45a049;
        }
        
        .piano-roll-clear-btn {
            background-color: #f44336;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .piano-roll-clear-btn:hover {
            background-color: #d32f2f;
        }
        
        /* Piano roll note length selector */
        .piano-roll-controls-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
            align-items: center;
            justify-content: space-evenly;
        }
        
        .piano-roll-note-length {
            display: flex;
            align-items: center;
            gap: 5px;
            flex: 1;
            min-width: 0;
        }
        
        .piano-roll-note-length label {
            color: white;
        }
        
        .piano-roll-note-length select {
            color: white;
            background-color: #333;
            border: 1px solid #555;
            padding: 5px;
            flex: 1;
            min-width: 0;
        }
        
        /* Piano roll grid size selector */
        .piano-roll-grid-size {
            display: flex;
            align-items: center;
            gap: 5px;
            flex: 1;
            min-width: 0;
        }
        
        .piano-roll-grid-size label {
            color: white;
        }
        
        .grid-size-controls {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .grid-size-controls button {
            background-color: #444;
            color: white;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .grid-size-controls button:hover {
            background-color: #555;
        }
        
        #grid-size-display {
            color: white;
            min-width: 30px;
            text-align: center;
        }
        
        .note-length-controls {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .note-length-controls button {
            background-color: #444;
            color: white;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .note-length-controls button:hover {
            background-color: #555;
        }
        
        #note-length-display {
            color: white;
            min-width: 40px;
            text-align: center;
        }
        
        /* Piano roll zoom controls */
        .piano-roll-zoom-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        
        .piano-roll-zoom-controls label {
            color: white;
        }
        
        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .zoom-controls button {
            background-color: #444;
            color: white;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .zoom-controls button:hover {
            background-color: #555;
        }
        
        #zoom-level-display {
            color: white;
            min-width: 50px;
            text-align: center;
        }
        
        /* Piano roll visualizer styling */
        .piano-roll-visualizer-container {
            height: 120px;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
            border: 2px solid #333;
            border-radius: 8px;
            margin: 15px 0;
            position: relative;
            overflow: hidden;
            box-shadow: 
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                0 4px 12px rgba(0, 0, 0, 0.3),
                0 1px 3px rgba(0, 0, 0, 0.2);
        }
        
        .piano-roll-visualizer {
            width: 100%;
            height: 100%;
        }
        
        /* Piano roll bar numbers wrapper */
        .piano-roll-bar-numbers-wrapper {
            height: 20px;
            overflow-x: auto;
            overflow-y: hidden;
            margin-left: 40px; /* Offset to align with grid, accounting for piano keys width */
            /* Hide scrollbar but keep scroll functionality */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* Internet Explorer 10+ */
        }
        
        /* Hide scrollbar for WebKit browsers (Chrome, Safari, Edge) */
        .piano-roll-bar-numbers-wrapper::-webkit-scrollbar {
            display: none;
        }
        
        /* Piano roll bar numbers */
        .piano-roll-bar-numbers {
            display: flex;
            height: 20px;
            background-color: #2a2a2a;
            border-bottom: 1px solid #444;
            position: relative;
            z-index: 1000; /* keep visible above grid when scrolling vertically */
            /* Allow full expansion without constraints */
        }
        
        /* Hide scrollbar for WebKit browsers (Chrome, Safari, Edge) */
        .piano-roll-bar-numbers::-webkit-scrollbar {
            display: none;
        }
        
        .piano-roll-bar-number {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #aaa;
            font-size: 10px;
            border-right: 1px solid #444;
            /* Width will be set dynamically based on zoom level */
        }
        
        .piano-roll-bar-number.bar-start {
            border-left: 2px solid black;
            font-weight: bold;
            color: #fff;
        }
        
        .sample-selection-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            border: 1px solid #444;
            border-radius: 12px;
            padding: 25px;
            z-index: 1001;
            width: 600px;
            max-width: 90vw;
            max-height: 85vh;
            overflow-y: auto;
            display: none;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .sample-selection-popup h3 {
            margin-top: 0;
            color: #fff;
            font-size: 20px;
            font-weight: 500;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .sample-selection-popup .popup-content {
            margin-bottom: 20px;
        }
        
        .sample-selection-popup .popup-footer {
            display: flex;
            justify-content: flex-end;
            gap: 15px;
            margin-top: 20px;
        }
        
        .sample-selection-popup button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        
        .sample-selection-popup .popup-close-btn {
            background-color: #555;
            color: white;
        }
        
        .sample-selection-popup .popup-close-btn:hover {
            background-color: #444;
            transform: translateY(-1px);
        }
        
        .sample-selection-popup .popup-accept-btn {
            background-color: #4CAF50;
            color: white;
        }
        
        .sample-selection-popup .popup-accept-btn:hover {
            background-color: #45a049;
            transform: translateY(-1px);
        }
        
        .sample-waveform-container {
            height: 180px;
            background: linear-gradient(145deg, #1a1a1a, #0a0a0a);
            border: 1px solid #444;
            border-radius: 8px;
            position: relative;
            margin: 15px 0;
            overflow: hidden;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        .sample-waveform {
            width: 100%;
            height: 100%;
            color: red;
            background-color: red;
            accent-color: red;
        }
        
        .sample-selection-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 15px 0;
        }
        
        .sample-selection-range {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        
        .sample-selection-range label {
            width: 60px;
            color: #ddd;
            font-weight: 500;
        }
        
        .sample-selection-range input[type="range"] {
            flex-grow: 1;
            margin: 0 15px;
            background: linear-gradient(90deg, #333 0%, #444 100%);
            height: 6px;
            border-radius: 3px;
            outline: none;
        }
        
        .sample-selection-range input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #5e4cafff;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        .sample-selection-range input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #af4c4cff;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }
        
        .sample-selection-values {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            color: #aaa;
            margin-top: 5px;
        }
        
        .sample-selection-info {
            display: flex;
            justify-content: space-between;
            background-color: rgba(255, 255, 255, 0.05);
            padding: 10px 15px;
            border-radius: 6px;
            margin-bottom: 15px;
        }
        
        .sample-selection-info span {
            color: #ddd;
            font-size: 14px;
        }
        
        .sample-selection-preview-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
        }
        
        .sample-selection-preview-btn {
            background-color: #c93600ff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        
        .sample-selection-preview-btn:hover {
            background-color: #da310bff;
            transform: translateY(-1px);
        }
        
        .sample-selection-zoom-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 10px 0;
        }
        
        .sample-selection-zoom-btn {
            background-color: #555;
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .sample-selection-zoom-btn:hover {
            background-color: #666;
            transform: scale(1.1);
        }
        
        .sample-selection-zoom-level {
            display: flex;
            align-items: center;
            color: #ddd;
            font-size: 14px;
            min-width: 50px;
            justify-content: center;
        }
        
        /* Piano roll filter controls styling - MODIFIED */
        .piano-roll-filters {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #444;
        }
        
        .piano-roll-filters h4 {
            margin-bottom: 10px;
            color: #fff;
        }
        
        .filter-control {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .filter-control label {
            width: 100px;
            font-size: 12px;
            color: #aaa;
        }
        
        .filter-control input {
            flex-grow: 1;
            margin-right: 10px;
        }
        
        .filter-control span {
            width: 50px;
            text-align: right;
            font-size: 12px;
            color: #aaa;
        }
        
        /* Enhanced filter controls styling - MOBILE FIX */
        .enhanced-filter-controls {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            margin-top: 10px;
        }
        
        @media (min-width: 768px) {
            .enhanced-filter-controls {
                grid-template-columns: 1fr 1fr;
            }
        }
        
        .filter-group {
            background-color: #2a2a2a;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #444;
        }
        
        .filter-group h5 {
            margin: 0 0 8px 0;
            color: #331febff;
            font-size: 14px;
        }
        
        .filter-group .filter-control {
            margin-bottom: 5px;
        }
        
        .filter-group .filter-control:last-child {
            margin-bottom: 0;
        }
        
        /* Loading indicator for piano roll rendering */
        .loading-indicator {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            z-index: 1000;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .loading-indicator .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 3px solid #4CAF50;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Toggle switch for piano roll section */
        .piano-roll-toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .piano-roll-toggle-container h4 {
            margin: 0;
        }
        
        /* The switch - the box around the slider */
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        
        /* Hide default HTML checkbox */
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        /* The slider */
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #444;
            transition: .4s;
            border-radius: 24px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: #4CAF50;
        }
        
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        
        /* Piano roll content - hidden by default */
        .piano-roll-content {
            display: none;
        }
        
        .piano-roll-content.visible {
            display: block;
        }
        
        /* Recording button styles */
        .microphone-record-btn {
            background-color: #d68100ff !important;
            color: black !important;
            padding: 3px;
        }
        
        .microphone-save-btn {
            background-color: #deae12ff !important;
            color: black !important;
            padding: 3px;
        }
        
        .microphone-download-btn {
            background-color: #4ca427ff !important;
            color: black !important;
            padding: 3px;
        }
        
        .microphone-delete-btn {
            background-color: #ff3f31ff !important;
            color: black !important;
            padding: 3px;
        }
        
        /* LFO Controls Styling */
        .lfo-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #444;
        }
        
        .lfo-section h4 {
            margin-bottom: 10px;
            color: #fff;
        }
        
        /* LFO Tabs Styling */
        .lfo-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }
        
        .lfo-tab {
            flex: 1;
            padding: 8px 12px;
            background-color: #2a2a2a;
            color: #888;
            border: 1px solid #444;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 12px;
            font-weight: 500;
        }
        
        .lfo-tab:hover {
            background-color: #333;
            color: #aaa;
        }
        
        .lfo-tab.active {
            background-color: #3F51B5;
            color: white;
            border-color: #3F51B5;
            box-shadow: 0 2px 8px rgba(63, 81, 181, 0.4);
        }
        
        /* Individual LFO tab colors */
        .lfo-tab[data-lfo="1"].active {
            background-color: #3F51B5;
            border-color: #3F51B5;
            box-shadow: 0 2px 8px rgba(63, 81, 181, 0.4);
        }
        
        .lfo-tab[data-lfo="2"].active {
            background-color: #E91E63;
            border-color: #E91E63;
            box-shadow: 0 2px 8px rgba(233, 30, 99, 0.4);
        }
        
        .lfo-tab[data-lfo="3"].active {
            background-color: #00BCD4;
            border-color: #00BCD4;
            box-shadow: 0 2px 8px rgba(0, 188, 212, 0.4);
        }
        
        .lfo-tab[data-lfo="4"].active {
            background-color: #FF9800;
            border-color: #FF9800;
            box-shadow: 0 2px 8px rgba(255, 152, 0, 0.4);
        }
        
        /* LFO Panels */
        .lfo-panel {
            display: none;
        }
        
        .lfo-panel.active {
            display: block;
        }
        
        .lfo-control {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .lfo-control label {
            width: 100px;
            font-size: 12px;
            color: #aaa;
        }
        
        .lfo-control select {
            flex-grow: 1;
            margin-right: 10px;
            color: white;
            background-color: #333;
            border: 1px solid #555;
            padding: 5px;
        }
        
        .lfo-control input {
            flex-grow: 1;
            margin-right: 10px;
        }
        
        .lfo-control span {
            width: 50px;
            text-align: right;
            font-size: 12px;
            color: #aaa;
        }
        
        .lfo-visualizer {
            height: 60px;
            background-color: #111;
            border: 1px solid #333;
            border-radius: 4px;
            margin: 10px 0;
            position: relative;
            overflow: hidden;
        }
        
        .lfo-wave {
            width: 100%;
            height: 100%;
        }
        
        /* Automation Tabs Styling */
        .automation-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .automation-tab {
            flex: 1;
            padding: 8px;
            background-color: #1a1a1a;
            border: 2px solid #444;
            color: #aaa;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 6px;
        }
        
        .automation-tab:hover {
            background-color: #2a2a2a;
            border-color: #666;
            color: #fff;
        }
        
        .automation-tab.active {
            color: #fff;
            border-color: #9C27B0;
            background-color: rgba(156, 39, 176, 0.2);
            box-shadow: 0 2px 8px rgba(156, 39, 176, 0.4);
        }
        
        /* Individual Automation tab colors */
        .automation-tab[data-automation="1"].active {
            background-color: #9C27B0;
            border-color: #9C27B0;
            box-shadow: 0 2px 8px rgba(156, 39, 176, 0.4);
        }
        
        .automation-tab[data-automation="2"].active {
            background-color: #E91E63;
            border-color: #E91E63;
            box-shadow: 0 2px 8px rgba(233, 30, 99, 0.4);
        }
        
        .automation-tab[data-automation="3"].active {
            background-color: #673AB7;
            border-color: #673AB7;
            box-shadow: 0 2px 8px rgba(103, 58, 183, 0.4);
        }
        
        .automation-tab[data-automation="4"].active {
            background-color: #3F51B5;
            border-color: #3F51B5;
            box-shadow: 0 2px 8px rgba(63, 81, 181, 0.4);
        }
        
        /* Automation Panels */
        .automation-panel {
            display: none;
        }
        
        .automation-panel.active {
            display: block;
        }
        
        .automation-control {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .automation-control label {
            width: 120px;
            font-size: 12px;
            color: #BA68C8;
        }
        
        .automation-control select {
            flex-grow: 1;
            margin-right: 10px;
            color: white;
            background-color: #333;
            border: 1px solid #9C27B0;
            padding: 5px;
            border-radius: 4px;
        }
        
        .automation-control input[type="range"] {
            flex-grow: 1;
            margin-right: 10px;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: linear-gradient(90deg, #4A148C 0%, #9C27B0 100%);
            border-radius: 4px;
            outline: none;
        }
        
        .automation-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #CE93D8;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .automation-control input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #CE93D8;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .automation-control span {
            width: 50px;
            text-align: right;
            font-size: 12px;
            color: #CE93D8;
        }
        
        .automation-control input[type="text"] {
            flex-grow: 1;
            margin-right: 10px;
            color: white;
            background-color: #1a1a1a;
            border: 1px solid #9C27B0;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
        }
        
        .automation-control input[type="text"]::placeholder {
            color: #666;
            font-size: 11px;
        }
        
        .automation-bars-hint {
            width: auto;
            max-width: 150px;
            text-align: left;
            font-size: 9px;
            color: #888;
            line-height: 1.2;
        }
        
        .automation-control input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            cursor: pointer;
            accent-color: #9C27B0;
        }
        
        .automation-loop-hint {
            width: auto;
            max-width: 150px;
            text-align: left;
            font-size: 10px;
            color: #BA68C8;
        }
        
        .automation-visualizer {
            height: 80px;
            background-color: #111;
            border: 2px solid #9C27B0;
            border-radius: 6px;
            margin: 10px 0;
            position: relative;
            overflow: hidden;
        }
        
        .automation-canvas {
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        
        .automation-canvas:active {
            cursor: grabbing;
        }
        
        .automation-hint {
            position: absolute;
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 9px;
            color: rgba(255, 255, 255, 0.4);
            pointer-events: none;
            white-space: nowrap;
        }
        
        /* EQ Visualizer Toggle */
        .eq-visualizer-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .eq-visualizer-toggle h4 {
            margin: 0;
        }
        
        /* Effect Section Color Coding */
        .effect-section {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        /* Volume Section - Blue Theme */
        .effect-section:nth-of-type(3) {
            background-color: rgba(33, 150, 243, 0.1);
            border-color: rgba(33, 150, 243, 0.3);
        }
        
        .effect-section:nth-of-type(3) h4 {
            color: #2196F3;
        }
        
        .effect-section:nth-of-type(3) .slider-container label {
            color: #64B5F6;
        }
        
        .effect-section:nth-of-type(3) input[type="range"] {
            background: linear-gradient(90deg, #1565C0 0%, #2196F3 100%);
        }
        
        .effect-section:nth-of-type(3) input[type="range"]::-webkit-slider-thumb {
            background: #2196F3;
        }
        
        .effect-section:nth-of-type(3) input[type="range"]::-moz-range-thumb {
            background: #2196F3;
        }
        
        .effect-section:nth-of-type(3) span {
            color: #90CAF9;
        }
        
        /* Speed Section - Green Theme */
        .effect-section:nth-of-type(4) {
            background-color: rgba(76, 175, 80, 0.1);
            border-color: rgba(76, 175, 80, 0.3);
        }
        
        .effect-section:nth-of-type(4) h4 {
            color: #4CAF50;
        }
        
        .effect-section:nth-of-type(4) .speed-selector label {
            color: #81C784;
        }
        
        .effect-section:nth-of-type(4) select {
            background-color: rgba(46, 125, 50, 0.5);
            border-color: rgba(76, 175, 80, 0.5);
        }
        
        /* Individual Tempo Section - Purple Theme */
        .individual-tempo-section {
            background-color: rgba(156, 39, 176, 0.1);
            border-color: rgba(156, 39, 176, 0.3);
        }
        
        .individual-tempo-section h4 {
            color: #9C27B0;
        }
        
        .individual-tempo-section .slider-container label {
            color: #BA68C8;
        }
        
        .individual-tempo-section input[type="range"] {
            background: linear-gradient(90deg, #6A1B9A 0%, #9C27B0 100%);
        }
        
        .individual-tempo-section input[type="range"]::-webkit-slider-thumb {
            background: #9C27B0;
        }
        
        .individual-tempo-section input[type="range"]::-moz-range-thumb {
            background: #9C27B0;
        }
        
        .individual-tempo-section span {
            color: #CE93D8;
        }
        
        /* Delay Section - Orange Theme */
        .effect-section:nth-of-type(6) {
            background-color: rgba(244, 89, 54, 0.1);
            border-color: rgba(255, 152, 0, 0.3);
        }
        
        .effect-section:nth-of-type(6) h4 {
            color: #F44336;
        }
        
        .effect-section:nth-of-type(6) .slider-container label {
            color: #7986CB;
        }
        
        .effect-section:nth-of-type(6) input[type="range"] {
            background: linear-gradient(90deg, #9d3700ff 0%, #b06900ff 100%);
        }
        
        .effect-section:nth-of-type(6) input[type="range"]::-webkit-slider-thumb {
            background: #F44336;
        }
        
        .effect-section:nth-of-type(6) input[type="range"]::-moz-range-thumb {
            background: #F44336;
        }
        
        .effect-section:nth-of-type(6) span {
            color: #F44336;
        }
        
        /* Reverb Section - Teal Theme */
        .effect-section:nth-of-type(7) {
            background-color: rgba(0, 150, 136, 0.1);
            border-color: rgba(0, 150, 136, 0.3);
        }
        
        .effect-section:nth-of-type(7) h4 {
            color: #009688;
        }
        
        .effect-section:nth-of-type(7) .slider-container label {
            color: #4DB6AC;
        }
        
        .effect-section:nth-of-type(7) input[type="range"] {
            background: linear-gradient(90deg, #00695C 0%, #009688 100%);
        }
        
        .effect-section:nth-of-type(7) input[type="range"]::-webkit-slider-thumb {
            background: #009688;
        }
        
        .effect-section:nth-of-type(7) input[type="range"]::-moz-range-thumb {
            background: #009688;
        }
        
        .effect-section:nth-of-type(7) span {
            color: #80CBC4;
        }
        
        /* EQ Section - Red Theme */
        .effect-section:nth-of-type(8) {
            background-color: rgba(244, 67, 54, 0.1);
            border-color: rgba(244, 67, 54, 0.3);
        }
        
        .effect-section:nth-of-type(8) h4 {
            color: #F44336;
        }
        
        .effect-section:nth-of-type(8) .eq-visualizer-toggle h4 {
            color: #F44336;
        }
        
        .effect-section:nth-of-type(8) .eq-frequency-labels span {
            color: #EF5350;
        }
        
        .effect-section:nth-of-type(8) .eq-gain-labels span {
            color: #EF5350;
        }
        
        /* LFO Section - Indigo Theme */
        .lfo-section {
            background-color: rgba(63, 81, 181, 0.1);
            border-color: rgba(63, 81, 181, 0.3);
        }
        
        .lfo-section h4 {
            color: #3F51B5;
        }
        
        .lfo-control label {
            color: #7986CB;
        }
        
        .lfo-control select {
            background-color: rgba(28, 28, 28, 0.5);
            border-color: rgba(178, 35, 35, 0.5);
        }
        
        .lfo-control input[type="range"] {
            background: linear-gradient(90deg, #932828ff 0%, #b53f3fff 100%);
        }
        
        .lfo-control input[type="range"]::-webkit-slider-thumb {
            background: #3F51B5;
        }
        
        .lfo-control input[type="range"]::-moz-range-thumb {
            background: #3F51B5;
        }
        
        .lfo-control span {
            color: #505a94ff;
        }
        
        /* Automation Section - Purple Theme */
        .automation-section {
            background-color: rgba(156, 39, 176, 0.1);
            border-color: rgba(156, 39, 176, 0.3);
        }
        
        .automation-section h4 {
            color: #9C27B0;
        }
        
        .automation-section .automation-control label {
            color: #BA68C8;
        }
        
        .automation-section select {
            background-color: rgba(28, 28, 28, 0.5);
            border-color: rgba(156, 39, 176, 0.5);
        }
        
        .automation-section input[type="range"] {
            background: linear-gradient(90deg, #6A1B9A 0%, #9C27B0 100%);
        }
        
        .automation-section input[type="range"]::-webkit-slider-thumb {
            background: #9C27B0;
        }
        
        .automation-section input[type="range"]::-moz-range-thumb {
            background: #9C27B0;
        }
        
        .automation-section span {
            color: #CE93D8;
        }
        
        .automation-section input[type="text"] {
            background-color: rgba(28, 28, 28, 0.5);
            border-color: rgba(156, 39, 176, 0.5);
            color: #CE93D8;
        }
        
        .automation-section input[type="checkbox"] {
            accent-color: #9C27B0;
        }
        
        /* Piano Roll Section - Amber Theme */
        .piano-roll-section {
            background-color: rgba(7, 255, 168, 0.1);
            border-color: rgba(255, 193, 7, 0.3);
        }
        
        .piano-roll-section h4 {
            color: #FFC107;
        }
        
        .piano-roll-toggle-container h4 {
            color: #FF8C00;
        }
        
        .piano-roll-note-length label {
            color: #FFD54F;
        }
        
        .piano-roll-note-length select {
            background-color: rgba(81, 81, 81, 0.5);
            border-color: rgba(255, 193, 7, 0.5);
            color: white;
        }
        
        .piano-roll-grid-size label {
            color: #00FFFF;
        }
        
        .piano-roll-sound-source label {
            color: #FFD54F;
        }
        
        .piano-roll-sound-source select {
            background-color: rgba(255, 160, 0, 0.5);
            border-color: rgba(255, 193, 7, 0.5);
        }
        
        /* Piano Roll Filters - Brown Theme */
        .piano-roll-filters {
            background-color: rgba(121, 85, 72, 0.1);
            border-color: rgba(121, 85, 72, 0.3);
        }
        
        .piano-roll-filters h4 {
            color: #795548;
        }
        
        .filter-group h5 {
            color: #8D6E63;
        }
        
        .filter-control label {
            color: #2a2a2aff;
        }
        
        .filter-control input[type="range"] {
            background: linear-gradient(90deg, #5D4037 0%, #795548 100%);
        }
        
        .filter-control input[type="range"]::-webkit-slider-thumb {
            background: #795548;
        }
        
        .filter-control input[type="range"]::-moz-range-thumb {
            background: #795548;
        }
        
        .filter-control span {
            color: #BCAAA4;
        }
        
        /* Save/Load Set Button Styles */
        .set-controls {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
        }
        
        .set-btn {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        
        .set-btn:hover {
            background-color: #45a049;
        }
        
        .load-btn {
            background-color: #2196F3;
        }
        
        .load-btn:hover {
            background-color: #0b7dda;
        }
        
        /* Notification styling */
        .notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 9999;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .notification.show {
            opacity: 1;
        }
        
        /* Active button styling for all themes */
        .audio-button.active {
            border: 2px solid #000 !important;
            color: #fff !important;
        }
    `;
    document.head.appendChild(style);

    function updateViewportHeight() {
        let vh = window.innerHeight * .01;
        document.documentElement.style.setProperty("--vh", `${vh}px`);
        updateGridSize();
    }

    function updateGridSize() {
        const buttonGrid = document.getElementById("buttonGrid");
        const gridPanel = document.querySelector(".grid-panel");
        if (!buttonGrid || !gridPanel) return;
        const containerWidth = gridPanel.offsetWidth;
        const containerHeight = gridPanel.offsetHeight;
        let maxSize;
        if (window.innerWidth <= 400 && window.innerHeight <= 500) {
            maxSize = Math.min(containerWidth, containerHeight);
            if (maxSize < 150) {
                maxSize = 150;
            }
        } else if (window.innerWidth <= 768) {
            maxSize = Math.min(containerWidth, containerHeight) * .95;
            if (maxSize < 200) {
                maxSize = 200;
            }
        } else {
            maxSize = Math.min(containerWidth, containerHeight);
            if (maxSize < 200) {
                maxSize = 200;
            }
            if (maxSize > 700) {
                maxSize = 700;
            }
        }
        buttonGrid.style.width = `${maxSize}px`;
        buttonGrid.style.height = `${maxSize}px`;
        buttonGrid.getBoundingClientRect();
        if (effectsPopup) {
            const marginTop = 4;
            const marginBottom = 4;
            const popupHeight = window.innerHeight - marginTop - marginBottom;
            effectsPopup.style.width = `${maxSize}px`;
            effectsPopup.style.height = `${popupHeight}px`;
        }
    }
    updateViewportHeight();
    let resizeTimeout;
    window.addEventListener("resize", function () {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(function () {
            updateViewportHeight();
        }, 100);
    });
    window.addEventListener("orientationchange", function () {
        setTimeout(function () {
            updateViewportHeight();
        }, 300);
    });
    const buttonGrid = document.getElementById("buttonGrid");
    const tempoSlider = document.getElementById("tempo");
    const tempoDisplay = document.getElementById("tempoDisplay");
    const playButton = document.getElementById("playButton");
    const recordButton = document.getElementById("recordButton");
    const saveButton = document.getElementById("saveButton");
    const gridPanel = document.querySelector(".grid-panel");
    if (!buttonGrid || !tempoSlider || !tempoDisplay || !playButton || !recordButton || !saveButton || !gridPanel) {
        console.error("One or more required elements are missing");
        return;
    }
    gridPanel.style.display = "flex";
    gridPanel.style.visibility = "visible";
    
    // Create notification element
    const notification = document.createElement("div");
    notification.className = "notification";
    document.body.appendChild(notification);
    
    // Function to show notification
    function showNotification(message, duration = 3000) {
        notification.textContent = message;
        notification.classList.add("show");
        setTimeout(() => {
            notification.classList.remove("show");
        }, duration);
    }
    
    sampleSelectionPopup = document.createElement("div");
    sampleSelectionPopup.className = "sample-selection-popup";
    sampleSelectionPopup.innerHTML = `
        <div class="popup-header">
            <h3>Select Sample Range</h3>
            <button class="popup-close-btn">Close</button>
        </div>
        <div class="popup-content">
            <div class="sample-selection-info">
                <span>Sample: <strong id="sample-name">Sample ${currentSampleForPopup||1}</strong></span>
                <span>Duration: <strong id="sample-duration">0.00s</strong></span>
            </div>
            <div class="sample-waveform-container">
                <canvas class="sample-waveform" id="sample-selection-waveform"></canvas>
            </div>
            <div class="sample-selection-zoom-controls">
                <button class="sample-selection-zoom-btn" id="zoom-out-btn">−</button>
                <div class="sample-selection-zoom-level" id="zoom-level">100%</div>
                <button class="sample-selection-zoom-btn" id="zoom-in-btn">+</button>
                <button class="sample-selection-zoom-btn" id="zoom-reset-btn">⟲</button>
            </div>
            <div class="sample-selection-controls">
                <div class="sample-selection-range">
                    <label>Start:</label>
                    <input type="range" id="sample-selection-start" min="0" max="100" value="0">
                    <span id="sample-selection-start-value">0.00s</span>
                </div>
                <div class="sample-selection-range">
                    <label>End:</label>
                    <input type="range" id="sample-selection-end" min="0" max="100" value="100">
                    <span id="sample-selection-end-value">0.00s</span>
                </div>
            </div>
            <div class="sample-selection-values">
                <span>Selection Duration: <strong id="selection-duration">0.00s</strong></span>
            </div>
            <div class="sample-selection-preview-controls">
                <button class="sample-selection-preview-btn" id="preview-selection-btn">Preview Selection</button>
                <button class="sample-selection-preview-btn" id="preview-full-btn">Preview Full Sample</button>
            </div>
        </div>
        <div class="popup-footer">
            <button class="popup-close-btn">Close</button>
            <button class="popup-accept-btn">Accept</button>
        </div>
    `;
    document.body.appendChild(sampleSelectionPopup);
    setupSampleSelectionPopupEventListeners();

    function setupSampleSelectionPopupEventListeners() {
        const closeButtons = sampleSelectionPopup.querySelectorAll(".popup-close-btn");
        closeButtons.forEach(btn => {
            btn.addEventListener("click", function () {
                stopSampleSelectionPreview();
                sampleSelectionPopup.style.display = "none";
            });
        });
        const acceptButton = sampleSelectionPopup.querySelector(".popup-accept-btn");
        acceptButton.addEventListener("click", function () {
            if (!currentSampleForSelection) return;
            const data = pianoRollData[currentSampleForSelection];
            data.sampleRange = {
                start: sampleSelectionStart,
                end: sampleSelectionEnd
            };
            stopSampleSelectionPreview();
            sampleSelectionPopup.style.display = "none";
        });
        const startSlider = document.getElementById("sample-selection-start");
        const endSlider = document.getElementById("sample-selection-end");
        startSlider.addEventListener("input", function () {
            sampleSelectionStart = parseInt(this.value);
            if (sampleSelectionStart > sampleSelectionEnd) {
                sampleSelectionStart = sampleSelectionEnd;
                this.value = sampleSelectionStart;
            }
            updateSampleSelectionDisplay();
            drawSampleWaveform();
            if (isPreviewingSelection) {
                previewSampleSelection();
            }
        });
        endSlider.addEventListener("input", function () {
            sampleSelectionEnd = parseInt(this.value);
            if (sampleSelectionEnd < sampleSelectionStart) {
                sampleSelectionEnd = sampleSelectionStart;
                this.value = sampleSelectionEnd;
            }
            updateSampleSelectionDisplay();
            drawSampleWaveform();
            if (isPreviewingSelection) {
                previewSampleSelection();
            }
        });
        document.getElementById("zoom-in-btn").addEventListener("click", function () {
            if (sampleSelectionZoomLevel < 4) {
                sampleSelectionZoomLevel *= 2;
                updateZoomLevel();
                drawSampleWaveform();
            }
        });
        document.getElementById("zoom-out-btn").addEventListener("click", function () {
            if (sampleSelectionZoomLevel > .25) {
                sampleSelectionZoomLevel /= 2;
                updateZoomLevel();
                drawSampleWaveform();
            }
        });
        document.getElementById("zoom-reset-btn").addEventListener("click", function () {
            sampleSelectionZoomLevel = 1;
            updateZoomLevel();
            drawSampleWaveform();
        });
        document.getElementById("preview-selection-btn").addEventListener("click", function () {
            if (isPreviewingSelection) {
                stopSampleSelectionPreview();
            } else {
                previewSampleSelection();
            }
        });
        document.getElementById("preview-full-btn").addEventListener("click", function () {
            if (isPreviewingSelection) {
                stopSampleSelectionPreview();
            } else {
                previewFullSample();
            }
        });
    }

    function updateZoomLevel() {
        document.getElementById("zoom-level").textContent = `${Math.round(sampleSelectionZoomLevel*100)}%`;
    }

    function previewSampleSelection() {
        if (!currentSampleForSelection || !currentPlaying[currentSampleForSelection].buffer) return;
        stopSampleSelectionPreview();
        const sample = currentPlaying[currentSampleForSelection];
        const buffer = sample.buffer;
        const bufferDuration = buffer.duration;
        const startTime = bufferDuration * (sampleSelectionStart / 100);
        const endTime = bufferDuration * (sampleSelectionEnd / 100);
        const selectionDuration = endTime - startTime;
        sampleSelectionPreviewSource = audioContext.createBufferSource();
        sampleSelectionPreviewSource.buffer = buffer;
        sampleSelectionPreviewSource.loop = true;
        sampleSelectionPreviewSource.loopStart = startTime;
        sampleSelectionPreviewSource.loopEnd = endTime;
        sampleSelectionPreviewGain = audioContext.createGain();
        sampleSelectionPreviewGain.gain.value = .7;
        sampleSelectionPreviewSource.connect(sampleSelectionPreviewGain);
        sampleSelectionPreviewGain.connect(audioContext.destination);
        sampleSelectionPreviewSource.start(0, startTime);
        isPreviewingSelection = true;
        document.getElementById("preview-selection-btn").textContent = "Stop Preview";
    }

    function previewFullSample() {
        if (!currentSampleForSelection || !currentPlaying[currentSampleForSelection].buffer) return;
        stopSampleSelectionPreview();
        const sample = currentPlaying[currentSampleForSelection];
        const buffer = sample.buffer;
        sampleSelectionPreviewSource = audioContext.createBufferSource();
        sampleSelectionPreviewSource.buffer = buffer;
        sampleSelectionPreviewSource.loop = true;
        sampleSelectionPreviewGain = audioContext.createGain();
        sampleSelectionPreviewGain.gain.value = .7;
        sampleSelectionPreviewSource.connect(sampleSelectionPreviewGain);
        sampleSelectionPreviewGain.connect(audioContext.destination);
        sampleSelectionPreviewSource.start(0);
        isPreviewingSelection = true;
        document.getElementById("preview-full-btn").textContent = "Stop Preview";
    }

    function stopSampleSelectionPreview() {
        if (sampleSelectionPreviewSource) {
            try {
                sampleSelectionPreviewSource.stop();
                sampleSelectionPreviewSource.disconnect();
            } catch (e) {}
            sampleSelectionPreviewSource = null;
        }
        if (sampleSelectionPreviewGain) {
            try {
                sampleSelectionPreviewGain.disconnect();
            } catch (e) {}
            sampleSelectionPreviewGain = null;
        }
        isPreviewingSelection = false;
        document.getElementById("preview-selection-btn").textContent = "Preview Selection";
        document.getElementById("preview-full-btn").textContent = "Preview Full Sample";
    }

    function updateSampleSelectionDisplay() {
        if (!currentSampleForSelection) return;
        const sample = currentPlaying[currentSampleForSelection];
        if (!sample.buffer) return;
        const bufferDuration = sample.buffer.duration;
        const startTime = bufferDuration * (sampleSelectionStart / 100);
        const endTime = bufferDuration * (sampleSelectionEnd / 100);
        const selectionDuration = endTime - startTime;
        document.getElementById("sample-selection-start-value").textContent = startTime.toFixed(2) + "s";
        document.getElementById("sample-selection-end-value").textContent = endTime.toFixed(2) + "s";
        document.getElementById("selection-duration").textContent = selectionDuration.toFixed(2) + "s";
    }

    function drawSampleWaveform() {
        if (!currentSampleForSelection) return;
        const sample = currentPlaying[currentSampleForSelection];
        const canvas = document.getElementById("sample-selection-waveform");
        const ctx = canvas.getContext("2d");
        if (!sample.buffer) return;
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        bgGradient.addColorStop(0, "#1a1a1a");
        bgGradient.addColorStop(1, "#0a0a0a");
        ctx.fillStyle = bgGradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        const buffer = sample.buffer;
        const data = buffer.getChannelData(0);
        const startSample = Math.floor(data.length * (sampleSelectionStart / 100));
        const endSample = Math.ceil(data.length * (sampleSelectionEnd / 100));
        const visibleRange = endSample - startSample;
        const zoomedRange = Math.floor(visibleRange / sampleSelectionZoomLevel);
        const centerPoint = startSample + visibleRange / 2;
        const zoomedStart = Math.max(0, Math.floor(centerPoint - zoomedRange / 2));
        const zoomedEnd = Math.min(data.length, Math.ceil(centerPoint + zoomedRange / 2));
        ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
        ctx.lineWidth = 1;
        for (let i = 0; i <= 4; i++) {
            const y = canvas.height / 4 * i;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }
        for (let i = 0; i <= 8; i++) {
            const x = canvas.width / 8 * i;
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
        }
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, "rgba(76, 175, 80, 0.8)");
        gradient.addColorStop(.5, "rgba(76, 175, 80, 0.5)");
        gradient.addColorStop(1, "rgba(76, 175, 80, 0.8)");
        ctx.fillStyle = gradient;
        ctx.beginPath();
        const step = Math.ceil((zoomedEnd - zoomedStart) / canvas.width);
        const amp = canvas.height / 2;
        for (let i = 0; i < canvas.width; i++) {
            let min = 1;
            let max = -1;
            for (let j = 0; j < step; j++) {
                const datum = data[zoomedStart + i * step + j];
                if (datum < min) min = datum;
                if (datum > max) max = datum;
            }
            ctx.fillRect(i, (1 + min) * amp, 1, Math.max(1, (max - min) * amp));
        }
        const selectionStartPixel = (startSample - zoomedStart) / (zoomedEnd - zoomedStart) * canvas.width;
        const selectionEndPixel = (endSample - zoomedStart) / (zoomedEnd - zoomedStart) * canvas.width;
        ctx.fillStyle = "rgba(255, 152, 0, 0.2)";
        ctx.fillRect(selectionStartPixel, 0, selectionEndPixel - selectionStartPixel, canvas.height);
        ctx.fillStyle = "#FF9800";
        ctx.fillRect(selectionStartPixel - 2, 0, 4, canvas.height);
        ctx.fillRect(selectionEndPixel - 2, 0, 4, canvas.height);
        ctx.beginPath();
        ctx.arc(selectionStartPixel, canvas.height / 2, 8, 0, Math.PI * 2);
        ctx.fillStyle = "#FF9800";
        ctx.fill();
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(selectionEndPixel, canvas.height / 2, 8, 0, Math.PI * 2);
        ctx.fillStyle = "#FF9800";
        ctx.fill();
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = "#aaa";
        ctx.font = "12px Arial";
        ctx.textAlign = "center";
        const startTime = buffer.duration * (sampleSelectionStart / 100);
        const endTime = buffer.duration * (sampleSelectionEnd / 100);
        const zoomedStartTime = buffer.duration * (zoomedStart / data.length);
        const zoomedEndTime = buffer.duration * (zoomedEnd / data.length);
        ctx.fillText(`${zoomedStartTime.toFixed(2)}s`, 30, canvas.height - 10);
        ctx.fillText(`${zoomedEndTime.toFixed(2)}s`, canvas.width - 30, canvas.height - 10);
        if (selectionStartPixel > 20 && selectionStartPixel < canvas.width - 20) {
            ctx.fillStyle = "#FF9800";
            ctx.fillText(`${startTime.toFixed(2)}s`, selectionStartPixel, canvas.height - 10);
        }
        if (selectionEndPixel > 20 && selectionEndPixel < canvas.width - 20) {
            ctx.fillStyle = "#FF9800";
            ctx.fillText(`${endTime.toFixed(2)}s`, selectionEndPixel, canvas.height - 10);
        }
    }

    function initializeAudioContext() {
        if (audioContext) return;
        try {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (!AudioContext) {
                throw new Error("Web Audio API is not supported in this browser");
            }
            audioContext = new AudioContext;
            audioContext.addEventListener("statechange", () => {
                console.log("Audio context state:", audioContext.state);
                if (audioContext.state === "interrupted") {
                    showNotification("Audio was interrupted. Please tap to resume.");
                }
            });
            console.log("Audio context initialized successfully");
        } catch (e) {
            console.error("Error initializing audio context:", e);
            showNotification("Audio initialization failed. Please try a different browser.");
        }
    }

    function resumeAudioContext() {
        if (audioContext && audioContext.state === "suspended") {
            audioContext.resume().then(() => {
                console.log("Audio context resumed successfully");
            })["catch"](e => {
                console.error("Error resuming audio context:", e);
            });
        }
    }
    initializeAudioContext();
    let masterOutputNode = audioContext.createGain();
    masterOutputNode.connect(audioContext.destination);
    effectsPopup.innerHTML = `
        <div class="popup-header">
            <h3>Effects for Sample <span id="popup-sample-number">1</span></h3>
            <button class="popup-close-btn">Close</button>
        </div>
        <div class="popup-content">
            <div class="effect-section">
                <h4>Sample</h4>
                <div class="sample-upload">
                    <label for="sample-upload"></label>
                    <input type="file" id="sample-upload" accept="audio/*,.wav,.mp3,.ogg,.aac,.flac,.m4a,.wma">
                    <div class="upload-status" id="upload-status"></div>
                </div>
                <div class="sample-record">
                    <label>Record:</label>
                    <div class="record-controls">
                        <button id="microphone-record-btn" class="microphone-record-btn">Start Recording</button>
                        <button id="microphone-save-btn" class="microphone-save-btn" style="display: none;">Save Recording</button>
                        <button id="microphone-download-btn" class="microphone-download-btn" style="display: none;">Download</button>
                        <button id="microphone-delete-btn" class="microphone-delete-btn" style="display: none;">Delete</button>
                    </div>
                    <div class="record-status" id="record-status"></div>
                </div>
            </div>
            <div class="effect-section">
            <hr color="purple">
            <br>
                <h4>VOLUME</h4>
                <div class="slider-container">
                    <label>Gain</label>
                    <input type="range" id="sample-volume" min="0" max="200" value="100" step="1">
                    <span id="sample-volume-value">100%</span>
                </div>
            </div>
            <div class="effect-section">
            <hr color="grey">
            <br>
                <h4>SPEED</h4>
                <div class="speed-selector">
                    <label for="speed-select">Speed:</label>
                    <select id="speed-select">
                        <option value="0.03125">0.03125x</option>
                        <option value="0.0625">0.0625x</option>
                        <option value="0.125">0.125x</option>
                        <option value="0.25">0.25x</option>
                        <option value="0.5">0.5x</option>
                        <option value="1" selected>1x</option>
                        <option value="1.5">1.5x</option>
                        <option value="2">2x</option>
                    </select>
                </div>
            </div>
            <div class="effect-section individual-tempo-section">
            <hr color="grey">
            <br>
                <h4>Individual Tempo</h4>
                <div class="slider-container">
                    <label>Tempo Multiplier</label>
                    <input type="range" id="individual-tempo" min="0.1" max="5.0" value="1.0" step="0.01">
                    <span id="individual-tempo-value">1.0</span>
                </div>
            </div>
            <div class="effect-section">
            <hr color="grey">
            <br>
                <h4>DELAY</h4>
                <div class="slider-container">
                    <label>Time (ms)</label>
                    <input type="range" id="delay-time" min="0" max="1000" value="0" step="10">
                    <span id="delay-time-value">0</span>
                </div>
                <div class="slider-container">
                    <label>Feedback (%)</label>
                    <input type="range" id="delay-feedback" min="0" max="100" value="0" step="1">
                    <span id="delay-feedback-value">0</span>
                </div>
            </div>
            <div class="effect-section">
            <hr color="grey">
            <br>
                <h4>REVERB</h4>
                <div class="slider-container">
                    <label>Decay (s)</label>
                    <input type="range" id="reverb-decay" min="0.1" max="5" value="0" step="0.1">
                    <span id="reverb-decay-value">0</span>
                </div>
                <div class="slider-container">
                    <label>Pre-delay (ms)</label>
                    <input type="range" id="reverb-predelay" min="0" max="100" value="0" step="1">
                    <span id="reverb-predelay-value">0</span>
                </div>
                <div class="slider-container">
                    <label>Diffusion (%)</label>
                    <input type="range" id="reverb-diffusion" min="0" max="100" value="50" step="1">
                    <span id="reverb-diffusion-value">50</span>
                </div>
                <div class="slider-container">
                    <label>Low Cut (Hz)</label>
                    <input type="range" id="reverb-lowcut" min="20" max="1000" value="20" step="10">
                    <span id="reverb-lowcut-value">20</span>
                </div>
                <div class="slider-container">
                    <label>High Cut (Hz)</label>
                    <input type="range" id="reverb-highcut" min="1000" max="20000" value="20000" step="100">
                    <span id="reverb-highcut-value">20000</span>
                </div>
                <div class="slider-container">
                    <label>Damping (%)</label>
                    <input type="range" id="reverb-damping" min="0" max="100" value="50" step="1">
                    <span id="reverb-damping-value">50</span>
                </div>
                <div class="slider-container">
                    <label>Wet/Dry (%)</label>
                    <input type="range" id="reverb-mix" min="0" max="100" value="0" step="1">
                    <span id="reverb-mix-value">0</span>
                </div>
            </div>
            <div class="effect-section">
            <hr color="grey">
            <br>
                <div class="eq-visualizer-toggle">
                    <h4>EQUALIZER</h4>
                    <label class="switch">
                        <input type="checkbox" id="eq-visualizer-toggle">
                        <span class="slider round"></span>
                    </label>
                </div>
                <div class="professional-eq-container">
                    <div class="visual-eq-container">
                        <canvas class="eq-canvas" id="eq-canvas"></canvas>
                        <div class="eq-frequency-labels">
                            <span>20Hz</span>
                            <span>100Hz</span>
                            <span>1kHz</span>
                            <span>10kHz</span>
                            <span>20kHz</span>
                        </div>
                        <div class="eq-gain-labels">
                            <span>+24dB</span>
                            <span>+12dB</span>
                            <span>0dB</span>
                            <span>-12dB</span>
                            <span>-24dB</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- LFO Section - Moved from Piano Roll to Main Effects -->
            <div class="effect-section lfo-section">
            <hr color="grey">
            <br>
                <h4>LFO MODULATORS</h4>
                
                <!-- LFO Tabs -->
                <div class="lfo-tabs">
                    <button class="lfo-tab active" data-lfo="1">LFO 1</button>
                    <button class="lfo-tab" data-lfo="2">LFO 2</button>
                    <button class="lfo-tab" data-lfo="3">LFO 3</button>
                    <button class="lfo-tab" data-lfo="4">LFO 4</button>
                </div>
                
                <!-- LFO 1 -->
                <div class="lfo-panel active" id="lfo-panel-1">
                    <div class="lfo-control">
                        <label>Target:</label>
                        <select id="lfo-1-target" class="lfo-target">
                            <option value="none">-- None --</option>
                            <option value="pitch">Pitch</option>
                            <option value="volume">Volume</option>
                            <option value="filter">Filter Cutoff</option>
                            <option value="delay-time">Delay Time</option>
                            <option value="delay-feedback">Delay Feedback</option>
                            <option value="eq-low">EQ Low</option>
                            <option value="eq-lowmid">EQ Low-Mid</option>
                            <option value="eq-mid">EQ Mid</option>
                            <option value="eq-highmid">EQ High-Mid</option>
                            <option value="eq-high">EQ High</option>
                            <option value="pan">Panning</option>
                        </select>
                    </div>
                    <div class="lfo-control">
                        <label>Waveform:</label>
                        <select id="lfo-1-waveform" class="lfo-waveform">
                            <option value="sine">Sine</option>
                            <option value="square">Square</option>
                            <option value="triangle">Triangle</option>
                            <option value="sawtooth">Sawtooth</option>
                        </select>
                    </div>
                    <div class="lfo-control">
                        <label>Rate (Hz):</label>
                        <input type="range" id="lfo-1-rate" class="lfo-rate" min="0.1" max="20" value="1" step="0.1">
                        <span id="lfo-1-rate-value" class="lfo-rate-value">1.0</span>
                    </div>
                    <div class="lfo-control">
                        <label>Depth (%):</label>
                        <input type="range" id="lfo-1-depth" class="lfo-depth" min="0" max="100" value="0" step="1">
                        <span id="lfo-1-depth-value" class="lfo-depth-value">0%</span>
                    </div>
                    <div class="lfo-visualizer">
                        <canvas class="lfo-wave" id="lfo-1-wave"></canvas>
                    </div>
                </div>
                
                <!-- LFO 2 -->
                <div class="lfo-panel" id="lfo-panel-2">
                    <div class="lfo-control">
                        <label>Target:</label>
                        <select id="lfo-2-target" class="lfo-target">
                            <option value="none">-- None --</option>
                            <option value="pitch">Pitch</option>
                            <option value="volume">Volume</option>
                            <option value="filter">Filter Cutoff</option>
                            <option value="delay-time">Delay Time</option>
                            <option value="delay-feedback">Delay Feedback</option>
                            <option value="eq-low">EQ Low</option>
                            <option value="eq-lowmid">EQ Low-Mid</option>
                            <option value="eq-mid">EQ Mid</option>
                            <option value="eq-highmid">EQ High-Mid</option>
                            <option value="eq-high">EQ High</option>
                            <option value="pan">Panning</option>
                        </select>
                    </div>
                    <div class="lfo-control">
                        <label>Waveform:</label>
                        <select id="lfo-2-waveform" class="lfo-waveform">
                            <option value="sine">Sine</option>
                            <option value="square">Square</option>
                            <option value="triangle">Triangle</option>
                            <option value="sawtooth">Sawtooth</option>
                        </select>
                    </div>
                    <div class="lfo-control">
                        <label>Rate (Hz):</label>
                        <input type="range" id="lfo-2-rate" class="lfo-rate" min="0.1" max="20" value="1" step="0.1">
                        <span id="lfo-2-rate-value" class="lfo-rate-value">1.0</span>
                    </div>
                    <div class="lfo-control">
                        <label>Depth (%):</label>
                        <input type="range" id="lfo-2-depth" class="lfo-depth" min="0" max="100" value="0" step="1">
                        <span id="lfo-2-depth-value" class="lfo-depth-value">0%</span>
                    </div>
                    <div class="lfo-visualizer">
                        <canvas class="lfo-wave" id="lfo-2-wave"></canvas>
                    </div>
                </div>
                
                <!-- LFO 3 -->
                <div class="lfo-panel" id="lfo-panel-3">
                    <div class="lfo-control">
                        <label>Target:</label>
                        <select id="lfo-3-target" class="lfo-target">
                            <option value="none">-- None --</option>
                            <option value="pitch">Pitch</option>
                            <option value="volume">Volume</option>
                            <option value="filter">Filter Cutoff</option>
                            <option value="delay-time">Delay Time</option>
                            <option value="delay-feedback">Delay Feedback</option>
                            <option value="eq-low">EQ Low</option>
                            <option value="eq-lowmid">EQ Low-Mid</option>
                            <option value="eq-mid">EQ Mid</option>
                            <option value="eq-highmid">EQ High-Mid</option>
                            <option value="eq-high">EQ High</option>
                            <option value="pan">Panning</option>
                        </select>
                    </div>
                    <div class="lfo-control">
                        <label>Waveform:</label>
                        <select id="lfo-3-waveform" class="lfo-waveform">
                            <option value="sine">Sine</option>
                            <option value="square">Square</option>
                            <option value="triangle">Triangle</option>
                            <option value="sawtooth">Sawtooth</option>
                        </select>
                    </div>
                    <div class="lfo-control">
                        <label>Rate (Hz):</label>
                        <input type="range" id="lfo-3-rate" class="lfo-rate" min="0.1" max="20" value="1" step="0.1">
                        <span id="lfo-3-rate-value" class="lfo-rate-value">1.0</span>
                    </div>
                    <div class="lfo-control">
                        <label>Depth (%):</label>
                        <input type="range" id="lfo-3-depth" class="lfo-depth" min="0" max="100" value="0" step="1">
                        <span id="lfo-3-depth-value" class="lfo-depth-value">0%</span>
                    </div>
                    <div class="lfo-visualizer">
                        <canvas class="lfo-wave" id="lfo-3-wave"></canvas>
                    </div>
                </div>
                
                <!-- LFO 4 -->
                <div class="lfo-panel" id="lfo-panel-4">
                    <div class="lfo-control">
                        <label>Target:</label>
                        <select id="lfo-4-target" class="lfo-target">
                            <option value="none">-- None --</option>
                            <option value="pitch">Pitch</option>
                            <option value="volume">Volume</option>
                            <option value="filter">Filter Cutoff</option>
                            <option value="delay-time">Delay Time</option>
                            <option value="delay-feedback">Delay Feedback</option>
                            <option value="eq-low">EQ Low</option>
                            <option value="eq-lowmid">EQ Low-Mid</option>
                            <option value="eq-mid">EQ Mid</option>
                            <option value="eq-highmid">EQ High-Mid</option>
                            <option value="eq-high">EQ High</option>
                            <option value="pan">Panning</option>
                        </select>
                    </div>
                    <div class="lfo-control">
                        <label>Waveform:</label>
                        <select id="lfo-4-waveform" class="lfo-waveform">
                            <option value="sine">Sine</option>
                            <option value="square">Square</option>
                            <option value="triangle">Triangle</option>
                            <option value="sawtooth">Sawtooth</option>
                        </select>
                    </div>
                    <div class="lfo-control">
                        <label>Rate (Hz):</label>
                        <input type="range" id="lfo-4-rate" class="lfo-rate" min="0.1" max="20" value="1" step="0.1">
                        <span id="lfo-4-rate-value" class="lfo-rate-value">1.0</span>
                    </div>
                    <div class="lfo-control">
                        <label>Depth (%):</label>
                        <input type="range" id="lfo-4-depth" class="lfo-depth" min="0" max="100" value="0" step="1">
                        <span id="lfo-4-depth-value" class="lfo-depth-value">0%</span>
                    </div>
                    <div class="lfo-visualizer">
                        <canvas class="lfo-wave" id="lfo-4-wave"></canvas>
                    </div>
                </div>
            </div>
            
            <!-- Automation Section -->
            <div class="effect-section automation-section">
            <hr color="grey">
            <br>
                <h4>AUTOMATION</h4>
                
                <!-- Automation Tabs -->
                <div class="automation-tabs">
                    <button class="automation-tab active" data-automation="1">Auto 1</button>
                    <button class="automation-tab" data-automation="2">Auto 2</button>
                    <button class="automation-tab" data-automation="3">Auto 3</button>
                    <button class="automation-tab" data-automation="4">Auto 4</button>
                </div>
                
                <!-- Automation 1 -->
                <div class="automation-panel active" id="automation-panel-1">
                    <div class="automation-control">
                        <label>Target:</label>
                        <select id="automation-1-target" class="automation-target">
                            <option value="none">-- None --</option>
                            <option value="volume">Volume</option>
                            <option value="pitch">Pitch</option>
                            <option value="speed">Speed</option>
                            <option value="filter">Filter Cutoff</option>
                            <option value="delay-time">Delay Time</option>
                            <option value="delay-feedback">Delay Feedback</option>
                            <option value="reverb-mix">Reverb Mix</option>
                            <option value="reverb-time">Reverb Time</option>
                            <option value="eq-low">EQ Low</option>
                            <option value="eq-lowmid">EQ Low-Mid</option>
                            <option value="eq-mid">EQ Mid</option>
                            <option value="eq-highmid">EQ High-Mid</option>
                            <option value="eq-high">EQ High</option>
                            <option value="pan">Panning</option>
                            <option value="lfo-1-depth">LFO 1 Depth</option>
                            <option value="lfo-1-rate">LFO 1 Rate</option>
                            <option value="lfo-2-depth">LFO 2 Depth</option>
                            <option value="lfo-2-rate">LFO 2 Rate</option>
                            <option value="lfo-3-depth">LFO 3 Depth</option>
                            <option value="lfo-3-rate">LFO 3 Rate</option>
                            <option value="lfo-4-depth">LFO 4 Depth</option>
                            <option value="lfo-4-rate">LFO 4 Rate</option>
                        </select>
                    </div>
                    <div class="automation-control">
                        <label>Start Value:</label>
                        <input type="range" id="automation-1-start" class="automation-start" min="0" max="100" value="50" step="1">
                        <span id="automation-1-start-value" class="automation-start-value">50</span>
                    </div>
                    <div class="automation-control">
                        <label>End Value:</label>
                        <input type="range" id="automation-1-end" class="automation-end" min="0" max="100" value="50" step="1">
                        <span id="automation-1-end-value" class="automation-end-value">50</span>
                    </div>
                    <div class="automation-control">
                        <label>Duration (bars):</label>
                        <input type="range" id="automation-1-duration" class="automation-duration" min="1" max="32" value="1" step="1">
                        <span id="automation-1-duration-value" class="automation-duration-value">1</span>
                    </div>
                    <div class="automation-control">
                        <label>Active Bars:</label>
                        <input type="text" id="automation-1-bars" class="automation-bars" placeholder="1,2,5-8 or * for all" value="*">
                        <span class="automation-bars-hint">Examples: *, 1, 1-4, 1,3,5</span>
                    </div>
                    <div class="automation-control">
                        <label>Loop:</label>
                        <input type="checkbox" id="automation-1-loop" class="automation-loop" checked>
                        <span class="automation-loop-hint">When off, stays at end value</span>
                    </div>
                    <div class="automation-control">
                        <label>Curve:</label>
                        <select id="automation-1-curve" class="automation-curve">
                            <option value="linear">Linear</option>
                            <option value="exponential">Exponential</option>
                            <option value="logarithmic">Logarithmic</option>
                        </select>
                    </div>
                    <div class="automation-visualizer">
                        <canvas class="automation-canvas" id="automation-1-canvas"></canvas>
                    </div>
                </div>
                
                <!-- Automation 2 -->
                <div class="automation-panel" id="automation-panel-2">
                    <div class="automation-control">
                        <label>Target:</label>
                        <select id="automation-2-target" class="automation-target">
                            <option value="none">-- None --</option>
                            <option value="volume">Volume</option>
                            <option value="pitch">Pitch</option>
                            <option value="speed">Speed</option>
                            <option value="filter">Filter Cutoff</option>
                            <option value="delay-time">Delay Time</option>
                            <option value="delay-feedback">Delay Feedback</option>
                            <option value="reverb-mix">Reverb Mix</option>
                            <option value="reverb-time">Reverb Time</option>
                            <option value="eq-low">EQ Low</option>
                            <option value="eq-lowmid">EQ Low-Mid</option>
                            <option value="eq-mid">EQ Mid</option>
                            <option value="eq-highmid">EQ High-Mid</option>
                            <option value="eq-high">EQ High</option>
                            <option value="pan">Panning</option>
                            <option value="lfo-1-depth">LFO 1 Depth</option>
                            <option value="lfo-1-rate">LFO 1 Rate</option>
                            <option value="lfo-2-depth">LFO 2 Depth</option>
                            <option value="lfo-2-rate">LFO 2 Rate</option>
                            <option value="lfo-3-depth">LFO 3 Depth</option>
                            <option value="lfo-3-rate">LFO 3 Rate</option>
                            <option value="lfo-4-depth">LFO 4 Depth</option>
                            <option value="lfo-4-rate">LFO 4 Rate</option>
                        </select>
                    </div>
                    <div class="automation-control">
                        <label>Start Value:</label>
                        <input type="range" id="automation-2-start" class="automation-start" min="0" max="100" value="50" step="1">
                        <span id="automation-2-start-value" class="automation-start-value">50</span>
                    </div>
                    <div class="automation-control">
                        <label>End Value:</label>
                        <input type="range" id="automation-2-end" class="automation-end" min="0" max="100" value="50" step="1">
                        <span id="automation-2-end-value" class="automation-end-value">50</span>
                    </div>
                    <div class="automation-control">
                        <label>Duration (bars):</label>
                        <input type="range" id="automation-2-duration" class="automation-duration" min="1" max="32" value="1" step="1">
                        <span id="automation-2-duration-value" class="automation-duration-value">1</span>
                    </div>
                    <div class="automation-control">
                        <label>Active Bars:</label>
                        <input type="text" id="automation-2-bars" class="automation-bars" placeholder="1,2,5-8 or * for all" value="*">
                        <span class="automation-bars-hint">Examples: *, 1, 1-4, 1,3,5</span>
                    </div>
                    <div class="automation-control">
                        <label>Loop:</label>
                        <input type="checkbox" id="automation-2-loop" class="automation-loop" checked>
                        <span class="automation-loop-hint">When off, stays at end value</span>
                    </div>
                    <div class="automation-control">
                        <label>Curve:</label>
                        <select id="automation-2-curve" class="automation-curve">
                            <option value="linear">Linear</option>
                            <option value="exponential">Exponential</option>
                            <option value="logarithmic">Logarithmic</option>
                        </select>
                    </div>
                    <div class="automation-visualizer">
                        <canvas class="automation-canvas" id="automation-2-canvas"></canvas>
                    </div>
                </div>
                
                <!-- Automation 3 -->
                <div class="automation-panel" id="automation-panel-3">
                    <div class="automation-control">
                        <label>Target:</label>
                        <select id="automation-3-target" class="automation-target">
                            <option value="none">-- None --</option>
                            <option value="volume">Volume</option>
                            <option value="pitch">Pitch</option>
                            <option value="speed">Speed</option>
                            <option value="filter">Filter Cutoff</option>
                            <option value="delay-time">Delay Time</option>
                            <option value="delay-feedback">Delay Feedback</option>
                            <option value="reverb-mix">Reverb Mix</option>
                            <option value="reverb-time">Reverb Time</option>
                            <option value="eq-low">EQ Low</option>
                            <option value="eq-lowmid">EQ Low-Mid</option>
                            <option value="eq-mid">EQ Mid</option>
                            <option value="eq-highmid">EQ High-Mid</option>
                            <option value="eq-high">EQ High</option>
                            <option value="pan">Panning</option>
                            <option value="lfo-1-depth">LFO 1 Depth</option>
                            <option value="lfo-1-rate">LFO 1 Rate</option>
                            <option value="lfo-2-depth">LFO 2 Depth</option>
                            <option value="lfo-2-rate">LFO 2 Rate</option>
                            <option value="lfo-3-depth">LFO 3 Depth</option>
                            <option value="lfo-3-rate">LFO 3 Rate</option>
                            <option value="lfo-4-depth">LFO 4 Depth</option>
                            <option value="lfo-4-rate">LFO 4 Rate</option>
                        </select>
                    </div>
                    <div class="automation-control">
                        <label>Start Value:</label>
                        <input type="range" id="automation-3-start" class="automation-start" min="0" max="100" value="50" step="1">
                        <span id="automation-3-start-value" class="automation-start-value">50</span>
                    </div>
                    <div class="automation-control">
                        <label>End Value:</label>
                        <input type="range" id="automation-3-end" class="automation-end" min="0" max="100" value="50" step="1">
                        <span id="automation-3-end-value" class="automation-end-value">50</span>
                    </div>
                    <div class="automation-control">
                        <label>Duration (bars):</label>
                        <input type="range" id="automation-3-duration" class="automation-duration" min="1" max="32" value="1" step="1">
                        <span id="automation-3-duration-value" class="automation-duration-value">1</span>
                    </div>
                    <div class="automation-control">
                        <label>Active Bars:</label>
                        <input type="text" id="automation-3-bars" class="automation-bars" placeholder="1,2,5-8 or * for all" value="*">
                        <span class="automation-bars-hint">Examples: *, 1, 1-4, 1,3,5</span>
                    </div>
                    <div class="automation-control">
                        <label>Loop:</label>
                        <input type="checkbox" id="automation-3-loop" class="automation-loop" checked>
                        <span class="automation-loop-hint">When off, stays at end value</span>
                    </div>
                    <div class="automation-control">
                        <label>Curve:</label>
                        <select id="automation-3-curve" class="automation-curve">
                            <option value="linear">Linear</option>
                            <option value="exponential">Exponential</option>
                            <option value="logarithmic">Logarithmic</option>
                        </select>
                    </div>
                    <div class="automation-visualizer">
                        <canvas class="automation-canvas" id="automation-3-canvas"></canvas>
                    </div>
                </div>
                
                <!-- Automation 4 -->
                <div class="automation-panel" id="automation-panel-4">
                    <div class="automation-control">
                        <label>Target:</label>
                        <select id="automation-4-target" class="automation-target">
                            <option value="none">-- None --</option>
                            <option value="volume">Volume</option>
                            <option value="pitch">Pitch</option>
                            <option value="speed">Speed</option>
                            <option value="filter">Filter Cutoff</option>
                            <option value="delay-time">Delay Time</option>
                            <option value="delay-feedback">Delay Feedback</option>
                            <option value="reverb-mix">Reverb Mix</option>
                            <option value="reverb-time">Reverb Time</option>
                            <option value="eq-low">EQ Low</option>
                            <option value="eq-lowmid">EQ Low-Mid</option>
                            <option value="eq-mid">EQ Mid</option>
                            <option value="eq-highmid">EQ High-Mid</option>
                            <option value="eq-high">EQ High</option>
                            <option value="pan">Panning</option>
                            <option value="lfo-1-depth">LFO 1 Depth</option>
                            <option value="lfo-1-rate">LFO 1 Rate</option>
                            <option value="lfo-2-depth">LFO 2 Depth</option>
                            <option value="lfo-2-rate">LFO 2 Rate</option>
                            <option value="lfo-3-depth">LFO 3 Depth</option>
                            <option value="lfo-3-rate">LFO 3 Rate</option>
                            <option value="lfo-4-depth">LFO 4 Depth</option>
                            <option value="lfo-4-rate">LFO 4 Rate</option>
                        </select>
                    </div>
                    <div class="automation-control">
                        <label>Start Value:</label>
                        <input type="range" id="automation-4-start" class="automation-start" min="0" max="100" value="50" step="1">
                        <span id="automation-4-start-value" class="automation-start-value">50</span>
                    </div>
                    <div class="automation-control">
                        <label>End Value:</label>
                        <input type="range" id="automation-4-end" class="automation-end" min="0" max="100" value="50" step="1">
                        <span id="automation-4-end-value" class="automation-end-value">50</span>
                    </div>
                    <div class="automation-control">
                        <label>Duration (bars):</label>
                        <input type="range" id="automation-4-duration" class="automation-duration" min="1" max="32" value="1" step="1">
                        <span id="automation-4-duration-value" class="automation-duration-value">1</span>
                    </div>
                    <div class="automation-control">
                        <label>Active Bars:</label>
                        <input type="text" id="automation-4-bars" class="automation-bars" placeholder="1,2,5-8 or * for all" value="*">
                        <span class="automation-bars-hint">Examples: *, 1, 1-4, 1,3,5</span>
                    </div>
                    <div class="automation-control">
                        <label>Loop:</label>
                        <input type="checkbox" id="automation-4-loop" class="automation-loop" checked>
                        <span class="automation-loop-hint">When off, stays at end value</span>
                    </div>
                    <div class="automation-control">
                        <label>Curve:</label>
                        <select id="automation-4-curve" class="automation-curve">
                            <option value="linear">Linear</option>
                            <option value="exponential">Exponential</option>
                            <option value="logarithmic">Logarithmic</option>
                        </select>
                    </div>
                    <div class="automation-visualizer">
                        <canvas class="automation-canvas" id="automation-4-canvas"></canvas>
                    </div>
                </div>
            </div>
            
            <div class="effect-section piano-roll-section">
            <hr color="brightgrey">
            <br>
                <div class="piano-roll-toggle-container">
                    <h4>SYNTH</h4>
                    <label class="switch">
                        <input type="checkbox" id="piano-roll-toggle">
                        <span class="slider round"></span>
                    </label>
                </div>
                <div class="piano-roll-content">
                    <div class="piano-roll-controls-row">
                        <div class="piano-roll-note-length">
                            <label>Note Length:</label>
                            <div class="note-length-controls">
                                <button id="note-length-decrease">-</button>
                                <span id="note-length-display">1/16</span>
                                <button id="note-length-increase">+</button>
                            </div>
                        </div>
                        <div class="piano-roll-grid-size">
                            <label>Grid Size:</label>
                            <div class="grid-size-controls">
                                <button id="grid-size-decrease">-</button>
                                <span id="grid-size-display">16</span>
                                <button id="grid-size-increase">+</button>
                            </div>
                        </div>
                    </div>
                    <div class="piano-roll-zoom-controls">
                        <label>Zoom:</label>
                        <div class="zoom-controls">
                            <button id="zoom-decrease">-</button>
                            <span id="zoom-level-display">100%</span>
                            <button id="zoom-increase">+</button>
                            <button id="zoom-reset">⟲</button>
                        </div>
                    </div>
                    <div class="piano-roll-container">
                        <div class="piano-roll-bar-numbers-wrapper">
                            <div class="piano-roll-bar-numbers"></div>
                        </div>
                        <div class="piano-roll-scrollable">
                            <div class="piano-keys">
                            </div>
                            <div class="piano-roll-grid-container">
                                <div class="piano-roll-grid">
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="piano-roll-visualizer-container">
                        <canvas class="piano-roll-visualizer" id="piano-roll-visualizer"></canvas>
                    </div>
                    <div class="piano-roll-controls">
                        <div class="piano-roll-sound-source">
                            <label for="piano-roll-sound-source">Sound Source:</label>
                            <select id="piano-roll-sound-source">
                                <option value="piano">Grand Piano</option>
                                <option value="synth">Synth</option>
                                <option value="strings">Strings</option>
                                <option value="bass">Bass</option>
                                <option value="lead">Lead</option>
                                <option value="pad">Pad</option>
                                <option value="pluck">Pluck</option>
                    <option value="sounddesign">Sound Design (Dual Osc)</option>
                                <option value="sample">Use Sample</option>
                            </select>
                        </div>
                        <div class="piano-roll-preview-controls">
                            <button id="piano-roll-preview-btn">Preview</button>
                            <button id="piano-roll-stop-btn">Stop</button>
                            <button id="piano-roll-clear-btn" class="piano-roll-clear-btn">Clear</button>
                        </div>
                    </div>
                    
                    <div class="sound-design-controls" style="display:none">
                        <h4>Sound Design</h4>
                        <div class="sd-row">
							<div style="display:flex;flex-direction:column;align-items:flex-start;gap:6px">
                                <label class="sd-red-label" style="color:red !important;">Osc 1 Wave</label>
								<select id="sd-osc1-wave" style="background-color:#333;color:#fff;border:1px solid #555;border-radius:4px;">
                                    <option value="sine">Sine</option>
                                    <option value="square">Square</option>
                                    <option value="triangle">Triangle</option>
                                    <option value="sawtooth">Sawtooth</option>
                                </select>
                            </div>
                            <br>
                            <div style="display:flex;align-items:center;gap:8px;justify-content:space-between">
                                <label>Level</label>
                                <input type="range" id="sd-osc1-level" min="0" max="100" step="1">
                                <span id="sd-osc1-level-val"></span>
                            </div>
                            <br>
                            <div style="display:flex;align-items:center;gap:8px;justify-content:space-between">
                                <label>Detune</label>
                                <input type="range" id="sd-osc1-detune" min="-1200" max="1200" step="1">
                                <span id="sd-osc1-detune-val"></span>
                            </div>
                        </div>
                        <br>
                        <div class="sd-row">
							<div style="display:flex;flex-direction:column;align-items:flex-start;gap:6px">
                                <label class="sd-red-label" style="color:red !important;">Osc 2 Wave</label>
								<select id="sd-osc2-wave" style="background-color:#333;color:#fff;border:1px solid #555;border-radius:4px;">
                                    <option value="sine">Sine</option>
                                    <option value="square">Square</option>
                                    <option value="triangle">Triangle</option>
                                    <option value="sawtooth">Sawtooth</option>
                                </select>
                            </div>
                            <br>
                            <div style="display:flex;align-items:center;gap:8px;justify-content:space-between">
                                <label>Level</label>
                                <input type="range" id="sd-osc2-level" min="0" max="100" step="1">
                                <span id="sd-osc2-level-val"></span>
                            </div>
                            <br>
                            <div style="display:flex;align-items:center;gap:8px;justify-content:space-between">
                                <label>Detune</label>
                                <input type="range" id="sd-osc2-detune" min="-1200" max="1200" step="1">
                                <span id="sd-osc2-detune-val"></span>
                            </div>
                        </div>
                        <br>
                        <div class="sd-row">
							<div style="display:flex;flex-direction:column;align-items:flex-start;gap:6px">
                                <label class="sd-red-label" style="color:red !important;">Filter Type</label>
								<select id="sd-filter-type" style="background-color:#333;color:#fff;border:1px solid #555;border-radius:4px;">
                                    <option value="lowpass">Low Pass</option>
                                    <option value="highpass">High Pass</option>
                                    <option value="bandpass">Band Pass</option>
                                </select>
                            </div>
                            <br>
                            <div style="display:flex;align-items:center;gap:8px;justify-content:space-between">
                                <label>Cutoff</label>
                                <input type="range" id="sd-filter-cutoff" min="20" max="20000" step="1">
                                <span id="sd-filter-cutoff-val"></span>
                            </div>
                            <br>
                            <div style="display:flex;align-items:center;gap:8px;justify-content:space-between">
                                <label>Resonance</label>
                                <input type="range" id="sd-filter-res" min="0" max="100" step="1">
                                <span id="sd-filter-res-val"></span>
                            </div>
                        </div>
                        <br>
                        <div class="sd-row">
                            <h5 class="sd-red-label" style="color:red !important;">Envelope (ADSR)</h5>
                            <canvas id="adsr-canvas" style="width: 100%; height: 200px; background: #1a1a1a; border: 1px solid #444; border-radius: 4px; cursor: crosshair; display: block; position: relative; z-index: 1;"></canvas>
                            <div style="display:flex;align-items:center;gap:8px;justify-content:space-between; margin-top: 10px;">
                                <label>Attack</label>
                                <input type="range" id="sd-env-attack" min="0" max="2000" step="1">
                                <span id="sd-env-attack-val"></span>
                            </div>
                            <br>
                            <div style="display:flex;align-items:center;gap:8px;justify-content:space-between">
                                <label>Decay</label>
                                <input type="range" id="sd-env-decay" min="0" max="4000" step="1">
                                <span id="sd-env-decay-val"></span>
                            </div>
                            <br>
                            <div style="display:flex;align-items:center;gap:8px;justify-content:space-between">
                                <label>Sustain</label>
                                <input type="range" id="sd-env-sustain" min="0" max="100" step="1">
                                <span id="sd-env-sustain-val"></span>
                            </div>
                            <br>
                            <div style="display:flex;align-items:center;gap:8px;justify-content:space-between">
                                <label>Release</label>
                                <input type="range" id="sd-env-release" min="0" max="4000" step="1">
                                <span id="sd-env-release-val"></span>
                            </div>
                            <br>
                            <div style="border-top: 1px solid #444; padding-top: 10px; margin-top: 10px;">
                                <div style="display:flex;align-items:center;gap:8px;justify-content:space-between; margin-bottom: 8px;">
                                    <h5 class="sd-red-label" style="color:red !important; margin: 0; font-size: 13px;">Envelope → Pitch Modulation</h5>
                                    <input type="checkbox" id="sd-env-pitch-enable" style="width: 18px; height: 18px; cursor: pointer;">
                                </div>
                                <div style="display:flex;align-items:center;gap:8px;justify-content:space-between">
                                    <label style="font-size: 12px;">Amount (semitones)</label>
                                    <input type="range" id="sd-env-pitch-amount" min="-24" max="24" step="1" value="0">
                                    <span id="sd-env-pitch-amount-val" style="min-width: 45px; text-align: right;">0</span>
                                </div>
                                <div style="margin-top: 6px; font-size: 10px; color: #888; text-align: center;">
                                    Modulates pitch over envelope (creates pitch bends, kicks, toms, etc.)
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="piano-roll-filters">
                        <h4>Synth Filters</h4>
                        
                        <div class="enhanced-filter-controls">
                            <div class="filter-group">
                                <h5>EQ Controls</h5>
                                <div class="filter-control">
                                    <label>Low Shelf:</label>
                                    <input type="range" id="piano-roll-lowshelf" min="-24" max="24" value="0" step="0.5">
                                    <span id="piano-roll-lowshelf-value">0dB</span>
                                </div>
                                <div class="filter-control">
                                    <label>Low Mid:</label>
                                    <input type="range" id="piano-roll-lowmid" min="-24" max="24" value="0" step="0.5">
                                    <span id="piano-roll-lowmid-value">0dB</span>
                                </div>
                                <div class="filter-control">
                                    <label>Mid:</label>
                                    <input type="range" id="piano-roll-mid" min="-24" max="24" value="0" step="0.5">
                                    <span id="piano-roll-mid-value">0dB</span>
                                </div>
                                <div class="filter-control">
                                    <label>High Mid:</label>
                                    <input type="range" id="piano-roll-highmid" min="-24" max="24" value="0" step="0.5">
                                    <span id="piano-roll-highmid-value">0dB</span>
                                </div>
                                <div class="filter-control">
                                    <label>High Shelf:</label>
                                    <input type="range" id="piano-roll-highshelf" min="-24" max="24" value="0" step="0.5">
                                    <span id="piano-roll-highshelf-value">0dB</span>
                                </div>
                            </div>
                            
                            <div class="filter-group">
                                <h5>DELAY</h5>
                                <div class="filter-control">
                                    <label>Time (ms):</label>
                                    <input type="range" id="piano-roll-delay-time" min="0" max="1000" value="0" step="10">
                                    <span id="piano-roll-delay-time-value">0ms</span>
                                </div>
                                <div class="filter-control">
                                    <label>Feedback (%):</label>
                                    <input type="range" id="piano-roll-delay-feedback" min="0" max="100" value="0" step="1">
                                    <span id="piano-roll-delay-feedback-value">0%</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="loading-indicator" id="piano-roll-loading">
                <div class="spinner"></div>
                <div>Rendering piano roll...</div>
            </div>
        </div>
        <div class="popup-footer">
            <button class="popup-reset-btn">Reset All to 0</button>
            <button class="popup-accept-btn">Accept</button>
        </div>
    `;
    document.body.appendChild(effectsPopup);

    // Ensure Sound Design sliders use green accent to match theme
    (function ensureSDSliderStyle(){
        const styleId = 'sd-slider-green-style';
        if (!document.getElementById(styleId)) {
            const style = document.createElement('style');
            style.id = styleId;
            style.textContent = `
                /* Blue color for most sound design labels */
                .sound-design-controls label { color: #64B5F6; }
                .sound-design-controls .slider-container label { color: #64B5F6; }
                .sound-design-controls span { color: #A5D6A7; }
                /* Red color for specific labels: Osc Wave, Filter Type, Envelope labels */
                .sound-design-controls .sd-red-label { color: red !important; }
                .sound-design-controls input[type="range"] {
                    -webkit-appearance: none;
                    appearance: none;
                    width: 100%;
                    height: 8px;
                    background: linear-gradient(90deg, #1B5E20 0%, #00C853 100%);
                    border-radius: 4px;
                    outline: none;
                }
                /* WebKit */
                .sound-design-controls input[type="range"]::-webkit-slider-runnable-track {
                    height: 8px;
                    background: linear-gradient(90deg, #1B5E20 0%, #00C853 100%);
                    border-radius: 4px;
                }
                .sound-design-controls input[type="range"]::-webkit-slider-thumb {
                    -webkit-appearance: none;
                    appearance: none;
                    margin-top: -5px;
                    width: 16px;
                    height: 16px;
                    border-radius: 50%;
                    background: #00C853;
                    border: 2px solid #1B5E20;
                    cursor: pointer;
                }
                /* Firefox */
                .sound-design-controls input[type="range"]::-moz-range-track {
                    height: 8px;
                    background: linear-gradient(90deg, #1B5E20 0%, #00C853 100%);
                    border-radius: 4px;
                }
                .sound-design-controls input[type="range"]::-moz-range-thumb {
                    width: 16px;
                    height: 16px;
                    border-radius: 50%;
                    background: #00C853;
                    border: 2px solid #1B5E20;
                    cursor: pointer;
                }
                /* MS Edge Legacy */
                .sound-design-controls input[type="range"]::-ms-fill-lower,
                .sound-design-controls input[type="range"]::-ms-fill-upper {
                    background: linear-gradient(90deg, #1B5E20 0%, #00C853 100%);
                    border-radius: 4px;
                }
                .sound-design-controls input[type="range"]::-ms-thumb {
                    width: 16px; height: 16px; border-radius: 50%; background: #00C853; border: 2px solid #1B5E20; cursor: pointer;
                }
            `;
            document.head.appendChild(style);
        }
    })();

    // Style Volume (red) and Delay (yellow) sliders and section backgrounds
    (function ensureFXSliderStyle(){
        const styleId = 'fx-slider-green-style';
        if (!document.getElementById(styleId)) {
            const style = document.createElement('style');
            style.id = styleId;
            style.textContent = `
                /* Volume (red theme) */
                #sample-volume { -webkit-appearance: none; appearance: none; width: 100%; height: 8px; background: linear-gradient(90deg, #7F1D1D 0%, #E53935 100%); border-radius: 4px; outline: none; }
                #sample-volume::-webkit-slider-runnable-track { height: 8px; background: linear-gradient(90deg, #7F1D1D 0%, #E53935 100%); border-radius: 4px; }
                #sample-volume::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; margin-top: -5px; width: 16px; height: 16px; border-radius: 50%; background: #E53935; border: 2px solid #7F1D1D; cursor: pointer; }
                #sample-volume::-moz-range-track { height: 8px; background: linear-gradient(90deg, #7F1D1D 0%, #E53935 100%); border-radius: 4px; }
                #sample-volume::-moz-range-thumb { width: 16px; height: 16px; border-radius: 50%; background: #E53935; border: 2px solid #7F1D1D; cursor: pointer; }
                
                /* Delay (yellow/amber theme, not too bright) */
                #delay-time, #delay-feedback { -webkit-appearance: none; appearance: none; width: 100%; height: 8px; background: linear-gradient(90deg, #795548 0%, #FBC02D 100%); border-radius: 4px; outline: none; }
                #delay-time::-webkit-slider-runnable-track, #delay-feedback::-webkit-slider-runnable-track { height: 8px; background: linear-gradient(90deg, #795548 0%, #FBC02D 100%); border-radius: 4px; }
                #delay-time::-webkit-slider-thumb, #delay-feedback::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; margin-top: -5px; width: 16px; height: 16px; border-radius: 50%; background: #FBC02D; border: 2px solid #795548; cursor: pointer; }
                #delay-time::-moz-range-track, #delay-feedback::-moz-range-track { height: 8px; background: linear-gradient(90deg, #795548 0%, #FBC02D 100%); border-radius: 4px; }
                #delay-time::-moz-range-thumb, #delay-feedback::-moz-range-thumb { width: 16px; height: 16px; border-radius: 50%; background: #FBC02D; border: 2px solid #795548; cursor: pointer; }
            `;
            document.head.appendChild(style);
        }
        // Soft background colors for sections (apply via DOM so we don't rely on :has)
        try {
            const volEl = document.getElementById('sample-volume');
            if (volEl) {
                const volSection = volEl.closest('.effect-section');
                if (volSection) {
                    volSection.style.backgroundColor = 'rgba(229, 57, 53, 0.10)';
                    volSection.style.borderColor = 'rgba(229, 57, 53, 0.30)';
                }
            }
            const dTime = document.getElementById('delay-time');
            if (dTime) {
                const delaySection = dTime.closest('.effect-section');
                if (delaySection) {
                    delaySection.style.backgroundColor = 'rgba(251, 192, 45, 0.10)';
                    delaySection.style.borderColor = 'rgba(251, 192, 45, 0.30)';
                }
            }
        } catch (e) {}
    })();

    function interpolateGainSpline(frequency, sortedPoints) {
        if (sortedPoints.length === 0) return 0;
        if (sortedPoints.length === 1) return sortedPoints[0].gain;
        const logPoints = sortedPoints.map(p => ({
            x: Math.log10(p.frequency),
            y: p.gain
        }));
        const x = Math.log10(frequency);
        if (x <= logPoints[0].x) return logPoints[0].y;
        if (x >= logPoints[logPoints.length - 1].x) return logPoints[logPoints.length - 1].y;
        let i = 0;
        for (i = 0; i < logPoints.length - 1; i++) {
            if (x >= logPoints[i].x && x <= logPoints[i + 1].x) {
                break;
            }
        }
        const p0 = logPoints[Math.max(0, i - 1)];
        const p1 = logPoints[i];
        const p2 = logPoints[i + 1];
        const p3 = logPoints[Math.min(logPoints.length - 1, i + 2)];
        const t = (x - p1.x) / (p2.x - p1.x);
        const t2 = t * t;
        const t3 = t2 * t;
        return .5 * (2 * p1.y + (-p0.y + p2.y) * t + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3);
    }

    function addEQPoint(frequency, gain) {
        if (!temporaryEffects || !temporaryEffects.eq) return;
        if (temporaryEffects.eq.length >= MAX_EQ_POINTS) return;
        if (frequency <= 20 || frequency >= 2e4) return;
        let type = "peaking";
        if (frequency < 200) type = "lowshelf";
        else if (frequency > 8e3) type = "highshelf";
        const newPoint = {
            frequency: frequency,
            gain: gain,
            q: 1,
            type: type
        };
        temporaryEffects.eq.push(newPoint);
        temporaryEffects.eq.sort((a, b) => a.frequency - b.frequency);
        updateEQFiltersInRealTime();
        drawEQVisual();
        return newPoint;
    }

    function initVisualEQ() {
        eqCanvas = document.getElementById("eq-canvas");
        eqCtx = eqCanvas.getContext("2d");
        const container = eqCanvas.parentElement;
        eqCanvas.width = container.clientWidth;
        eqCanvas.height = container.clientHeight;
        drawEQVisual();
        
        // Add event listener for the EQ visualizer toggle
        const eqVisualizerToggle = document.getElementById("eq-visualizer-toggle");
        if (eqVisualizerToggle) {
            eqVisualizerToggle.addEventListener("change", function() {
                // Store the state for the current sample
                currentPlaying[currentSampleForPopup].eqVisualizerEnabled = this.checked;
                
                // Enable/disable EQ interaction based on toggle state
                if (this.checked) {
                    // Enable interaction
                    eqCanvas.style.pointerEvents = "auto";
                } else {
                    // Disable interaction
                    eqCanvas.style.pointerEvents = "none";
                }
            });
            
            // Set initial state based on the sample's stored state
            eqCanvas.style.pointerEvents = eqVisualizerToggle.checked ? "auto" : "none";
        }
        
        eqCanvas.addEventListener("mousedown", startDraggingEQBand);
        eqCanvas.addEventListener("mousemove", dragEQBand);
        eqCanvas.addEventListener("mouseup", stopDraggingEQBand);
        eqCanvas.addEventListener("mouseleave", stopDraggingEQBand);
        eqCanvas.addEventListener("touchstart", handleEQTouchStart);
        eqCanvas.addEventListener("touchmove", handleEQTouchMove);
        eqCanvas.addEventListener("touchend", stopDraggingEQBand);
        initWaveformVisualization();
    }

    function initWaveformVisualization() {
        if (!currentSampleForPopup || !currentPlaying[currentSampleForPopup].isScheduled) {
            return;
        }
        if (!waveformAnalyzer) {
            waveformAnalyzer = audioContext.createAnalyser();
            waveformAnalyzer.fftSize = 4096;
            waveformAnalyzer.smoothingTimeConstant = .7;
            const sample = currentPlaying[currentSampleForPopup];
            if (sample.eqVeryHighNode) {
                sample.eqVeryHighNode.disconnect();
                sample.eqVeryHighNode.connect(waveformAnalyzer);
                waveformAnalyzer.connect(masterOutputNode);
            } else if (sample.outputNode) {
                sample.outputNode.disconnect();
                sample.outputNode.connect(waveformAnalyzer);
                waveformAnalyzer.connect(masterOutputNode);
            } else if (sample.gainNode) {
                sample.gainNode.disconnect();
                sample.gainNode.connect(waveformAnalyzer);
                waveformAnalyzer.connect(masterOutputNode);
            }
        }
        startWaveformAnimation();
    }

    function startWaveformAnimation() {
        if (waveformAnimationId) {
            cancelAnimationFrame(waveformAnimationId);
        }
        const bufferLength = waveformAnalyzer.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);

        function animate() {
            waveformAnimationId = requestAnimationFrame(animate);
            waveformAnalyzer.getByteFrequencyData(dataArray);
            waveformHistory.push([...dataArray]);
            if (waveformHistory.length > waveformHistorySize) {
                waveformHistory.shift();
            }
            drawEQVisual();
        }
        animate();
    }

    function stopWaveformAnimation() {
        if (waveformAnimationId) {
            cancelAnimationFrame(waveformAnimationId);
            waveformAnimationId = null;
        }
        waveformHistory = [];
        drawEQVisual();
    }

    function drawEQVisual() {
        if (!eqCanvas || !eqCtx) return;
        const width = eqCanvas.width;
        const height = eqCanvas.height;
        const padding = 20;
        eqCtx.fillStyle = "#0a0a0f";
        eqCtx.fillRect(0, 0, width, height);
        eqCtx.strokeStyle = "#1a1a2e";
        eqCtx.lineWidth = 1;
        for (let i = 0; i <= 4; i++) {
            const y = padding + i * (height - 2 * padding) / 4;
            eqCtx.beginPath();
            eqCtx.moveTo(padding, y);
            eqCtx.lineTo(width - padding, y);
            eqCtx.stroke();
        }
        for (let i = 0; i <= 4; i++) {
            const x = padding + i * (width - 2 * padding) / 4;
            eqCtx.beginPath();
            eqCtx.moveTo(x, padding);
            eqCtx.lineTo(x, height - padding);
            eqCtx.stroke();
        }
        eqCtx.strokeStyle = "#333";
        eqCtx.lineWidth = 1;
        eqCtx.setLineDash([5, 3]);
        const zeroDbY = height / 2;
        eqCtx.beginPath();
        eqCtx.moveTo(padding, zeroDbY);
        eqCtx.lineTo(width - padding, zeroDbY);
        eqCtx.stroke();
        eqCtx.setLineDash([]);
        if (waveformHistory.length > 0) {
            drawWaveform();
        }
        eqCtx.strokeStyle = "#4CAF50";
        eqCtx.lineWidth = 4;
        eqCtx.shadowColor = "rgba(76, 175, 80, 0.8)";
        eqCtx.shadowBlur = 8;
        eqCtx.beginPath();
        const eqPoints = temporaryEffects && temporaryEffects.eq ? temporaryEffects.eq : [];
        const sortedPoints = [...eqPoints].sort((a, b) => a.frequency - b.frequency);
        const points = [];
        const numPoints = 200;
        for (let i = 0; i <= numPoints; i++) {
            const x = padding + i * (width - 2 * padding) / numPoints;
            const freq = 20 * Math.pow(2e4 / 20, (x - padding) / (width - 2 * padding));
            let gain = interpolateGainSpline(freq, sortedPoints);
            const y = height / 2 - gain / 24 * (height / 2 - padding);
            points.push({
                x: x,
                y: y
            });
            if (i === 0) {
                eqCtx.moveTo(x, y);
            } else {
                eqCtx.lineTo(x, y);
            }
        }
        eqCtx.stroke();
        eqCtx.shadowBlur = 0;
        for (let i = 0; i < eqPoints.length; i++) {
            const point = eqPoints[i];
            const x = padding + Math.log10(point.frequency / 20) / Math.log10(2e4 / 20) * (eqCanvas.width - 2 * padding);
            const y = height / 2 - point.gain / 24 * (height / 2 - padding);
            if (point.fixed) {
                eqCtx.fillStyle = "#FFC107";
                eqCtx.shadowColor = "rgba(255, 193, 7, 0.8)";
            } else {
                eqCtx.fillStyle = point === draggedPoint ? "#FF5722" : "#4CAF50";
                eqCtx.shadowColor = point === draggedPoint ? "rgba(255, 87, 34, 0.8)" : "rgba(76, 175, 80, 0.8)";
            }
            eqCtx.shadowBlur = 15;
            eqCtx.beginPath();
            eqCtx.arc(x, y, 9, 0, Math.PI * 2);
            eqCtx.fill();
            eqCtx.fillStyle = "#fff";
            eqCtx.shadowBlur = 0;
            eqCtx.beginPath();
            eqCtx.arc(x, y, 6, 0, Math.PI * 2);
            eqCtx.fill();
            eqCtx.fillStyle = "rgba(0, 0, 0, 0.7)";
            eqCtx.fillRect(x - 25, y + 20, 50, 15);
            eqCtx.fillStyle = "#fff";
            eqCtx.font = "bold 10px Arial";
            eqCtx.textAlign = "center";
            let freqLabel;
            if (point.frequency < 1e3) {
                freqLabel = `${Math.round(point.frequency)}Hz`;
            } else {
                const kHzValue = point.frequency / 1e3;
                if (kHzValue === Math.round(kHzValue)) {
                    freqLabel = `${Math.round(kHzValue)}k`;
                } else {
                    freqLabel = `${kHzValue.toFixed(1)}k`;
                }
            }
            eqCtx.fillText(freqLabel, x, y + 30);
            eqCtx.fillStyle = "rgba(0, 0, 0, 0.7)";
            eqCtx.fillRect(x - 25, y - 35, 50, 15);
            eqCtx.fillStyle = "#fff";
            eqCtx.fillText(`${point.gain>0?"+":""}${point.gain.toFixed(1)}dB`, x, y - 25);
        }
    }

    function drawWaveform() {
        const width = eqCanvas.width;
        const height = eqCanvas.height;
        const padding = 20;
        const gradient = eqCtx.createLinearGradient(0, height - padding, 0, padding);
        gradient.addColorStop(0, "rgba(28, 0, 212, 0.9)");
        gradient.addColorStop(.1, "rgba(0, 191, 255, 0.95)");
        gradient.addColorStop(.3, "rgba(0, 210, 154, 0.9)");
        gradient.addColorStop(.5, "rgba(255, 196, 0, 0.85)");
        gradient.addColorStop(.7, "rgba(255, 0, 0, 0.85)");
        gradient.addColorStop(.9, "rgba(255, 0, 157, 0.85)");
        gradient.addColorStop(1, "rgba(170, 0, 255, 0.85)");
        const sliceWidth = (width - 2 * padding) / waveformHistorySize;
        for (let h = 0; h < waveformHistory.length; h++) {
            const dataArray = waveformHistory[h];
            const x = padding + h * sliceWidth;
            const alpha = .4 + h / waveformHistory.length * .6;
            eqCtx.beginPath();
            eqCtx.moveTo(x, height - padding);
            const maxFreq = audioContext.sampleRate / 2;
            const minLogFreq = Math.log10(20);
            const maxLogFreq = Math.log10(maxFreq);
            for (let i = 0; i < dataArray.length; i++) {
                const freq = i * maxFreq / dataArray.length;
                const logFreq = Math.log10(Math.max(20, freq));
                const normalizedLogFreq = (logFreq - minLogFreq) / (maxLogFreq - minLogFreq);
                const freqX = padding + normalizedLogFreq * (width - 2 * padding);
                if (freqX >= x && freqX <= x + sliceWidth) {
                    const amplitude = dataArray[i] / 255;
                    const enhancedAmplitude = Math.pow(amplitude, .4);
                    const ampY = height - padding - enhancedAmplitude * (height - 2 * padding);
                    eqCtx.lineTo(freqX, ampY);
                }
            }
            eqCtx.lineTo(x + sliceWidth, height - padding);
            eqCtx.closePath();
            eqCtx.globalAlpha = alpha;
            eqCtx.fillStyle = gradient;
            eqCtx.fill();
            if (h > waveformHistory.length * .7) {
                eqCtx.shadowColor = "rgba(0, 255, 170, 0.8)";
                eqCtx.shadowBlur = 10;
                eqCtx.fill();
                eqCtx.shadowBlur = 0;
            }
        }
        eqCtx.globalAlpha = 1;
        if (waveformHistory.length > 0) {
            const latestData = waveformHistory[waveformHistory.length - 1];
            eqCtx.strokeStyle = "rgba(96, 96, 96, 1)";
            eqCtx.lineWidth = 2;
            eqCtx.beginPath();
            const maxFreq = audioContext.sampleRate / 2;
            const minLogFreq = Math.log10(20);
            const maxLogFreq = Math.log10(maxFreq);
            for (let i = 0; i < latestData.length; i++) {
                const freq = i * maxFreq / latestData.length;
                const logFreq = Math.log10(Math.max(20, freq));
                const normalizedLogFreq = (logFreq - minLogFreq) / (maxLogFreq - minLogFreq);
                const x = padding + normalizedLogFreq * (width - 2 * padding);
                const amplitude = latestData[i] / 255;
                const enhancedAmplitude = Math.pow(amplitude, .4);
                const y = height - padding - enhancedAmplitude * (height - 2 * padding);
                if (i === 0) {
                    eqCtx.moveTo(x, y);
                } else {
                    eqCtx.lineTo(x, y);
                }
            }
            eqCtx.stroke();
        }
    }

    function startDraggingEQBand(e) {
        // Check if EQ interaction is disabled
        const eqVisualizerToggle = document.getElementById("eq-visualizer-toggle");
        if (eqVisualizerToggle && !eqVisualizerToggle.checked) {
            return; // Don't allow interaction if toggle is off
        }
        
        if (!temporaryEffects || !temporaryEffects.eq) return;
        const rect = eqCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const padding = 20;
        const height = eqCanvas.height;
        for (let i = 0; i < temporaryEffects.eq.length; i++) {
            const point = temporaryEffects.eq[i];
            if (point.fixed) continue;
            const pointX = padding + Math.log10(point.frequency / 20) / Math.log10(2e4 / 20) * (eqCanvas.width - 2 * padding);
            const pointY = height / 2 - point.gain / 24 * (height / 2 - padding);
            const distance = Math.sqrt(Math.pow(x - pointX, 2) + Math.pow(y - pointY, 2));
            if (distance <= 9) {
                isDraggingEqBand = true;
                draggedPoint = point;
                isCreatingNewPoint = false;
                return;
            }
        }
        if (temporaryEffects.eq.length < MAX_EQ_POINTS) {
            const frequency = 20 * Math.pow(2e4 / 20, (x - padding) / (eqCanvas.width - 2 * padding));
            if (frequency <= 20 || frequency >= 2e4) return;
            const gain = -(y - eqCanvas.height / 2) / (eqCanvas.height / 2 - padding) * 24;
            const newPoint = addEQPoint(frequency, gain);
            isDraggingEqBand = true;
            draggedPoint = newPoint;
            isCreatingNewPoint = true;
        }
    }

    function handleEQTouchStart(e) {
        // Check if EQ interaction is disabled
        const eqVisualizerToggle = document.getElementById("eq-visualizer-toggle");
        if (eqVisualizerToggle && !eqVisualizerToggle.checked) {
            return; // Don't allow interaction if toggle is off
        }
        
        e.preventDefault();
        if (!temporaryEffects || !temporaryEffects.eq) return;
        const touch = e.touches[0];
        const rect = eqCanvas.getBoundingClientRect();
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;
        const padding = 20;
        const height = eqCanvas.height;
        for (let i = 0; i < temporaryEffects.eq.length; i++) {
            const point = temporaryEffects.eq[i];
            if (point.fixed) continue;
            const pointX = padding + Math.log10(point.frequency / 20) / Math.log10(2e4 / 20) * (eqCanvas.width - 2 * padding);
            const pointY = height / 2 - point.gain / 24 * (height / 2 - padding);
            const distance = Math.sqrt(Math.pow(x - pointX, 2) + Math.pow(y - pointY, 2));
            if (distance <= 9) {
                isDraggingEqBand = true;
                draggedPoint = point;
                isCreatingNewPoint = false;
                return;
            }
        }
        if (temporaryEffects.eq.length < MAX_EQ_POINTS) {
            const frequency = 20 * Math.pow(2e4 / 20, (x - padding) / (eqCanvas.width - 2 * padding));
            if (frequency <= 20 || frequency >= 2e4) return;
            const gain = -(y - height / 2) / (height / 2 - padding) * 24;
            const newPoint = addEQPoint(frequency, gain);
            isDraggingEqBand = true;
            draggedPoint = newPoint;
            isCreatingNewPoint = true;
        }
    }

    function handleEQTouchMove(e) {
        // Check if EQ interaction is disabled
        const eqVisualizerToggle = document.getElementById("eq-visualizer-toggle");
        if (eqVisualizerToggle && !eqVisualizerToggle.checked) {
            return; // Don't allow interaction if toggle is off
        }
        
        e.preventDefault();
        if (!isDraggingEqBand || !draggedPoint || !temporaryEffects || !temporaryEffects.eq) return;
        const touch = e.touches[0];
        const rect = eqCanvas.getBoundingClientRect();
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;
        const padding = 20;
        const height = eqCanvas.height;
        const gain = -(y - height / 2) / (height / 2 - padding) * 24;
        const clampedGain = Math.max(-24, Math.min(24, gain));
        const freq = 20 * Math.pow(2e4 / 20, (x - padding) / (eqCanvas.width - 2 * padding));
        const clampedFreq = Math.max(20, Math.min(2e4, freq));
        draggedPoint.gain = clampedGain;
        draggedPoint.frequency = clampedFreq;
        updateEQFiltersInRealTime();
        drawEQVisual();
    }

    function dragEQBand(e) {
        // Check if EQ interaction is disabled
        const eqVisualizerToggle = document.getElementById("eq-visualizer-toggle");
        if (eqVisualizerToggle && !eqVisualizerToggle.checked) {
            return; // Don't allow interaction if toggle is off
        }
        
        if (!isDraggingEqBand || !draggedPoint || !temporaryEffects || !temporaryEffects.eq) return;
        const rect = eqCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const padding = 20;
        const height = eqCanvas.height;
        const gain = -(y - height / 2) / (height / 2 - padding) * 24;
        const clampedGain = Math.max(-24, Math.min(24, gain));
        const freq = 20 * Math.pow(2e4 / 20, (x - padding) / (eqCanvas.width - 2 * padding));
        const clampedFreq = Math.max(20, Math.min(2e4, freq));
        draggedPoint.gain = clampedGain;
        draggedPoint.frequency = clampedFreq;
        updateEQFiltersInRealTime();
        drawEQVisual();
    }

    function stopDraggingEQBand() {
        isDraggingEqBand = false;
        draggedPoint = null;
        isCreatingNewPoint = false;
        drawEQVisual();
    }

    function updateEQFiltersInRealTime() {
        if (!currentSampleForPopup || !temporaryEffects || !temporaryEffects.eq) return;
        const sample = currentPlaying[currentSampleForPopup];
        if (sample.eqLowNode) sample.eqLowNode.gain.value = 0;
        if (sample.eqLowMidNode) sample.eqLowMidNode.gain.value = 0;
        if (sample.eqMidNode) sample.eqMidNode.gain.value = 0;
        if (sample.eqHighMidNode) sample.eqHighMidNode.gain.value = 0;
        if (sample.eqHighMid2Node) sample.eqHighMid2Node.gain.value = 0;
        if (sample.eqHighNode) sample.eqHighNode.gain.value = 0;
        if (sample.eqVeryHighNode) sample.eqVeryHighNode.gain.value = 0;
        const sortedEqPoints = [...temporaryEffects.eq].sort((a, b) => a.frequency - b.frequency);
        if (sortedEqPoints[0] && sortedEqPoints[0].type === "lowshelf") {
            if (sample.eqLowNode) {
                sample.eqLowNode.frequency.value = sortedEqPoints[0].frequency;
                sample.eqLowNode.gain.value = sortedEqPoints[0].gain;
            }
        }
        if (sortedEqPoints[sortedEqPoints.length - 1] && sortedEqPoints[sortedEqPoints.length - 1].type === "highshelf") {
            if (sample.eqHighNode) {
                sample.eqHighNode.frequency.value = sortedEqPoints[sortedEqPoints.length - 1].frequency;
                sample.eqHighNode.gain.value = sortedEqPoints[sortedEqPoints.length - 1].gain;
            }
        }
        let peakingIndex = 0;
        for (let i = 0; i < sortedEqPoints.length; i++) {
            if (sortedEqPoints[i].type === "peaking") {
                let filterNode;
                switch (peakingIndex) {
                case 0:
                    filterNode = sample.eqLowMidNode;
                    break;
                case 1:
                    filterNode = sample.eqMidNode;
                    break;
                case 2:
                    filterNode = sample.eqHighMidNode;
                    break;
                case 3:
                    filterNode = sample.eqHighMid2Node;
                    break;
                default:
                    break;
                }
                if (filterNode) {
                    filterNode.frequency.value = sortedEqPoints[i].frequency;
                    filterNode.gain.value = sortedEqPoints[i].gain;
                    filterNode.Q.value = sortedEqPoints[i].q || 1;
                    peakingIndex++;
                }
            }
        }
    }

    function updateWetDryMix() {
        if (!currentSampleForPopup) return;
        const sample = currentPlaying[currentSampleForPopup];
        const delayTime = parseInt(document.getElementById("delay-time").value);
        const reverbMix = parseInt(document.getElementById("reverb-mix").value);
        let wetLevel = 0;
        if (delayTime > 0) {
            wetLevel += .5;
        }
        if (reverbMix > 0) {
            wetLevel += reverbMix / 100;
        }
        wetLevel = Math.min(wetLevel, .8);
        if (sample.wetPathNode) {
            sample.wetPathNode.gain.value = wetLevel;
        }
        if (sample.dryPathNode) {
            sample.dryPathNode.gain.value = 1 - wetLevel;
        }
    }

    function updateDelayInRealTime() {
        if (!currentSampleForPopup) return;
        const sample = currentPlaying[currentSampleForPopup];
        const delayTime = parseInt(document.getElementById("delay-time").value);
        const feedback = parseInt(document.getElementById("delay-feedback").value);
        if (sample.delayNode) {
            sample.delayNode.delayTime.value = delayTime / 1e3;
            if (sample.delayFeedbackNode) {
                sample.delayFeedbackNode.gain.value = feedback / 100;
            }
        }
        updateWetDryMix();
    }

    function updateReverbInRealTime() {
        if (!currentSampleForPopup) return;
        const sample = currentPlaying[currentSampleForPopup];
        const reverbDecay = parseFloat(document.getElementById("reverb-decay").value);
        const reverbPredelay = parseFloat(document.getElementById("reverb-predelay").value);
        const reverbDiffusion = parseFloat(document.getElementById("reverb-diffusion").value);
        const reverbLowcut = parseFloat(document.getElementById("reverb-lowcut").value);
        const reverbHighcut = parseFloat(document.getElementById("reverb-highcut").value);
        const reverbDamping = parseFloat(document.getElementById("reverb-damping").value);
        const reverbMix = parseInt(document.getElementById("reverb-mix").value);
        if (sample.reverbMixNode) {
            sample.reverbMixNode.gain.value = reverbMix / 100;
        }
        if (reverbDecay > 0) {
            const convolver = audioContext.createConvolver();
            const length = audioContext.sampleRate * reverbDecay;
            const impulse = audioContext.createBuffer(2, length, audioContext.sampleRate);
            const predelaySamples = audioContext.sampleRate * (reverbPredelay / 1e3);
            for (let channel = 0; channel < 2; channel++) {
                const channelData = impulse.getChannelData(channel);
                for (let i = 0; i < length; i++) {
                    if (i < predelaySamples) {
                        channelData[i] = 0;
                    } else {
                        const decayFactor = Math.pow(1 - (i - predelaySamples) / (length - predelaySamples), 2);
                        const diffusionFactor = reverbDiffusion / 100;
                        channelData[i] = (Math.random() * 2 - 1) * decayFactor * diffusionFactor;
                        const dampingFactor = 1 - reverbDamping / 100 * (i / length);
                        channelData[i] *= dampingFactor;
                    }
                }
            }
            convolver.buffer = impulse;
            if (sample.reverbNode) {
                sample.reverbNode.disconnect();
            }
            sample.reverbNode = convolver;
            if (sample.wetPathNode && sample.reverbMixNode) {
                sample.wetPathNode.connect(convolver);
                convolver.connect(sample.reverbMixNode);
                sample.reverbMixNode.connect(sample.outputNode);
            }
        } else {
            if (sample.reverbNode) {
                sample.reverbNode.disconnect();
                sample.reverbNode = null;
            }
        }
        updateWetDryMix();
    }

    // Function to update the actual gain based on both group and individual volumes
    function updateActualGain(sampleNumber) {
        if (!currentPlaying[sampleNumber] || !currentPlaying[sampleNumber].gainNode) return;
        
        const sample = currentPlaying[sampleNumber];
        const groupVolume = sample.groupVolume !== undefined ? sample.groupVolume : 0.8;
        const individualVolume = sample.individualVolume !== undefined ? sample.individualVolume : 1.0;
        
        // Calculate the combined gain by multiplying group and individual volumes
        const combinedGain = groupVolume * individualVolume;
        sample.gainNode.gain.value = combinedGain;
        sample.volume = combinedGain;
    }

    // Function to get the current group volume for a sample
    function getGroupVolumeForSample(sampleNumber) {
        const group = Math.floor((sampleNumber - 1) / 10);
        const groupSlider = document.getElementById(`volumeSlider${group}`);
        return groupSlider ? parseFloat(groupSlider.value) / 100 : 0.8;
    }

    // Perceptual volume curve: map 0-200% to an audio gain with fine control at low end
    function mapVolumePercentToGain(percent) {
        const clamped = Math.max(0, Math.min(200, Number(percent) || 0));
        const normalized = clamped / 100; // 0..2
        // Use a power curve for better low-end resolution and sensible high-end
        // 1% -> ~-36 dB, 50% -> ~-9 dB, 100% -> 0 dB, 200% -> +6 dB-ish
        const gain = Math.pow(normalized, 2.5);
        return gain;
    }

    function updateSampleVolumeInRealTime() {
        if (!currentSampleForPopup) return;
        const sample = currentPlaying[currentSampleForPopup];
        const volume = parseInt(document.getElementById("sample-volume").value);
        document.getElementById("sample-volume-value").textContent = `${volume}%`;
        
        // Store the individual volume as a decimal (0-2)
        const individualVolume = mapVolumePercentToGain(volume * 1.0);
        sample.individualVolume = individualVolume;
        
        // Update the actual gain by combining with group volume
        updateActualGain(currentSampleForPopup);
    }

    function updateSpeedInRealTime() {
        if (!currentSampleForPopup) return;
        const sample = currentPlaying[currentSampleForPopup];
        const speed = parseFloat(document.getElementById("speed-select").value);
        if (sample.source && sample.isScheduled) {
            let basePlaybackRate;
            if (sample.isLongSample) {
                const longLoopBeatDuration = 60 / longLoopTempo;
                const longLoopBarDuration = longLoopBeatDuration * 4;
                const desiredLoopDuration = longLoopBarDuration * longLoopLength;
                basePlaybackRate = sample.loopDuration / desiredLoopDuration;
            } else {
                const effectiveTempo = tempo + highTempo;
                const effectiveBeatDuration = 60 / effectiveTempo;
                const effectiveBarDuration = effectiveBeatDuration * 4;
                const desiredLoopDuration = effectiveBarDuration * loopLength;
                basePlaybackRate = sample.loopDuration / desiredLoopDuration;
            }
            let individualTempo = 1;
            if (sample.isLongSample && sample.effects && sample.effects.individualTempo) {
                individualTempo = sample.effects.individualTempo;
            }
            const newPlaybackRate = basePlaybackRate * individualTempo * speed;
            const currentPlaybackRate = sample.source.playbackRate.value;
            const currentTime = audioContext.currentTime;
            const elapsedTime = currentTime - sample.loopStartTime;
            const currentPosition = elapsedTime * currentPlaybackRate % sample.loopDuration;
            sample.source.playbackRate.value = newPlaybackRate;
            sample.loopStartTime = currentTime - currentPosition / newPlaybackRate;
            
            // Update LFO base rate if pitch modulation is active
            if (sample.lfoTarget === "pitch") {
                sample.lfoBaseRate = newPlaybackRate;
            }
            
            console.log(`Sample ${currentSampleForPopup} speed updated: new rate ${newPlaybackRate}, position ${currentPosition}`);
        }
    }

    function updateIndividualTempoInRealTime() {
        if (!currentSampleForPopup) return;
        const sample = currentPlaying[currentSampleForPopup];
        const individualTempo = parseFloat(document.getElementById("individual-tempo").value);
        if (sample.source && sample.isScheduled && sample.isLongSample) {
            const longLoopBeatDuration = 60 / longLoopTempo;
            const longLoopBarDuration = longLoopBeatDuration * 4;
            const desiredLoopDuration = longLoopBarDuration * longLoopLength;
            const basePlaybackRate = sample.loopDuration / desiredLoopDuration;
            const speed = sample.effects ? sample.effects.speed || 1 : 1;
            const newPlaybackRate = basePlaybackRate * individualTempo * speed;
            const currentPlaybackRate = sample.source.playbackRate.value;
            const currentTime = audioContext.currentTime;
            const elapsedTime = currentTime - sample.loopStartTime;
            const currentPosition = elapsedTime * currentPlaybackRate % sample.loopDuration;
            sample.source.playbackRate.value = newPlaybackRate;
            sample.loopStartTime = currentTime - currentPosition / newPlaybackRate;
            
            // Update LFO base rate if pitch modulation is active
            if (sample.lfoTarget === "pitch") {
                sample.lfoBaseRate = newPlaybackRate;
            }
            
            console.log(`Sample ${currentSampleForPopup} individual tempo updated: new rate ${newPlaybackRate}, position ${currentPosition}`);
        }
    }

    function initializeSpeedAndTempoControls() {
        const speedSelect = document.getElementById("speed-select");
        const individualTempoSlider = document.getElementById("individual-tempo");
        const individualTempoValue = document.getElementById("individual-tempo-value");
        const sampleVolumeSlider = document.getElementById("sample-volume");
        speedSelect.addEventListener("change", function () {
            updateSpeedInRealTime();
            if (temporaryEffects) {
                temporaryEffects.speed = parseFloat(this.value);
            }
        });
        individualTempoSlider.addEventListener("input", function () {
            individualTempoValue.textContent = this.value;
            updateIndividualTempoInRealTime();
            if (temporaryEffects) {
                temporaryEffects.individualTempo = parseFloat(this.value);
            }
        });
        sampleVolumeSlider.addEventListener("input", function () {
            updateSampleVolumeInRealTime();
            if (temporaryEffects) {
                temporaryEffects.volume = parseInt(this.value);
            }
        });
    }

    function initializeEffectsForSample(sampleNumber) {
        if (!currentPlaying[sampleNumber].isScheduled || !currentPlaying[sampleNumber].source) return;
        const sample = currentPlaying[sampleNumber];
        if (sample.outputNode) {
            updateSampleEffects(sampleNumber);
            return;
        }
        const sourceNode = sample.gainNode;
        const outputNode = audioContext.createGain();
        outputNode.gain.value = 1;
        const dryPath = audioContext.createGain();
        dryPath.gain.value = 1;
        const wetPath = audioContext.createGain();
        wetPath.gain.value = 0;
        sample.wetPathNode = wetPath;
        sample.dryPathNode = dryPath;
        sample.outputNode = outputNode;
        sourceNode.connect(dryPath);
        sourceNode.connect(wetPath);
        dryPath.connect(outputNode);
        wetPath.connect(outputNode);
        let lastEffectNode = wetPath;
        const delayNode = audioContext.createDelay(1);
        delayNode.delayTime.value = 0;
        const feedbackGain = audioContext.createGain();
        feedbackGain.gain.value = 0;
        lastEffectNode.connect(delayNode);
        delayNode.connect(feedbackGain);
        feedbackGain.connect(delayNode);
        delayNode.connect(outputNode);
        lastEffectNode = delayNode;
        sample.delayNode = delayNode;
        sample.delayFeedbackNode = feedbackGain;
        const convolver = audioContext.createConvolver();
        const length = audioContext.sampleRate * .1;
        const impulse = audioContext.createBuffer(2, length, audioContext.sampleRate);
        for (let channel = 0; channel < 2; channel++) {
            const channelData = impulse.getChannelData(channel);
            for (let i = 0; i < length; i++) {
                channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
            }
        }
        convolver.buffer = impulse;
        const reverbMix = audioContext.createGain();
        const effects = sample.effects || {};
        reverbMix.gain.value = effects.reverb && effects.reverb.mix ? effects.reverb.mix / 100 : 0;
        lastEffectNode.connect(convolver);
        convolver.connect(reverbMix);
        reverbMix.connect(outputNode);
        sample.reverbNode = convolver;
        sample.reverbMixNode = reverbMix;
        
        // Initialize LFO for main sample - ensure it's unique to this sample
        const lfo = audioContext.createOscillator();
        lfo.type = 'sine';
        lfo.frequency.value = 1.0;
        const lfoGain = audioContext.createGain();
        lfoGain.gain.value = 0;
        lfo.connect(lfoGain);
        sample.lfoNode = lfo;
        sample.lfoGainNode = lfoGain;
        sample.lfoBaseRate = 1.0; // Store the base rate for tempo changes
        lfo.start();
        
        // Create a separate gain node for individual volume modulation
        const individualVolumeGain = audioContext.createGain();
        individualVolumeGain.gain.value = sample.individualVolume || 1.0;
        sample.individualVolumeGain = individualVolumeGain;
        
        // Reconnect the audio chain to include the individual volume gain node
        sourceNode.disconnect();
        sourceNode.connect(individualVolumeGain);
        individualVolumeGain.connect(dryPath);
        individualVolumeGain.connect(wetPath);
        
        const storedEffects = sample.effects || {
            delay: {
                time: 0,
                feedback: 0
            },
            reverb: {
                decay: 0,
                mix: 0,
                predelay: 0,
                diffusion: 50,
                lowcut: 20,
                highcut: 2e4,
                damping: 50
            },
            eq: [{
                frequency: 20,
                gain: 0,
                q: 1,
                type: "lowshelf",
                fixed: true
            }, {
                frequency: 2e4,
                gain: 0,
                q: 1,
                type: "highshelf",
                fixed: true
            }],
            volume: 100,
            speed: 1,
            individualTempo: 1,
            lfos: [
                {
                    target: "none",
                    waveform: "sine",
                    rate: 1.0,
                    depth: 0
                },
                {
                    target: "none",
                    waveform: "sine",
                    rate: 1.0,
                    depth: 0
                },
                {
                    target: "none",
                    waveform: "sine",
                    rate: 1.0,
                    depth: 0
                },
                {
                    target: "none",
                    waveform: "sine",
                    rate: 1.0,
                    depth: 0
                }
            ],
            pianoRoll: {
                notes: [],
                soundSource: "sounddesign",
                soundDesign: {
                    osc1: { wave: "sine", detune: 0, level: 50 },
                    osc2: { wave: "sawtooth", detune: 0, level: 50 },
                    filter: { type: "lowpass", cutoff: 2000, resonance: 0 },
                    envelope: { attack: 10, decay: 100, sustain: 70, release: 200, sustainTime: 10 },
                    envToPitch: { enabled: false, amount: 0 }
                },
                gridWidth: sample.isLongSample ? 32 : 16,
                gridHeight: 84,
                scrollX: 0,
                scrollY: 0,
                sampleRange: {
                    start: 0,
                    end: 100
                },
                filters: {
                    lowShelf: 0,
                    highShelf: 0,
                    lowMid: 0,
                    mid: 0,
                    highMid: 0,
                    delay: {
                        time: 0,
                        feedback: 0
                    }
                },
                isEnabled: false
            }
        };
        if (storedEffects.pianoRoll && !pianoRollData[sampleNumber]) {
            pianoRollData[sampleNumber] = JSON.parse(JSON.stringify(storedEffects.pianoRoll));
        }
        const lowFilter = audioContext.createBiquadFilter();
        lowFilter.type = "lowshelf";
        lowFilter.frequency.value = 60;
        lowFilter.gain.value = 0;
        const lowMidFilter = audioContext.createBiquadFilter();
        lowMidFilter.type = "peaking";
        lowMidFilter.frequency.value = 230;
        lowMidFilter.Q.value = 1;
        lowMidFilter.gain.value = 0;
        const midFilter = audioContext.createBiquadFilter();
        midFilter.type = "peaking";
        midFilter.frequency.value = 910;
        midFilter.Q.value = 1;
        midFilter.gain.value = 0;
        const highMidFilter = audioContext.createBiquadFilter();
        highMidFilter.type = "peaking";
        highMidFilter.frequency.value = 3e3;
        highMidFilter.Q.value = 1;
        highMidFilter.gain.value = 0;
        const highMid2Filter = audioContext.createBiquadFilter();
        highMid2Filter.type = "peaking";
        highMid2Filter.frequency.value = 6e3;
        highMid2Filter.Q.value = 1;
        highMid2Filter.gain.value = 0;
        const highFilter = audioContext.createBiquadFilter();
        highFilter.type = "highshelf";
        highFilter.frequency.value = 1e4;
        highFilter.gain.value = 0;
        const veryHighFilter = audioContext.createBiquadFilter();
        veryHighFilter.type = "highshelf";
        veryHighFilter.frequency.value = 14e3;
        veryHighFilter.gain.value = 0;
        
        // Create a dedicated filter for LFO modulation - ensure it's unique to this sample
        const lfoFilter = audioContext.createBiquadFilter();
        lfoFilter.type = "lowpass";
        lfoFilter.frequency.value = 2000;
        lfoFilter.Q.value = 1;
        lfoFilter.gain.value = 0;
        sample.lfoFilter = lfoFilter;
        
        outputNode.connect(lowFilter);
        lowFilter.connect(lowMidFilter);
        lowMidFilter.connect(midFilter);
        midFilter.connect(highMidFilter);
        highMidFilter.connect(highMid2Filter);
        highMid2Filter.connect(highFilter);
        
        // FIX: Only include LFO filter in the chain if LFO target is "filter"
        // Create a bypass node that connects directly to veryHighFilter when LFO target is not "filter"
        const lfoFilterBypass = audioContext.createGain();
        lfoFilterBypass.gain.value = 1.0;
        
        // Connect both paths
        highFilter.connect(lfoFilter);
        highFilter.connect(lfoFilterBypass);
        
        // Initially bypass the LFO filter
        lfoFilterBypass.connect(veryHighFilter);
        
        // Store the bypass node for later use
        sample.lfoFilterBypass = lfoFilterBypass;
        
        veryHighFilter.connect(masterOutputNode);
        sample.eqLowNode = lowFilter;
        sample.eqLowMidNode = lowMidFilter;
        sample.eqMidNode = midFilter;
        sample.eqHighMidNode = highMidFilter;
        sample.eqHighMid2Node = highMid2Filter;
        sample.eqHighNode = highFilter;
        sample.eqVeryHighNode = veryHighFilter;
        if (sample.effects) {
            updateSampleEffects(sampleNumber);
        }
    }

    function showEffectsPopup(sampleNumber, button) {
        currentSampleForPopup = sampleNumber;
        document.getElementById("popup-sample-number").textContent = sampleNumber;
        
        // Set the EQ visualizer toggle state based on the sample's stored state
        const eqVisualizerToggle = document.getElementById("eq-visualizer-toggle");
        if (eqVisualizerToggle) {
            eqVisualizerToggle.checked = currentPlaying[sampleNumber].eqVisualizerEnabled || false;
        }
        
        const loadingIndicator = document.getElementById("piano-roll-loading");
        if (loadingIndicator) {
            loadingIndicator.style.display = "none";
        }
        const effects = currentPlaying[sampleNumber].effects || {
            delay: {
                time: 0,
                feedback: 0
            },
            reverb: {
                decay: 0,
                mix: 0,
                predelay: 0,
                diffusion: 50,
                lowcut: 20,
                highcut: 2e4,
                damping: 50
            },
            eq: [{
                frequency: 20,
                gain: 0,
                q: 1,
                type: "lowshelf",
                fixed: true
            }, {
                frequency: 2e4,
                gain: 0,
                q: 1,
                type: "highshelf",
                fixed: true
            }],
            volume: 100,
            speed: 1,
            individualTempo: 1,
            lfos: [
                {
                    target: "none",
                    waveform: "sine",
                    rate: 1.0,
                    depth: 0
                },
                {
                    target: "none",
                    waveform: "sine",
                    rate: 1.0,
                    depth: 0
                },
                {
                    target: "none",
                    waveform: "sine",
                    rate: 1.0,
                    depth: 0
                },
                {
                    target: "none",
                    waveform: "sine",
                    rate: 1.0,
                    depth: 0
                }
            ],
            pianoRoll: {
                notes: [],
                soundSource: "sounddesign",
                soundDesign: {
                    osc1: { wave: "sine", detune: 0, level: 50 },
                    osc2: { wave: "sawtooth", detune: 0, level: 50 },
                    filter: { type: "lowpass", cutoff: 2000, resonance: 0 },
                    envelope: { attack: 10, decay: 100, sustain: 70, release: 200, sustainTime: 10 },
                    envToPitch: { enabled: false, amount: 0 }
                },
                gridWidth: sampleNumber > 60 ? 32 : 16,
                gridHeight: 84,
                scrollX: 0,
                scrollY: 0,
                sampleRange: {
                    start: 0,
                    end: 100
                },
                filters: {
                    lowShelf: 0,
                    highShelf: 0,
                    lowMid: 0,
                    mid: 0,
                    highMid: 0,
                    delay: {
                        time: 0,
                        feedback: 0
                    }
                },
                isEnabled: false
            }
        };
        
        // Ensure lfos array exists and has all 4 LFOs with proper defaults
        if (!effects.lfos || !Array.isArray(effects.lfos) || effects.lfos.length !== 4) {
            effects.lfos = [
                { target: "none", waveform: "sine", rate: 1.0, depth: 0 },
                { target: "none", waveform: "sine", rate: 1.0, depth: 0 },
                { target: "none", waveform: "sine", rate: 1.0, depth: 0 },
                { target: "none", waveform: "sine", rate: 1.0, depth: 0 }
            ];
        }
        
        originalEffects = JSON.parse(JSON.stringify(effects));
        temporaryEffects = JSON.parse(JSON.stringify(effects));
        if (effects.pianoRoll) {
            pianoRollData[sampleNumber] = JSON.parse(JSON.stringify(effects.pianoRoll));
            if (pianoRollData[sampleNumber].isEnabled === undefined) {
                pianoRollData[sampleNumber].isEnabled = false;
            }
        } else if (!pianoRollData[sampleNumber]) {
            pianoRollData[sampleNumber] = {
                notes: [],
                soundSource: "sounddesign",
                gridWidth: sampleNumber > 60 ? 32 : 16,
                gridHeight: 84,
                scrollX: 0,
                scrollY: 0,
                sampleRange: {
                    start: 0,
                    end: 100
                },
                filters: {
                    lowShelf: 0,
                    highShelf: 0,
                    lowMid: 0,
                    mid: 0,
                    highMid: 0,
                    delay: {
                        time: 0,
                        feedback: 0
                    }
                },
                isEnabled: false
            };
        }
        
        // Ensure lfos array exists with proper structure
        if (!temporaryEffects.lfos || !Array.isArray(temporaryEffects.lfos) || temporaryEffects.lfos.length !== 4) {
            temporaryEffects.lfos = [
                { target: "none", waveform: "sine", rate: 1.0, depth: 0 },
                { target: "none", waveform: "sine", rate: 1.0, depth: 0 },
                { target: "none", waveform: "sine", rate: 1.0, depth: 0 },
                { target: "none", waveform: "sine", rate: 1.0, depth: 0 }
            ];
        }
        
        // Ensure automations array exists with proper structure
        if (!temporaryEffects.automations || !Array.isArray(temporaryEffects.automations) || temporaryEffects.automations.length !== 4) {
            temporaryEffects.automations = [
                { target: "none", start: 50, end: 50, duration: 4, curve: "linear" },
                { target: "none", start: 50, end: 50, duration: 4, curve: "linear" },
                { target: "none", start: 50, end: 50, duration: 4, curve: "linear" },
                { target: "none", start: 50, end: 50, duration: 4, curve: "linear" }
            ];
        }
        
        document.getElementById("sample-volume").value = temporaryEffects.volume || 100;
        document.getElementById("sample-volume-value").textContent = `${temporaryEffects.volume||100}%`;
        document.getElementById("delay-time").value = temporaryEffects.delay.time;
        document.getElementById("delay-time-value").textContent = temporaryEffects.delay.time;
        document.getElementById("delay-feedback").value = temporaryEffects.delay.feedback;
        document.getElementById("delay-feedback-value").textContent = temporaryEffects.delay.feedback;
        document.getElementById("reverb-decay").value = temporaryEffects.reverb.decay;
        document.getElementById("reverb-decay-value").textContent = temporaryEffects.reverb.decay;
        document.getElementById("reverb-predelay").value = temporaryEffects.reverb.predelay;
        document.getElementById("reverb-predelay-value").textContent = temporaryEffects.reverb.predelay;
        document.getElementById("reverb-diffusion").value = temporaryEffects.reverb.diffusion;
        document.getElementById("reverb-diffusion-value").textContent = temporaryEffects.reverb.diffusion;
        document.getElementById("reverb-lowcut").value = temporaryEffects.reverb.lowcut;
        document.getElementById("reverb-lowcut-value").textContent = temporaryEffects.reverb.lowcut;
        document.getElementById("reverb-highcut").value = temporaryEffects.reverb.highcut;
        document.getElementById("reverb-highcut-value").textContent = temporaryEffects.reverb.highcut;
        document.getElementById("reverb-damping").value = temporaryEffects.reverb.damping;
        document.getElementById("reverb-damping-value").textContent = temporaryEffects.reverb.damping;
        document.getElementById("reverb-mix").value = temporaryEffects.reverb.mix;
        document.getElementById("reverb-mix-value").textContent = temporaryEffects.reverb.mix;
        document.getElementById("speed-select").value = temporaryEffects.speed || 1;
        if (sampleNumber > 60) {
            document.getElementById("individual-tempo").value = temporaryEffects.individualTempo || 1;
            document.getElementById("individual-tempo-value").textContent = temporaryEffects.individualTempo || 1;
        }
        
        // Initialize LFO tabs and panels
        setupLFOTabs();
        
        // Initialize Automation tabs and panels
        setupAutomationTabs();
        
        // Load values for all 4 LFOs
        console.log('Loading LFO values for sample', sampleNumber, ':', temporaryEffects.lfos);
        for (let i = 0; i < 4; i++) {
            const lfoNum = i + 1;
            const lfo = temporaryEffects.lfos[i];
            
            console.log(`LFO ${lfoNum}:`, lfo);
            
            document.getElementById(`lfo-${lfoNum}-target`).value = lfo.target || "none";
            document.getElementById(`lfo-${lfoNum}-waveform`).value = lfo.waveform || "sine";
            document.getElementById(`lfo-${lfoNum}-rate`).value = lfo.rate || 1.0;
            document.getElementById(`lfo-${lfoNum}-rate-value`).textContent = (lfo.rate || 1.0).toFixed(1);
            document.getElementById(`lfo-${lfoNum}-depth`).value = lfo.depth || 0;
            document.getElementById(`lfo-${lfoNum}-depth-value`).textContent = `${lfo.depth||0}%`;
            
            // Draw the LFO waveform immediately after loading values
            drawLFOWaveform(lfoNum);
        }
        
        // Load automation values for all 4 automations
        for (let autoNum = 1; autoNum <= 4; autoNum++) {
            const autoIndex = autoNum - 1;
            const auto = temporaryEffects.automations && temporaryEffects.automations[autoIndex] ?
                        temporaryEffects.automations[autoIndex] : 
                        { target: "none", start: 50, end: 50, duration: 1, curve: "linear", bars: "*", loop: true };
            
            console.log(`Automation ${autoNum}:`, auto);
            
            document.getElementById(`automation-${autoNum}-target`).value = auto.target || "none";
            document.getElementById(`automation-${autoNum}-start`).value = auto.start !== undefined ? auto.start : 50;
            document.getElementById(`automation-${autoNum}-start-value`).textContent = auto.start !== undefined ? auto.start : 50;
            document.getElementById(`automation-${autoNum}-end`).value = auto.end !== undefined ? auto.end : 50;
            document.getElementById(`automation-${autoNum}-end-value`).textContent = auto.end !== undefined ? auto.end : 50;
            document.getElementById(`automation-${autoNum}-duration`).value = auto.duration !== undefined ? auto.duration : 1;
            document.getElementById(`automation-${autoNum}-duration-value`).textContent = auto.duration !== undefined ? auto.duration : 1;
            document.getElementById(`automation-${autoNum}-curve`).value = auto.curve || "linear";
            
            const barsInput = document.getElementById(`automation-${autoNum}-bars`);
            if (barsInput) {
                barsInput.value = auto.bars || "*";
            }
            
            const loopCheckbox = document.getElementById(`automation-${autoNum}-loop`);
            if (loopCheckbox) {
                loopCheckbox.checked = auto.loop !== undefined ? auto.loop : true;
            }
        }
        
        if (temporaryEffects.pianoRoll && temporaryEffects.pianoRoll.filters) {
            document.getElementById("piano-roll-lowshelf").value = temporaryEffects.pianoRoll.filters.lowShelf || 0;
            document.getElementById("piano-roll-lowshelf-value").textContent = `${temporaryEffects.pianoRoll.filters.lowShelf||0}dB`;
            document.getElementById("piano-roll-lowmid").value = temporaryEffects.pianoRoll.filters.lowMid || 0;
            document.getElementById("piano-roll-lowmid-value").textContent = `${temporaryEffects.pianoRoll.filters.lowMid||0}dB`;
            document.getElementById("piano-roll-mid").value = temporaryEffects.pianoRoll.filters.mid || 0;
            document.getElementById("piano-roll-mid-value").textContent = `${temporaryEffects.pianoRoll.filters.mid||0}dB`;
            document.getElementById("piano-roll-highmid").value = temporaryEffects.pianoRoll.filters.highMid || 0;
            document.getElementById("piano-roll-highmid-value").textContent = `${temporaryEffects.pianoRoll.filters.highMid||0}dB`;
            document.getElementById("piano-roll-highshelf").value = temporaryEffects.pianoRoll.filters.highShelf || 0;
            document.getElementById("piano-roll-highshelf-value").textContent = `${temporaryEffects.pianoRoll.filters.highShelf||0}dB`;
            document.getElementById("piano-roll-delay-time").value = temporaryEffects.pianoRoll.filters.delay.time || 0;
            document.getElementById("piano-roll-delay-time-value").textContent = `${temporaryEffects.pianoRoll.filters.delay.time||0}ms`;
            document.getElementById("piano-roll-delay-feedback").value = temporaryEffects.pianoRoll.filters.delay.feedback || 0;
            document.getElementById("piano-roll-delay-feedback-value").textContent = `${temporaryEffects.pianoRoll.filters.delay.feedback||0}%`;
        }
        const gridRect = gridPanel.getBoundingClientRect();
        const popupWidth = gridRect.width;
        const marginTop = 4; // 4px top margin
        const marginBottom = 4; // 4px bottom margin
        const popupHeight = window.innerHeight - marginTop - marginBottom; // Full height minus margins
        effectsPopup.style.left = `${(window.innerWidth-popupWidth)/2}px`;
        effectsPopup.style.top = `${marginTop}px`; // Position with top margin
        effectsPopup.style.width = `${popupWidth}px`;
        effectsPopup.style.height = `${popupHeight}px`;
        effectsPopup.style.display = "flex";
        
        // FIX: Reset scroll position to top when popup opens
        // The .popup-content div is the scrollable element
        const popupContent = effectsPopup.querySelector(".popup-content");
        if (popupContent) {
            popupContent.scrollTop = 0;
        }
        
        const individualTempoSection = document.querySelector(".individual-tempo-section");
        if (individualTempoSection) {
            if (sampleNumber <= 60) {
                individualTempoSection.style.display = "none";
            } else {
                individualTempoSection.style.display = "block";
            }
        }
        setTimeout(() => {
            initVisualEQ();
            initializeSpeedAndTempoControls();
            
            // Setup LFO event listeners for all 4 LFOs
            setupAllLFOEventListeners(sampleNumber);
            
            // Initialize LFO visualizers for all 4 LFOs (after popup is visible)
            // Add a small delay to ensure canvas dimensions are calculated
            setTimeout(() => {
                initAllLFOVisualizers();
            }, 50);
            
            // Initialize LFO connections for real-time preview
            initializeAllLFOConnections(sampleNumber);
            
            // Setup Automation event listeners for all 4 automations
            setupAllAutomationEventListeners(sampleNumber);
            
            // Initialize automation visualizers
            setTimeout(() => {
                initAllAutomationVisualizers();
            }, 50);
            
            const pianoRollToggle = document.getElementById("piano-roll-toggle");
            const pianoRollContent = document.querySelector(".piano-roll-content");
            pianoRollToggle.replaceWith(pianoRollToggle.cloneNode(true));
            const newPianoRollToggle = document.getElementById("piano-roll-toggle");
            newPianoRollToggle.checked = pianoRollData[sampleNumber].isEnabled;
            if (pianoRollData[sampleNumber].isEnabled) {
                pianoRollContent.classList.add("visible");
            } else {
                pianoRollContent.classList.remove("visible");
            }
            newPianoRollToggle.addEventListener("change", function () {
                if (this.checked) {
                    pianoRollContent.classList.add("visible");
                    pianoRollData[sampleNumber].isEnabled = true;
                    initPianoRoll();
                    initPianoRollFilters();
                    const sd = document.querySelector('.sound-design-controls');
                    if (sd) sd.style.display = (document.getElementById('piano-roll-sound-source').value === 'sounddesign') ? '' : 'none';
                } else {
                    pianoRollContent.classList.remove("visible");
                    pianoRollData[sampleNumber].isEnabled = false;
                    if (isPreviewingPianoRoll) {
                        stopPianoRollPreview();
                    }
                }
            });
            const uploadStatus = document.getElementById("upload-status");
            const recordStatus = document.getElementById("record-status");
            uploadStatus.textContent = uploadStatusPerSample[sampleNumber] || "";
            recordStatus.textContent = recordStatusPerSample[sampleNumber] || "";
            const microphoneRecordBtn = document.getElementById("microphone-record-btn");
            if (microphoneRecordBtn) {
                microphoneRecordBtn.replaceWith(microphoneRecordBtn.cloneNode(true));
                const newMicrophoneRecordBtn = document.getElementById("microphone-record-btn");
                newMicrophoneRecordBtn.addEventListener("click", function () {
                    handleMicrophoneRecording(sampleNumber);
                });
                if (recordedBlobs[sampleNumber]) {
                    newMicrophoneRecordBtn.textContent = "Record New";
                } else {
                    newMicrophoneRecordBtn.textContent = "Start Recording";
                }
            }
            const microphoneSaveBtn = document.getElementById("microphone-save-btn");
            if (microphoneSaveBtn) {
                microphoneSaveBtn.replaceWith(microphoneSaveBtn.cloneNode(true));
                const newMicrophoneSaveBtn = document.getElementById("microphone-save-btn");
                newMicrophoneSaveBtn.addEventListener("click", function () {
                    saveMicrophoneRecording(sampleNumber);
                });
                if (recordedBlobs[sampleNumber]) {
                    newMicrophoneSaveBtn.style.display = "inline-block";
                } else {
                    newMicrophoneSaveBtn.style.display = "none";
                }
            }
            const microphoneDownloadBtn = document.getElementById("microphone-download-btn");
            if (microphoneDownloadBtn) {
                microphoneDownloadBtn.replaceWith(microphoneDownloadBtn.cloneNode(true));
                const newMicrophoneDownloadBtn = document.getElementById("microphone-download-btn");
                newMicrophoneDownloadBtn.addEventListener("click", function () {
                    downloadMicrophoneRecording(sampleNumber);
                });
                if (recordedBlobs[sampleNumber]) {
                    newMicrophoneDownloadBtn.style.display = "inline-block";
                } else {
                    newMicrophoneDownloadBtn.style.display = "none";
                }
            }
            const microphoneDeleteBtn = document.getElementById("microphone-delete-btn");
            if (microphoneDeleteBtn) {
                microphoneDeleteBtn.replaceWith(microphoneDeleteBtn.cloneNode(true));
                const newMicrophoneDeleteBtn = document.getElementById("microphone-delete-btn");
                newMicrophoneDeleteBtn.addEventListener("click", function () {
                    deleteMicrophoneRecording(sampleNumber);
                });
                if (recordedBlobs[sampleNumber]) {
                    newMicrophoneDeleteBtn.style.display = "inline-block";
                } else {
                    newMicrophoneDeleteBtn.style.display = "none";
                }
            }
            if (currentPlaying[sampleNumber] && currentPlaying[sampleNumber].isScheduled) {
                initWaveformVisualization();
            }
        }, 100);
    }

    // New function to setup LFO event listeners with proper scoping
    // LFO Tab Switching
    function setupLFOTabs() {
        const tabs = document.querySelectorAll('.lfo-tab');
        const panels = document.querySelectorAll('.lfo-panel');
        
        console.log('setupLFOTabs: Found', tabs.length, 'tabs and', panels.length, 'panels');
        
        // Clone all tabs to remove old event listeners
        tabs.forEach(tab => {
            const newTab = tab.cloneNode(true);
            tab.parentNode.replaceChild(newTab, tab);
        });
        
        // Re-query after cloning
        const newTabs = document.querySelectorAll('.lfo-tab');
        
        newTabs.forEach(tab => {
            tab.addEventListener('click', function() {
                const lfoNum = this.getAttribute('data-lfo');
                console.log('LFO tab clicked:', lfoNum);
                
                // Remove active class from all tabs and panels
                newTabs.forEach(t => t.classList.remove('active'));
                panels.forEach(p => p.classList.remove('active'));
                
                // Add active class to clicked tab and corresponding panel
                this.classList.add('active');
                document.getElementById(`lfo-panel-${lfoNum}`).classList.add('active');
                
                // Reinitialize the canvas size when panel becomes visible, then draw
                setTimeout(() => {
                    initSingleLFOVisualizer(parseInt(lfoNum));
                }, 10);
            });
        });
    }
    
    // Setup event listeners for all 4 LFOs
    function setupAllLFOEventListeners(sampleNumber) {
        for (let i = 1; i <= 4; i++) {
            setupSingleLFOEventListeners(sampleNumber, i);
        }
    }
    
    // Setup event listeners for a single LFO
    function setupSingleLFOEventListeners(sampleNumber, lfoNum) {
        const lfoIndex = lfoNum - 1;
        
        const target = document.getElementById(`lfo-${lfoNum}-target`);
        const waveform = document.getElementById(`lfo-${lfoNum}-waveform`);
        const rate = document.getElementById(`lfo-${lfoNum}-rate`);
        const depth = document.getElementById(`lfo-${lfoNum}-depth`);
        
        // Store current values before cloning
        const targetValue = target.value;
        const waveformValue = waveform.value;
        const rateValue = rate.value;
        const depthValue = depth.value;
        
        // Clone to remove old listeners
        const newTarget = target.cloneNode(true);
        const newWaveform = waveform.cloneNode(true);
        const newRate = rate.cloneNode(true);
        const newDepth = depth.cloneNode(true);
        
        // Restore values after cloning
        newTarget.value = targetValue;
        newWaveform.value = waveformValue;
        newRate.value = rateValue;
        newDepth.value = depthValue;
        
        target.parentNode.replaceChild(newTarget, target);
        waveform.parentNode.replaceChild(newWaveform, waveform);
        rate.parentNode.replaceChild(newRate, rate);
        depth.parentNode.replaceChild(newDepth, depth);
        
        newTarget.addEventListener("change", function() {
            updateSingleLFOInRealTime(sampleNumber, lfoNum);
        });
        
        newWaveform.addEventListener("change", function() {
            updateSingleLFOInRealTime(sampleNumber, lfoNum);
        });
        
        newRate.addEventListener("input", function() {
            updateSingleLFOInRealTime(sampleNumber, lfoNum);
        });
        
        newDepth.addEventListener("input", function() {
            updateSingleLFOInRealTime(sampleNumber, lfoNum);
        });
    }
    
    // Update a single LFO in real-time
    function updateSingleLFOInRealTime(sampleNumber, lfoNum) {
        if (!sampleNumber) sampleNumber = currentSampleForPopup;
        if (!sampleNumber || !currentPlaying[sampleNumber]) return;
        
        console.log('updateSingleLFOInRealTime:', sampleNumber, lfoNum);
        
        const lfoIndex = lfoNum - 1;
        const sample = currentPlaying[sampleNumber];
        
        const target = document.getElementById(`lfo-${lfoNum}-target`).value;
        const waveform = document.getElementById(`lfo-${lfoNum}-waveform`).value;
        const rate = parseFloat(document.getElementById(`lfo-${lfoNum}-rate`).value);
        const depth = parseInt(document.getElementById(`lfo-${lfoNum}-depth`).value);
        
        console.log('LFO settings:', { target, waveform, rate, depth });
        
        document.getElementById(`lfo-${lfoNum}-rate-value`).textContent = rate.toFixed(1);
        document.getElementById(`lfo-${lfoNum}-depth-value`).textContent = `${depth}%`;
        
        if (temporaryEffects && sampleNumber === currentSampleForPopup) {
            if (!temporaryEffects.lfos) temporaryEffects.lfos = [{},{},{},{}];
            temporaryEffects.lfos[lfoIndex] = { target, waveform, rate, depth };
        }
        
        // Update the sample's effects directly
        if (!sample.effects) sample.effects = {};
        if (!sample.effects.lfos) sample.effects.lfos = [{},{},{},{}];
        sample.effects.lfos[lfoIndex] = { target, waveform, rate, depth };
        
        // Initialize or update LFO connection
        initializeSingleLFOConnection(sampleNumber, lfoNum);
        
        // Update visualizer
        drawLFOWaveform(lfoNum);
    }
    
    // Initialize all 4 LFO visualizers
    function initAllLFOVisualizers() {
        // Initialize LFO 1 immediately since its panel is active/visible
        initSingleLFOVisualizer(1);
        
        // For LFOs 2-4, set reasonable default dimensions
        // They will be properly initialized when their tabs are clicked
        for (let i = 2; i <= 4; i++) {
            const lfoCanvas = document.getElementById(`lfo-${i}-wave`);
            if (lfoCanvas) {
                // Set a reasonable default size
                lfoCanvas.width = 300;
                lfoCanvas.height = 60;
            }
        }
    }
    
    // Initialize a single LFO visualizer
    function initSingleLFOVisualizer(lfoNum) {
        const lfoCanvas = document.getElementById(`lfo-${lfoNum}-wave`);
        if (!lfoCanvas) return;
        
        const ctx = lfoCanvas.getContext("2d");
        const container = lfoCanvas.parentElement;
        lfoCanvas.width = container.clientWidth;
        lfoCanvas.height = container.clientHeight;
        
        drawLFOWaveform(lfoNum);
    }
    
    // Draw LFO waveform for a specific LFO
    function drawLFOWaveform(lfoNum) {
        const lfoCanvas = document.getElementById(`lfo-${lfoNum}-wave`);
        if (!lfoCanvas) return;
        
        const ctx = lfoCanvas.getContext("2d");
        const width = lfoCanvas.width;
        const height = lfoCanvas.height;
        
        // Clear canvas
        ctx.fillStyle = "#111";
        ctx.fillRect(0, 0, width, height);
        
        // Get current LFO settings
        const waveform = document.getElementById(`lfo-${lfoNum}-waveform`).value;
        const rate = parseFloat(document.getElementById(`lfo-${lfoNum}-rate`).value);
        const depth = parseInt(document.getElementById(`lfo-${lfoNum}-depth`).value);
        
        // Draw grid
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, height / 2);
        ctx.lineTo(width, height / 2);
        ctx.stroke();
        
        // Different color for each LFO
        const lfoColors = {
            1: "#3F51B5",  // Indigo (original)
            2: "#E91E63",  // Pink
            3: "#00BCD4",  // Cyan
            4: "#FF9800"   // Orange
        };
        
        // Draw waveform with LFO-specific color
        ctx.strokeStyle = lfoColors[lfoNum] || "#3F51B5";
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        const samples = width;
        const period = samples / (rate * 10);
        const amplitude = (height / 2) * (depth / 100);
        
        for (let x = 0; x < samples; x++) {
            let y;
            const phase = (x % period) / period * Math.PI * 2;
            
            switch (waveform) {
                case "sine":
                    y = height / 2 - Math.sin(phase) * amplitude;
                    break;
                case "square":
                    y = height / 2 - (Math.sin(phase) > 0 ? 1 : -1) * amplitude;
                    break;
                case "triangle":
                    const t = (phase / Math.PI) % 2;
                    y = height / 2 - (t < 1 ? 2 * t - 1 : 3 - 2 * t) * amplitude;
                    break;
                case "sawtooth":
                    y = height / 2 - (2 * ((phase / Math.PI) % 1) - 1) * amplitude;
                    break;
                default:
                    y = height / 2;
            }
            
            if (x === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        
        ctx.stroke();
    }
    
    // Initialize LFO connections for all 4 LFOs
    function initializeAllLFOConnections(sampleNumber) {
        for (let i = 1; i <= 4; i++) {
            initializeSingleLFOConnection(sampleNumber, i);
        }
    }
    
    // Initialize a single LFO connection
    function initializeSingleLFOConnection(sampleNumber, lfoNum) {
        if (!currentPlaying[sampleNumber]) return;
        
        const lfoIndex = lfoNum - 1;
        const sample = currentPlaying[sampleNumber];
        
        // Ensure LFO nodes array exists
        if (!sample.lfoNodes) sample.lfoNodes = [null, null, null, null];
        if (!sample.lfoGainNodes) sample.lfoGainNodes = [null, null, null, null];
        if (!sample.lfoFilterOffsetNodes) sample.lfoFilterOffsetNodes = [null, null, null, null];
        if (!sample.lfoUpdateTimeouts) sample.lfoUpdateTimeouts = [null, null, null, null];
        if (!sample.lfoTargets) sample.lfoTargets = ["none", "none", "none", "none"];
        if (!sample.lfoPitchIntervals) sample.lfoPitchIntervals = [null, null, null, null];
        
        // Get LFO settings
        const lfo = sample.effects && sample.effects.lfos && sample.effects.lfos[lfoIndex] ?
                    sample.effects.lfos[lfoIndex] : { target: "none", waveform: "sine", rate: 1.0, depth: 0 };
        
        // Clear any existing update timeout for this LFO
        if (sample.lfoUpdateTimeouts[lfoIndex]) {
            clearTimeout(sample.lfoUpdateTimeouts[lfoIndex]);
            sample.lfoUpdateTimeouts[lfoIndex] = null;
        }
        
        // If target is "none" or depth is 0, disconnect but still start update loop
        // (so automation can enable it later)
        if (lfo.target === "none" || lfo.depth === 0) {
            disconnectSingleLFO(sample, lfoIndex);
            // Start update loop anyway (will check for activation)
            startLFOUpdateLoop(sample, sampleNumber, lfoIndex);
            return;
        }
        
        // Create or reuse LFO oscillator and gain node
        if (!sample.lfoNodes[lfoIndex]) {
            sample.lfoNodes[lfoIndex] = audioContext.createOscillator();
            sample.lfoNodes[lfoIndex].start();
        }
        
        if (!sample.lfoGainNodes[lfoIndex]) {
            sample.lfoGainNodes[lfoIndex] = audioContext.createGain();
        }
        
        const lfoNode = sample.lfoNodes[lfoIndex];
        const lfoGainNode = sample.lfoGainNodes[lfoIndex];
        
        // Update LFO parameters
        lfoNode.type = lfo.waveform;
        lfoNode.frequency.setValueAtTime(lfo.rate, audioContext.currentTime);
        
        // Connect LFO to gain node
        try {
            lfoNode.disconnect();
        } catch (e) {}
        lfoNode.connect(lfoGainNode);
        
        // Disconnect previous connections
        try {
            lfoGainNode.disconnect();
        } catch (e) {}
        
        // Disconnect offset node if it exists
        if (sample.lfoFilterOffsetNodes[lfoIndex]) {
            try {
                sample.lfoFilterOffsetNodes[lfoIndex].disconnect();
                sample.lfoFilterOffsetNodes[lfoIndex].stop();
                sample.lfoFilterOffsetNodes[lfoIndex] = null;
            } catch (e) {}
        }
        
        // Clear any existing update timeout
        if (sample.lfoUpdateTimeouts[lfoIndex]) {
            clearTimeout(sample.lfoUpdateTimeouts[lfoIndex]);
            sample.lfoUpdateTimeouts[lfoIndex] = null;
        }
        
        // Connect to the appropriate target (using similar logic as before but for individual LFOs)
        connectLFOToTarget(sample, lfoIndex, lfo, lfoNode, lfoGainNode, sampleNumber);
        
        // Start the update loop to handle automation changes
        startLFOUpdateLoop(sample, sampleNumber, lfoIndex);
    }
    
    // Start the LFO parameter update loop for handling automation changes
    function startLFOUpdateLoop(sample, sampleNumber, lfoIndex) {
        // Clear any existing timeout
        if (sample.lfoUpdateTimeouts && sample.lfoUpdateTimeouts[lfoIndex]) {
            clearTimeout(sample.lfoUpdateTimeouts[lfoIndex]);
        }
        
        const updateLFOParameters = () => {
            if (!currentPlaying[sampleNumber] || !currentPlaying[sampleNumber].isScheduled) {
                return; // Stop updating if sample stopped
            }
            
            const currentLfo = sample.effects?.lfos?.[lfoIndex];
            if (!currentLfo) {
                // Schedule next update to keep checking
                sample.lfoUpdateTimeouts[lfoIndex] = setTimeout(updateLFOParameters, 50);
                return;
            }
            
            // Check if LFO should be active
            const shouldBeActive = currentLfo.target !== "none" && currentLfo.depth > 0;
            const isCurrentlyActive = sample.lfoNodes && sample.lfoNodes[lfoIndex] !== null;
            
            // If LFO should be active but isn't, reinitialize it
            if (shouldBeActive && !isCurrentlyActive) {
                console.log(`[LFO] Automation activated LFO ${lfoIndex + 1} for sample ${sampleNumber}`);
                // Reinitialize the LFO connection (but don't restart the loop - we're already in it!)
                const lfoNode = sample.lfoNodes[lfoIndex] = audioContext.createOscillator();
                lfoNode.type = currentLfo.waveform || "sine";
                lfoNode.frequency.setValueAtTime(currentLfo.rate || 1.0, audioContext.currentTime);
                lfoNode.start();
                
                const lfoGainNode = sample.lfoGainNodes[lfoIndex] = audioContext.createGain();
                lfoNode.connect(lfoGainNode);
                
                // Connect to target
                connectLFOToTarget(sample, lfoIndex, currentLfo, lfoNode, lfoGainNode, sampleNumber);
            }
            // If LFO should not be active but is, disconnect it
            else if (!shouldBeActive && isCurrentlyActive) {
                console.log(`[LFO] Automation deactivated LFO ${lfoIndex + 1} for sample ${sampleNumber}`);
                disconnectSingleLFO(sample, lfoIndex);
            }
            // If LFO is active, update its parameters
            else if (shouldBeActive && isCurrentlyActive) {
                const lfoNode = sample.lfoNodes[lfoIndex];
                const lfoGainNode = sample.lfoGainNodes[lfoIndex];
                
                // Update oscillator frequency if rate changed
                if (lfoNode && lfoNode.frequency) {
                    const currentRate = currentLfo.rate || 1.0;
                    lfoNode.frequency.setValueAtTime(currentRate, audioContext.currentTime);
                }
                
                // Update gain depth for non-pitch targets
                if (lfoGainNode && lfoGainNode.gain && currentLfo.target !== "pitch") {
                    const currentDepth = currentLfo.depth / 100;
                    updateLFOGainForTarget(sample, lfoIndex, currentLfo.target, currentDepth, lfoGainNode);
                }
            }
            
            // Schedule next update
            sample.lfoUpdateTimeouts[lfoIndex] = setTimeout(updateLFOParameters, 50);
        };
        
        // Start the update loop
        sample.lfoUpdateTimeouts[lfoIndex] = setTimeout(updateLFOParameters, 50);
    }
    
    // Helper function to update LFO gain based on target type
    function updateLFOGainForTarget(sample, lfoIndex, target, depth, lfoGainNode) {
        if (target === "volume" && sample.individualVolumeGain) {
            const baseGain = sample.individualVolumeGain.gain.value;
            const maxModulation = baseGain * 0.5;
            const modulationAmount = maxModulation * depth;
            lfoGainNode.gain.setValueAtTime(modulationAmount, audioContext.currentTime);
        } else if (target === "filter" && sample.lfoFilter) {
            const baseFrequency = sample.lfoFilter.frequency.value;
            const maxOctaves = 2;
            const modulationOctaves = maxOctaves * depth;
            const minFrequency = baseFrequency / Math.pow(2, modulationOctaves);
            const maxFrequency = baseFrequency * Math.pow(2, modulationOctaves);
            const scaleFactor = (maxFrequency - minFrequency) / 2;
            lfoGainNode.gain.setValueAtTime(scaleFactor, audioContext.currentTime);
        } else if (target === "delay-time" && sample.delayNode) {
            // Use a fixed maximum modulation range even when delay time is 0
            // This allows LFO to modulate from 0 to a reasonable value
            const maxModulation = 0.5; // Up to 500ms modulation
            const modulationAmount = maxModulation * depth;
            lfoGainNode.gain.setValueAtTime(modulationAmount, audioContext.currentTime);
        } else if (target === "delay-feedback" && sample.delayFeedbackNode) {
            const maxModulation = 0.3;
            const modulationAmount = maxModulation * depth;
            lfoGainNode.gain.setValueAtTime(modulationAmount, audioContext.currentTime);
        } else if (target === "pan" && sample.pannerNode) {
            lfoGainNode.gain.setValueAtTime(depth, audioContext.currentTime);
        } else if (target.startsWith("eq-")) {
            const maxModulation = 12;
            const modulationAmount = maxModulation * depth;
            lfoGainNode.gain.setValueAtTime(modulationAmount, audioContext.currentTime);
        }
    }
    
    // Disconnect a single LFO
    function disconnectSingleLFO(sample, lfoIndex) {
        if (sample.lfoGainNodes && sample.lfoGainNodes[lfoIndex]) {
            try {
                sample.lfoGainNodes[lfoIndex].disconnect();
            } catch (e) {}
        }
        
        if (sample.lfoFilterOffsetNodes && sample.lfoFilterOffsetNodes[lfoIndex]) {
            try {
                sample.lfoFilterOffsetNodes[lfoIndex].disconnect();
                sample.lfoFilterOffsetNodes[lfoIndex].stop();
                sample.lfoFilterOffsetNodes[lfoIndex] = null;
            } catch (e) {}
        }
        
        if (sample.lfoUpdateTimeouts && sample.lfoUpdateTimeouts[lfoIndex]) {
            clearTimeout(sample.lfoUpdateTimeouts[lfoIndex]);
            sample.lfoUpdateTimeouts[lfoIndex] = null;
        }
        
        // Clear pitch modulation interval if it exists
        if (sample.lfoPitchIntervals && sample.lfoPitchIntervals[lfoIndex]) {
            clearInterval(sample.lfoPitchIntervals[lfoIndex]);
            sample.lfoPitchIntervals[lfoIndex] = null;
            
            // CRITICAL FIX: Reset playback rate to base rate if this was a pitch LFO
            if (sample.lfoTargets && sample.lfoTargets[lfoIndex] === "pitch") {
                if (sample.source && sample.source.playbackRate) {
                    // Get the current base pitch rate (without LFO modulation)
                    const baseRate = sample.basePitchRate || 1;
                    try {
                        sample.source.playbackRate.setValueAtTime(baseRate, audioContext.currentTime);
                        console.log(`✅ [LFO] Reset pitch for LFO ${lfoIndex + 1} to base rate:`, baseRate);
                    } catch (e) {
                        console.warn('Failed to reset pitch rate:', e);
                    }
                }
            }
        }
        
        if (sample.lfoTargets) {
            sample.lfoTargets[lfoIndex] = "none";
        }
    }
    
    // Connect an LFO to its target
    function connectLFOToTarget(sample, lfoIndex, lfo, lfoNode, lfoGainNode, sampleNumber) {
        const target = lfo.target;
        const depth = lfo.depth / 100;
        
        sample.lfoTargets[lfoIndex] = target;
        
        // Similar connection logic as the original single LFO, but for each individual LFO
        
        if (target === "pitch") {
            // Pitch modulation requires a polled approach
            // Store the base playback rate from the actual source
            if (!sample.basePitchRate && sample.source) {
                sample.basePitchRate = sample.source.playbackRate.value;
            }
            
            // Clear any existing pitch update interval for this LFO
            if (sample.lfoPitchIntervals && sample.lfoPitchIntervals[lfoIndex]) {
                clearInterval(sample.lfoPitchIntervals[lfoIndex]);
            }
            
            // Create intervals array if it doesn't exist
            if (!sample.lfoPitchIntervals) {
                sample.lfoPitchIntervals = [null, null, null, null];
            }
            
            // Set up polling interval to update pitch
            const updateRate = 50; // Update every 50ms
            sample.lfoPitchIntervals[lfoIndex] = setInterval(() => {
                if (sample.source && sample.source.playbackRate) {
                    // Get current LFO settings (may have been changed by automation)
                    const currentLfo = sample.effects?.lfos?.[lfoIndex];
                    if (!currentLfo) return;
                    
                    const currentRate = currentLfo.rate || 1.0;
                    const currentDepth = (currentLfo.depth || 0) / 100;
                    const currentWaveform = currentLfo.waveform || "sine";
                    
                    const time = audioContext.currentTime;
                    const phase = (time * currentRate * Math.PI * 2) % (Math.PI * 2);
                    let modulation = 0;
                    
                    switch (currentWaveform) {
                        case "sine":
                            modulation = Math.sin(phase);
                            break;
                        case "square":
                            modulation = Math.sin(phase) > 0 ? 1 : -1;
                            break;
                        case "triangle":
                            const t = (phase / Math.PI) % 2;
                            modulation = t < 1 ? 2 * t - 1 : 3 - 2 * t;
                            break;
                        case "sawtooth":
                            modulation = 2 * ((phase / Math.PI) % 1) - 1;
                            break;
                    }
                    
                    // Apply pitch modulation (±1 octave max based on depth)
                    const maxSemitones = 12; // 1 octave
                    const semitones = modulation * maxSemitones * currentDepth;
                    const pitchMultiplier = Math.pow(2, semitones / 12);
                    
                    // Get the current base rate (which includes tempo/speed changes)
                    const baseRate = sample.basePitchRate || 1;
                    const newRate = baseRate * pitchMultiplier;
                    
                    try {
                        sample.source.playbackRate.setValueAtTime(newRate, time);
                    } catch (e) {
                        // Source might have been stopped, clear the interval
                        if (sample.lfoPitchIntervals && sample.lfoPitchIntervals[lfoIndex]) {
                            clearInterval(sample.lfoPitchIntervals[lfoIndex]);
                            sample.lfoPitchIntervals[lfoIndex] = null;
                        }
                    }
                }
            }, updateRate);
        } else if (target === "volume" && sample.individualVolumeGain) {
            const baseGain = sample.individualVolumeGain.gain.value;
            const maxModulation = baseGain * 0.5;
            const modulationAmount = maxModulation * depth;
            lfoGainNode.gain.value = modulationAmount;
            lfoGainNode.connect(sample.individualVolumeGain.gain);
        } else if (target === "filter" && sample.lfoFilter) {
            const baseFrequency = sample.lfoFilter.frequency.value;
            const maxOctaves = 2;
            const modulationOctaves = maxOctaves * depth;
            const minFrequency = baseFrequency / Math.pow(2, modulationOctaves);
            const maxFrequency = baseFrequency * Math.pow(2, modulationOctaves);
            const scaleFactor = (maxFrequency - minFrequency) / 2;
            const offset = (maxFrequency + minFrequency) / 2;
            
            lfoGainNode.gain.value = scaleFactor;
            lfoGainNode.connect(sample.lfoFilter.frequency);
            sample.lfoFilter.frequency.value = baseFrequency;
            
            const offsetNode = audioContext.createConstantSource();
            offsetNode.offset.value = offset;
            offsetNode.connect(sample.lfoFilter.frequency);
            offsetNode.start();
            sample.lfoFilterOffsetNodes[lfoIndex] = offsetNode;
        } else if (target === "delay-time" && sample.delayNode) {
            // Use a fixed maximum modulation range even when delay time is 0
            const maxModulation = 0.5; // Up to 500ms modulation
            const modulationAmount = maxModulation * depth;
            lfoGainNode.gain.value = modulationAmount;
            lfoGainNode.connect(sample.delayNode.delayTime);
        } else if (target === "delay-feedback" && sample.delayFeedbackNode) {
            const maxModulation = 0.3;
            const modulationAmount = maxModulation * depth;
            lfoGainNode.gain.value = modulationAmount;
            lfoGainNode.connect(sample.delayFeedbackNode.gain);
        } else if (target === "pan" && sample.pannerNode) {
            lfoGainNode.gain.value = depth;
            lfoGainNode.connect(sample.pannerNode.pan);
        } else if (target.startsWith("eq-")) {
            const maxModulation = 12;
            const modulationAmount = maxModulation * depth;
            lfoGainNode.gain.value = modulationAmount;
            
            if (target === "eq-low" && sample.eqLowNode) {
                lfoGainNode.connect(sample.eqLowNode.gain);
            } else if (target === "eq-lowmid" && sample.eqLowMidNode) {
                lfoGainNode.connect(sample.eqLowMidNode.gain);
            } else if (target === "eq-mid" && sample.eqMidNode) {
                lfoGainNode.connect(sample.eqMidNode.gain);
            } else if (target === "eq-highmid" && sample.eqHighMidNode) {
                lfoGainNode.connect(sample.eqHighMidNode.gain);
            } else if (target === "eq-high" && sample.eqHighNode) {
                lfoGainNode.connect(sample.eqHighNode.gain);
            }
        }
    }

    function setupLFOEventListeners(sampleNumber) {
        // Remove any existing event listeners to prevent duplicates
        const lfoTarget = document.getElementById("lfo-target");
        const lfoWaveform = document.getElementById("lfo-waveform");
        const lfoRate = document.getElementById("lfo-rate");
        const lfoDepth = document.getElementById("lfo-depth");
        
        // Create new event listeners with the sample number in scope
        const newLfoTarget = lfoTarget.cloneNode(true);
        const newLfoWaveform = lfoWaveform.cloneNode(true);
        const newLfoRate = lfoRate.cloneNode(true);
        const newLfoDepth = lfoDepth.cloneNode(true);
        
        lfoTarget.parentNode.replaceChild(newLfoTarget, lfoTarget);
        lfoWaveform.parentNode.replaceChild(newLfoWaveform, lfoWaveform);
        lfoRate.parentNode.replaceChild(newLfoRate, lfoRate);
        lfoDepth.parentNode.replaceChild(newLfoDepth, lfoDepth);
        
        newLfoTarget.addEventListener("change", function() {
            updateLFOInRealTime(sampleNumber);
        });
        
        newLfoWaveform.addEventListener("change", function() {
            updateLFOInRealTime(sampleNumber);
        });
        
        newLfoRate.addEventListener("input", function() {
            updateLFOInRealTime(sampleNumber);
        });
        
        newLfoDepth.addEventListener("input", function() {
            updateLFOInRealTime(sampleNumber);
        });
    }

    function initializeLFOConnection(sampleNumber) {
        if (!currentPlaying[sampleNumber] || !currentPlaying[sampleNumber].lfoNode) return;
        
        const sample = currentPlaying[sampleNumber];
        // FIX: Use the saved LFO target from the sample's effects, not the DOM value
        const target = sample.effects && sample.effects.lfo ? sample.effects.lfo.target : "pitch";
        
        // Disconnect all previous connections to ensure isolation
        try {
            sample.lfoGainNode.disconnect();
        } catch (e) {}
        
        // Disconnect filter offset node if it exists
        if (sample.lfoFilterOffsetNode) {
            try {
                sample.lfoFilterOffsetNode.disconnect();
                sample.lfoFilterOffsetNode.stop();
                sample.lfoFilterOffsetNode = null;
            } catch (e) {}
        }
        
        // Clear any existing update timeout
        if (sample.lfoUpdateTimeout) {
            clearTimeout(sample.lfoUpdateTimeout);
            sample.lfoUpdateTimeout = null;
        }
        
        // FIX: Handle LFO filter bypass based on target
        if (sample.lfoFilterBypass && sample.lfoFilter) {
            if (target === "filter") {
                // Use the LFO filter path
                sample.lfoFilterBypass.gain.value = 0.0;
                sample.lfoFilter.connect(sample.eqVeryHighNode);
            } else {
                // Use the bypass path
                sample.lfoFilterBypass.gain.value = 1.0;
                try {
                    sample.lfoFilter.disconnect();
                } catch (e) {}
            }
        }
        
        // Connect to the appropriate target
        if (target === "pitch") {
            // Check if detune is supported
            const supportsDetune = typeof sample.source.detune !== 'undefined';
            
            if (supportsDetune) {
                // For pitch modulation, we'll use the detune property
                // which changes pitch without affecting playback rate
                sample.lfoTarget = "pitch";
                
                // Create a loop to continuously update the detune
                const updateDetune = () => {
                    if (!sample.source || sample.lfoTarget !== "pitch") return;
                    
                    const time = audioContext.currentTime;
                    const lfoRate = sample.effects && sample.effects.lfo ? sample.effects.lfo.rate : 1.0;
                    const lfoDepth = sample.effects && sample.effects.lfo ? sample.effects.lfo.depth / 100 : 0;
                    const waveform = sample.effects && sample.effects.lfo ? sample.effects.lfo.waveform : "sine";
                    
                    const lfoDuration = 1 / lfoRate;
                    const phase = (time % lfoDuration) / lfoDuration * Math.PI * 2;
                    
                    let modulationValue = 0;
                    switch (waveform) {
                        case "sine":
                            modulationValue = Math.sin(phase);
                            break;
                        case "square":
                            modulationValue = Math.sin(phase) > 0 ? 1 : -1;
                            break;
                        case "triangle":
                            const t = (phase / Math.PI) % 2;
                            modulationValue = t < 1 ? 2 * t - 1 : 3 - 2 * t;
                            break;
                        case "sawtooth":
                            modulationValue = 2 * ((phase / Math.PI) % 1) - 1;
                            break;
                    }
                    
                    // Calculate the detune value in cents
                    // Maximum detune is 1200 cents (one octave) in either direction
                    const maxDetune = 1200;
                    const detuneValue = maxDetune * lfoDepth * modulationValue;
                    
                    // Apply the detune to the source
                    sample.source.detune.setValueAtTime(detuneValue, time);
                    
                    // Schedule the next update
                    sample.lfoUpdateTimeout = setTimeout(updateDetune, 50); // Update every 50ms for smooth modulation
                };
                
                // Start the update loop
                updateDetune();
            } else {
                // Fall back to the current implementation using playbackRate
                // For pitch modulation, we'll use a more direct approach
                // by updating the playback rate in a scheduled manner
                sample.lfoTarget = "pitch";
                
                // Store the current base playback rate
                if (sample.source) {
                    sample.lfoBaseRate = sample.source.playbackRate.value;
                }
                
                // Create a loop to continuously update the playback rate
                const updatePlaybackRate = () => {
                    if (!sample.source || sample.lfoTarget !== "pitch") return;
                    
                    const time = audioContext.currentTime;
                    const lfoRate = sample.effects && sample.effects.lfo ? sample.effects.lfo.rate : 1.0;
                    const lfoDepth = sample.effects && sample.effects.lfo ? sample.effects.lfo.depth / 100 : 0;
                    const waveform = sample.effects && sample.effects.lfo ? sample.effects.lfo.waveform : "sine";
                    
                    const lfoDuration = 1 / lfoRate;
                    const phase = (time % lfoDuration) / lfoDuration * Math.PI * 2;
                    
                    let modulationValue = 0;
                    switch (waveform) {
                        case "sine":
                            modulationValue = Math.sin(phase);
                            break;
                        case "square":
                            modulationValue = Math.sin(phase) > 0 ? 1 : -1;
                            break;
                        case "triangle":
                            const t = (phase / Math.PI) % 2;
                            modulationValue = t < 1 ? 2 * t - 1 : 3 - 2 * t;
                            break;
                        case "sawtooth":
                            modulationValue = 2 * ((phase / Math.PI) % 1) - 1;
                            break;
                    }
                    
                    // Use the stored base rate which should be updated when tempo changes
                    const baseRate = sample.lfoBaseRate || 1.0;
                    
                    // Limit the modulation depth to prevent extreme values
                    // Maximum modulation is 50% of the base rate in either direction
                    const maxModulation = baseRate * 0.5;
                    const modulationAmount = maxModulation * lfoDepth * modulationValue;
                    
                    // Ensure the playback rate never goes below 0.1 to prevent audio stopping
                    const newPlaybackRate = Math.max(0.1, baseRate + modulationAmount);
                    
                    sample.source.playbackRate.setValueAtTime(newPlaybackRate, time);
                    
                    // Schedule the next update
                    sample.lfoUpdateTimeout = setTimeout(updatePlaybackRate, 50); // Update every 50ms for smooth modulation
                };
                
                // Start the update loop
                updatePlaybackRate();
            }
        } else if (target === "filter") {
            // Connect to the dedicated LFO filter cutoff frequency
            const baseFrequency = sample.lfoFilter ? sample.lfoFilter.frequency.value : 2000;
            const lfoDepth = sample.effects && sample.effects.lfo ? sample.effects.lfo.depth / 100 : 0;
            
            // Calculate the modulation range in octaves
            // Maximum modulation is 2 octaves in either direction
            const maxOctaves = 2;
            const modulationOctaves = maxOctaves * lfoDepth;
            
            // Calculate the frequency range
            const minFrequency = baseFrequency / Math.pow(2, modulationOctaves);
            const maxFrequency = baseFrequency * Math.pow(2, modulationOctaves);
            
            // Create a scale factor to map the LFO output to the frequency range
            const scaleFactor = (maxFrequency - minFrequency) / 2;
            const offset = (maxFrequency + minFrequency) / 2;
            
            // Connect the LFO to the filter frequency
            sample.lfoGainNode.gain.value = scaleFactor;
            sample.lfoGainNode.connect(sample.lfoFilter.frequency);
            
            // Set the base frequency
            sample.lfoFilter.frequency.value = baseFrequency;
            
            // Create a constant source node to add the offset
            const offsetNode = audioContext.createConstantSource();
            offsetNode.offset.value = offset;
            offsetNode.connect(sample.lfoFilter.frequency);
            offsetNode.start();
            
            // Store the offset node for cleanup
            sample.lfoFilterOffsetNode = offsetNode;
            
            sample.lfoTarget = "filter";
        } else if (target === "volume") {
            // Connect to the individual volume gain node
            if (sample.individualVolumeGain) {
                const baseGain = sample.individualVolumeGain.gain.value;
                const lfoDepth = sample.effects && sample.effects.lfo ? sample.effects.lfo.depth / 100 : 0;
                
                // Calculate the modulation range
                // Maximum modulation is 50% of the base gain in either direction
                const maxModulation = baseGain * 0.5;
                const modulationAmount = maxModulation * lfoDepth;
                
                // Connect the LFO to the individual volume gain
                sample.lfoGainNode.gain.value = modulationAmount;
                sample.lfoGainNode.connect(sample.individualVolumeGain.gain);
                sample.lfoTarget = "volume";
            }
        } else if (target === "delay-time") {
            // Connect to delay time
            if (sample.delayNode) {
                const lfoDepth = sample.effects && sample.effects.lfo ? sample.effects.lfo.depth / 100 : 0;
                
                // Use a fixed maximum modulation range even when delay time is 0
                const maxModulation = 0.5; // Up to 500ms modulation
                const modulationAmount = maxModulation * lfoDepth;
                
                sample.lfoGainNode.gain.value = modulationAmount;
                sample.lfoGainNode.connect(sample.delayNode.delayTime);
                sample.lfoTarget = "delay-time";
            }
        } else if (target === "delay-feedback") {
            // Connect to delay feedback gain
            if (sample.delayFeedbackNode) {
                const baseFeedback = sample.delayFeedbackNode.gain.value;
                const lfoDepth = sample.effects && sample.effects.lfo ? sample.effects.lfo.depth / 100 : 0;
                
                // Calculate modulation range (up to ±30% to prevent runaway feedback)
                const maxModulation = 0.3;
                const modulationAmount = maxModulation * lfoDepth;
                
                sample.lfoGainNode.gain.value = modulationAmount;
                sample.lfoGainNode.connect(sample.delayFeedbackNode.gain);
                sample.lfoTarget = "delay-feedback";
            }
        } else if (target === "reverb-decay") {
            // For reverb decay, we need to use a polled approach since decay isn't a real-time parameter
            sample.lfoTarget = "reverb-decay";
            
            const updateReverbDecay = () => {
                if (sample.lfoTarget !== "reverb-decay") return;
                
                const time = audioContext.currentTime;
                const lfoRate = sample.effects && sample.effects.lfo ? sample.effects.lfo.rate : 1.0;
                const lfoDepth = sample.effects && sample.effects.lfo ? sample.effects.lfo.depth / 100 : 0;
                const waveform = sample.effects && sample.effects.lfo ? sample.effects.lfo.waveform : "sine";
                const baseDecay = sample.effects && sample.effects.reverb ? sample.effects.reverb.decay : 0;
                
                const lfoDuration = 1 / lfoRate;
                const phase = (time % lfoDuration) / lfoDuration * Math.PI * 2;
                
                let modulationValue = 0;
                switch (waveform) {
                    case "sine": modulationValue = Math.sin(phase); break;
                    case "square": modulationValue = Math.sin(phase) > 0 ? 1 : -1; break;
                    case "triangle":
                        const t = (phase / Math.PI) % 2;
                        modulationValue = t < 1 ? 2 * t - 1 : 3 - 2 * t;
                        break;
                    case "sawtooth": modulationValue = 2 * ((phase / Math.PI) % 1) - 1; break;
                }
                
                // Modulate decay (range 0-5 seconds)
                const maxModulation = 2.5; // ±2.5 seconds
                const newDecay = Math.max(0, Math.min(5, baseDecay + (maxModulation * lfoDepth * modulationValue)));
                
                // Update reverb if it exists
                if (sample.effects) {
                    sample.effects.reverb.decay = newDecay;
                    updateSampleEffects(sampleNumber);
                }
                
                sample.lfoUpdateTimeout = setTimeout(updateReverbDecay, 100);
            };
            
            updateReverbDecay();
        } else if (target === "reverb-mix") {
            // Connect to reverb wet gain
            if (sample.reverbWetGain) {
                const baseWet = sample.reverbWetGain.gain.value;
                const lfoDepth = sample.effects && sample.effects.lfo ? sample.effects.lfo.depth / 100 : 0;
                
                // Calculate modulation range (up to ±30% of wet signal)
                const maxModulation = 0.3;
                const modulationAmount = maxModulation * lfoDepth;
                
                sample.lfoGainNode.gain.value = modulationAmount;
                sample.lfoGainNode.connect(sample.reverbWetGain.gain);
                sample.lfoTarget = "reverb-mix";
            }
        } else if (target === "eq-low") {
            // Connect to low shelf EQ
            if (sample.eqLowNode) {
                const baseGain = sample.eqLowNode.gain.value;
                const lfoDepth = sample.effects && sample.effects.lfo ? sample.effects.lfo.depth / 100 : 0;
                
                // Calculate modulation range (±12dB)
                const maxModulation = 12;
                const modulationAmount = maxModulation * lfoDepth;
                
                sample.lfoGainNode.gain.value = modulationAmount;
                sample.lfoGainNode.connect(sample.eqLowNode.gain);
                sample.lfoTarget = "eq-low";
            }
        } else if (target === "eq-lowmid") {
            // Connect to low-mid EQ
            if (sample.eqLowMidNode) {
                const baseGain = sample.eqLowMidNode.gain.value;
                const lfoDepth = sample.effects && sample.effects.lfo ? sample.effects.lfo.depth / 100 : 0;
                
                // Calculate modulation range (±12dB)
                const maxModulation = 12;
                const modulationAmount = maxModulation * lfoDepth;
                
                sample.lfoGainNode.gain.value = modulationAmount;
                sample.lfoGainNode.connect(sample.eqLowMidNode.gain);
                sample.lfoTarget = "eq-lowmid";
            }
        } else if (target === "eq-mid") {
            // Connect to mid EQ
            if (sample.eqMidNode) {
                const baseGain = sample.eqMidNode.gain.value;
                const lfoDepth = sample.effects && sample.effects.lfo ? sample.effects.lfo.depth / 100 : 0;
                
                // Calculate modulation range (±12dB)
                const maxModulation = 12;
                const modulationAmount = maxModulation * lfoDepth;
                
                sample.lfoGainNode.gain.value = modulationAmount;
                sample.lfoGainNode.connect(sample.eqMidNode.gain);
                sample.lfoTarget = "eq-mid";
            }
        } else if (target === "eq-highmid") {
            // Connect to high-mid EQ
            if (sample.eqHighMidNode) {
                const baseGain = sample.eqHighMidNode.gain.value;
                const lfoDepth = sample.effects && sample.effects.lfo ? sample.effects.lfo.depth / 100 : 0;
                
                // Calculate modulation range (±12dB)
                const maxModulation = 12;
                const modulationAmount = maxModulation * lfoDepth;
                
                sample.lfoGainNode.gain.value = modulationAmount;
                sample.lfoGainNode.connect(sample.eqHighMidNode.gain);
                sample.lfoTarget = "eq-highmid";
            }
        } else if (target === "eq-high") {
            // Connect to high shelf EQ
            if (sample.eqHighNode) {
                const baseGain = sample.eqHighNode.gain.value;
                const lfoDepth = sample.effects && sample.effects.lfo ? sample.effects.lfo.depth / 100 : 0;
                
                // Calculate modulation range (±12dB)
                const maxModulation = 12;
                const modulationAmount = maxModulation * lfoDepth;
                
                sample.lfoGainNode.gain.value = modulationAmount;
                sample.lfoGainNode.connect(sample.eqHighNode.gain);
                sample.lfoTarget = "eq-high";
            }
        } else if (target === "pan") {
            // Connect to stereo panner
            if (sample.pannerNode) {
                const lfoDepth = sample.effects && sample.effects.lfo ? sample.effects.lfo.depth / 100 : 0;
                
                // Pan ranges from -1 (left) to 1 (right)
                // LFO output is -1 to 1, so we just scale by depth
                sample.lfoGainNode.gain.value = lfoDepth;
                sample.lfoGainNode.connect(sample.pannerNode.pan);
                sample.lfoTarget = "pan";
            }
        }
    }

    function formatFrequency(freq) {
        if (freq >= 1e3) {
            return `${(freq/1e3).toFixed(1)}kHz`;
        }
        return `${freq}Hz`;
    }

    function initPianoRollFilters() {
        if (!currentSampleForPopup) return;
        const lowShelfSlider = document.getElementById("piano-roll-lowshelf");
        const lowMidSlider = document.getElementById("piano-roll-lowmid");
        const midSlider = document.getElementById("piano-roll-mid");
        const highMidSlider = document.getElementById("piano-roll-highmid");
        const highShelfSlider = document.getElementById("piano-roll-highshelf");
        const delayTimeSlider = document.getElementById("piano-roll-delay-time");
        const delayFeedbackSlider = document.getElementById("piano-roll-delay-feedback");
        const lowShelfValue = document.getElementById("piano-roll-lowshelf-value");
        const lowMidValue = document.getElementById("piano-roll-lowmid-value");
        const midValue = document.getElementById("piano-roll-mid-value");
        const highMidValue = document.getElementById("piano-roll-highmid-value");
        const highShelfValue = document.getElementById("piano-roll-highshelf-value");
        const delayTimeValue = document.getElementById("piano-roll-delay-time-value");
        const delayFeedbackValue = document.getElementById("piano-roll-delay-feedback-value");
        lowShelfSlider.addEventListener("input", function () {
            lowShelfValue.textContent = `${this.value}dB`;
            updatePianoRollFilters();
        });
        lowMidSlider.addEventListener("input", function () {
            lowMidValue.textContent = `${this.value}dB`;
            updatePianoRollFilters();
        });
        midSlider.addEventListener("input", function () {
            midValue.textContent = `${this.value}dB`;
            updatePianoRollFilters();
        });
        highMidSlider.addEventListener("input", function () {
            highMidValue.textContent = `${this.value}dB`;
            updatePianoRollFilters();
        });
        highShelfSlider.addEventListener("input", function () {
            highShelfValue.textContent = `${this.value}dB`;
            updatePianoRollFilters();
        });
        delayTimeSlider.addEventListener("input", function () {
            delayTimeValue.textContent = `${this.value}ms`;
            updatePianoRollFilters();
        });
        delayFeedbackSlider.addEventListener("input", function () {
            delayFeedbackValue.textContent = `${this.value}%`;
            updatePianoRollFilters();
        });
    }

    function updatePianoRollFilters() {
        if (!currentSampleForPopup || !pianoRollFilterNodes.lowShelf) return;
        const lowShelf = parseFloat(document.getElementById("piano-roll-lowshelf").value);
        const lowMid = parseFloat(document.getElementById("piano-roll-lowmid").value);
        const mid = parseFloat(document.getElementById("piano-roll-mid").value);
        const highMid = parseFloat(document.getElementById("piano-roll-highmid").value);
        const highShelf = parseFloat(document.getElementById("piano-roll-highshelf").value);
        const delayTime = parseInt(document.getElementById("piano-roll-delay-time").value);
        const delayFeedback = parseInt(document.getElementById("piano-roll-delay-feedback").value);
        if (pianoRollFilterNodes.lowShelf) {
            pianoRollFilterNodes.lowShelf.gain.value = lowShelf;
        }
        if (pianoRollFilterNodes.lowMid) {
            pianoRollFilterNodes.lowMid.gain.value = lowMid;
        }
        if (pianoRollFilterNodes.mid) {
            pianoRollFilterNodes.mid.gain.value = mid;
        }
        if (pianoRollFilterNodes.highMid) {
            pianoRollFilterNodes.highMid.gain.value = highMid;
        }
        if (pianoRollFilterNodes.highShelf) {
            pianoRollFilterNodes.highShelf.gain.value = highShelf;
        }
        if (pianoRollFilterNodes.delay) {
            pianoRollFilterNodes.delay.delayTime.value = delayTime / 1e3;
        }
        if (pianoRollFilterNodes.delayFeedback) {
            pianoRollFilterNodes.delayFeedback.gain.value = delayFeedback / 100;
        }
        if (pianoRollData[currentSampleForPopup]) {
            if (!pianoRollData[currentSampleForPopup].filters) {
                pianoRollData[currentSampleForPopup].filters = {};
            }
            pianoRollData[currentSampleForPopup].filters.lowShelf = lowShelf;
            pianoRollData[currentSampleForPopup].filters.lowMid = lowMid;
            pianoRollData[currentSampleForPopup].filters.mid = mid;
            pianoRollData[currentSampleForPopup].filters.highMid = highMid;
            pianoRollData[currentSampleForPopup].filters.highShelf = highShelf;
            pianoRollData[currentSampleForPopup].filters.delay = {
                time: delayTime,
                feedback: delayFeedback
            };
        }
    }

    // Modified updateLFOInRealTime to accept a sampleNumber parameter
    function updateLFOInRealTime(sampleNumber) {
        if (!sampleNumber) sampleNumber = currentSampleForPopup;
        if (!sampleNumber || !currentPlaying[sampleNumber]) return;
        
        const sample = currentPlaying[sampleNumber];
        const target = document.getElementById("lfo-target").value;
        const waveform = document.getElementById("lfo-waveform").value;
        const rate = parseFloat(document.getElementById("lfo-rate").value);
        const depth = parseInt(document.getElementById("lfo-depth").value);
        
        document.getElementById("lfo-rate-value").textContent = rate.toFixed(1);
        document.getElementById("lfo-depth-value").textContent = `${depth}%`;
        
        if (temporaryEffects && sampleNumber === currentSampleForPopup) {
            if (!temporaryEffects.lfo) temporaryEffects.lfo = {};
            temporaryEffects.lfo.target = target;
            temporaryEffects.lfo.waveform = waveform;
            temporaryEffects.lfo.rate = rate;
            temporaryEffects.lfo.depth = depth;
        }
        
        // Update the sample's effects directly
        if (!sample.effects) sample.effects = {};
        if (!sample.effects.lfo) sample.effects.lfo = {};
        sample.effects.lfo.target = target;
        sample.effects.lfo.waveform = waveform;
        sample.effects.lfo.rate = rate;
        sample.effects.lfo.depth = depth;
        
        // Update the LFO if it's already connected
        if (sample.lfoNode) {
            // Update LFO parameters directly without recreating the node
            sample.lfoNode.type = waveform;
            sample.lfoNode.frequency.setValueAtTime(rate, audioContext.currentTime);
            sample.lfoGainNode.gain.setValueAtTime(depth / 100, audioContext.currentTime);
            
            // Clear any existing update timeout
            if (sample.lfoUpdateTimeout) {
                clearTimeout(sample.lfoUpdateTimeout);
                sample.lfoUpdateTimeout = null;
            }
            
            // Disconnect all previous connections
            try {
                sample.lfoGainNode.disconnect();
            } catch (e) {}
            
            // Disconnect filter offset node if it exists
            if (sample.lfoFilterOffsetNode) {
                try {
                    sample.lfoFilterOffsetNode.disconnect();
                    sample.lfoFilterOffsetNode.stop();
                    sample.lfoFilterOffsetNode = null;
                } catch (e) {}
            }
            
            // FIX: Handle LFO filter bypass based on target
            if (sample.lfoFilterBypass && sample.lfoFilter) {
                if (target === "filter") {
                    // Use the LFO filter path
                    sample.lfoFilterBypass.gain.value = 0.0;
                    sample.lfoFilter.connect(sample.eqVeryHighNode);
                } else {
                    // Use the bypass path
                    sample.lfoFilterBypass.gain.value = 1.0;
                    try {
                        sample.lfoFilter.disconnect();
                    } catch (e) {}
                }
            }
            
            // Reconnect to the appropriate target
            initializeLFOConnection(sampleNumber);
        }
        
        // Update LFO visualizer
        drawLFOWaveform();
    }
    function initLFOVisualizer() {
        const lfoCanvas = document.getElementById("lfo-wave");
        if (!lfoCanvas) return;
        
        const ctx = lfoCanvas.getContext("2d");
        const container = lfoCanvas.parentElement;
        lfoCanvas.width = container.clientWidth;
        lfoCanvas.height = container.clientHeight;
        
        drawLFOWaveform_OLD_UNUSED();
    }

    // ===== AUTOMATION FUNCTIONS =====
    
    // Automation Tab Switching
    function setupAutomationTabs() {
        const tabs = document.querySelectorAll('.automation-tab');
        const panels = document.querySelectorAll('.automation-panel');
        
        console.log('setupAutomationTabs: Found', tabs.length, 'tabs and', panels.length, 'panels');
        
        // Clone all tabs to remove old event listeners
        tabs.forEach(tab => {
            const newTab = tab.cloneNode(true);
            tab.parentNode.replaceChild(newTab, tab);
        });
        
        // Re-query after cloning
        const newTabs = document.querySelectorAll('.automation-tab');
        
        newTabs.forEach(tab => {
            tab.addEventListener('click', function() {
                const autoNum = this.getAttribute('data-automation');
                console.log('Automation tab clicked:', autoNum);
                
                // Remove active class from all tabs and panels
                newTabs.forEach(t => t.classList.remove('active'));
                panels.forEach(p => p.classList.remove('active'));
                
                // Add active class to clicked tab and corresponding panel
                this.classList.add('active');
                document.getElementById(`automation-panel-${autoNum}`).classList.add('active');
                
                // Reinitialize the canvas when panel becomes visible
                setTimeout(() => {
                    initSingleAutomationVisualizer(parseInt(autoNum));
                }, 10);
            });
        });
    }
    
    // Setup event listeners for all 4 automations
    function setupAllAutomationEventListeners(sampleNumber) {
        for (let i = 1; i <= 4; i++) {
            setupSingleAutomationEventListeners(sampleNumber, i);
        }
    }
    
    // Setup event listeners for a single automation
    function setupSingleAutomationEventListeners(sampleNumber, autoNum) {
        const autoIndex = autoNum - 1;
        
        const target = document.getElementById(`automation-${autoNum}-target`);
        const start = document.getElementById(`automation-${autoNum}-start`);
        const end = document.getElementById(`automation-${autoNum}-end`);
        const duration = document.getElementById(`automation-${autoNum}-duration`);
        const curve = document.getElementById(`automation-${autoNum}-curve`);
        
        const startValue = document.getElementById(`automation-${autoNum}-start-value`);
        const endValue = document.getElementById(`automation-${autoNum}-end-value`);
        const durationValue = document.getElementById(`automation-${autoNum}-duration-value`);
        
        if (!target || !start || !end || !duration || !curve) {
            console.error(`Automation ${autoNum} elements not found`);
            return;
        }
        
        // Initialize automation data structure if it doesn't exist
        if (!temporaryEffects.automations || !Array.isArray(temporaryEffects.automations)) {
            temporaryEffects.automations = [
                { target: "none", start: 50, end: 50, duration: 4, curve: "linear" },
                { target: "none", start: 50, end: 50, duration: 4, curve: "linear" },
                { target: "none", start: 50, end: 50, duration: 4, curve: "linear" },
                { target: "none", start: 50, end: 50, duration: 4, curve: "linear" }
            ];
        }
        
        // Load existing values
        const auto = temporaryEffects.automations[autoIndex];
        target.value = auto.target || "none";
        start.value = auto.start !== undefined ? auto.start : 50;
        end.value = auto.end !== undefined ? auto.end : 50;
        duration.value = auto.duration !== undefined ? auto.duration : 1;
        curve.value = auto.curve || "linear";
        
        startValue.textContent = start.value;
        endValue.textContent = end.value;
        durationValue.textContent = duration.value;
        
        // Target change
        target.addEventListener('change', function() {
            temporaryEffects.automations[autoIndex].target = this.value;
            console.log(`Automation ${autoNum} target:`, this.value);
            drawAutomationCurve(autoNum);
        });
        
        // Start value change
        start.addEventListener('input', function() {
            temporaryEffects.automations[autoIndex].start = parseInt(this.value);
            startValue.textContent = this.value;
            
            // Update first point if points array exists
            if (temporaryEffects.automations[autoIndex].points && temporaryEffects.automations[autoIndex].points.length > 0) {
                temporaryEffects.automations[autoIndex].points[0].value = parseInt(this.value);
            }
            
            drawAutomationCurve(autoNum);
        });
        
        // End value change
        end.addEventListener('input', function() {
            temporaryEffects.automations[autoIndex].end = parseInt(this.value);
            endValue.textContent = this.value;
            
            // Update last point if points array exists
            if (temporaryEffects.automations[autoIndex].points && temporaryEffects.automations[autoIndex].points.length > 0) {
                const lastIndex = temporaryEffects.automations[autoIndex].points.length - 1;
                temporaryEffects.automations[autoIndex].points[lastIndex].value = parseInt(this.value);
            }
            
            drawAutomationCurve(autoNum);
        });
        
        // Duration change
        duration.addEventListener('input', function() {
            temporaryEffects.automations[autoIndex].duration = parseInt(this.value);
            durationValue.textContent = this.value;
            drawAutomationCurve(autoNum);
        });
        
        // Curve change
        curve.addEventListener('change', function() {
            temporaryEffects.automations[autoIndex].curve = this.value;
            console.log(`Automation ${autoNum} curve:`, this.value);
            drawAutomationCurve(autoNum);
        });
        
        // Bars input change
        const barsInput = document.getElementById(`automation-${autoNum}-bars`);
        if (barsInput) {
            barsInput.value = auto.bars || "*";
            
            barsInput.addEventListener('input', function() {
                temporaryEffects.automations[autoIndex].bars = this.value.trim();
                console.log(`Automation ${autoNum} bars:`, this.value);
            });
        }
        
        // Loop checkbox change
        const loopCheckbox = document.getElementById(`automation-${autoNum}-loop`);
        if (loopCheckbox) {
            loopCheckbox.checked = auto.loop !== undefined ? auto.loop : true;
            
            loopCheckbox.addEventListener('change', function() {
                temporaryEffects.automations[autoIndex].loop = this.checked;
                console.log(`Automation ${autoNum} loop:`, this.checked);
            });
        }
        
        // Initial draw
        setTimeout(() => {
            drawAutomationCurve(autoNum);
        }, 100);
    }
    
    // Initialize all automation visualizers
    function initAllAutomationVisualizers() {
        for (let i = 1; i <= 4; i++) {
            initSingleAutomationVisualizer(i);
        }
    }
    
    // Initialize a single automation visualizer
    function initSingleAutomationVisualizer(autoNum) {
        const canvas = document.getElementById(`automation-${autoNum}-canvas`);
        if (!canvas) {
            console.error(`Automation ${autoNum} canvas not found`);
            return;
        }
        
        // Set canvas size to match its display size
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
        
        console.log(`Automation ${autoNum} canvas initialized:`, canvas.width, 'x', canvas.height);
        
        // Add mouse interaction for dragging the curve
        setupAutomationCanvasInteraction(autoNum, canvas);
        
        // Draw the automation curve
        drawAutomationCurve(autoNum);
    }
    
    // Setup mouse interaction for automation canvas
    function setupAutomationCanvasInteraction(autoNum, canvas) {
        let isDragging = false;
        let draggedPointIndex = null;
        let selectedPointIndex = null;
        
        canvas.addEventListener('mousedown', function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const autoIndex = autoNum - 1;
            if (!temporaryEffects.automations || !temporaryEffects.automations[autoIndex]) return;
            
            const auto = temporaryEffects.automations[autoIndex];
            
            // Initialize points array if it doesn't exist
            if (!auto.points) {
                auto.points = [
                    { time: 0, value: auto.start || 50 },
                    { time: 1, value: auto.end || 50 }
                ];
            }
            
            // Check if clicking near an existing point
            let clickedPoint = -1;
            for (let i = 0; i < auto.points.length; i++) {
                const point = auto.points[i];
                const pointX = point.time * canvas.width;
                const pointY = canvas.height - (point.value / 100 * canvas.height);
                
                if (Math.abs(x - pointX) < 10 && Math.abs(y - pointY) < 10) {
                    clickedPoint = i;
                    break;
                }
            }
            
            if (clickedPoint !== -1) {
                // Right click or Ctrl+click to delete point (except first and last)
                if (e.button === 2 || e.ctrlKey) {
                    if (clickedPoint !== 0 && clickedPoint !== auto.points.length - 1) {
                        auto.points.splice(clickedPoint, 1);
                        drawAutomationCurve(autoNum);
                        updateAutomationStartEndFromPoints(autoNum);
                    }
                    e.preventDefault();
                    return;
                }
                
                // Start dragging existing point
                isDragging = true;
                draggedPointIndex = clickedPoint;
                selectedPointIndex = clickedPoint;
            } else {
                // Add new point at clicked position
                const time = x / canvas.width;
                const value = ((canvas.height - y) / canvas.height) * 100;
                
                // Find where to insert the new point to keep time order
                let insertIndex = auto.points.findIndex(p => p.time > time);
                if (insertIndex === -1) insertIndex = auto.points.length;
                
                auto.points.splice(insertIndex, 0, { time: time, value: value });
                
                // Start dragging the new point
                isDragging = true;
                draggedPointIndex = insertIndex;
                selectedPointIndex = insertIndex;
                
                drawAutomationCurve(autoNum);
                updateAutomationStartEndFromPoints(autoNum);
            }
        });
        
        // Prevent context menu on right-click
        canvas.addEventListener('contextmenu', function(e) {
            e.preventDefault();
        });
        
        canvas.addEventListener('mousemove', function(e) {
            if (!isDragging || draggedPointIndex === null) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const autoIndex = autoNum - 1;
            const auto = temporaryEffects.automations[autoIndex];
            
            // Calculate new value
            let value = ((canvas.height - y) / canvas.height) * 100;
            value = Math.max(0, Math.min(100, value));
            
            // Calculate new time position
            let time = x / canvas.width;
            time = Math.max(0, Math.min(1, time));
            
            // Don't allow moving first or last point horizontally (keep them at 0 and 1)
            if (draggedPointIndex === 0) {
                time = 0;
            } else if (draggedPointIndex === auto.points.length - 1) {
                time = 1;
            } else {
                // Constrain time to be between neighbors
                const prevTime = auto.points[draggedPointIndex - 1].time;
                const nextTime = auto.points[draggedPointIndex + 1].time;
                time = Math.max(prevTime + 0.01, Math.min(nextTime - 0.01, time));
            }
            
            // Update point
            auto.points[draggedPointIndex].time = time;
            auto.points[draggedPointIndex].value = value;
            
            // Redraw
            drawAutomationCurve(autoNum);
            updateAutomationStartEndFromPoints(autoNum);
        });
        
        canvas.addEventListener('mouseup', function() {
            isDragging = false;
            draggedPointIndex = null;
        });
        
        canvas.addEventListener('mouseleave', function() {
            isDragging = false;
            draggedPointIndex = null;
        });
        
        // Change cursor on hover
        canvas.addEventListener('mousemove', function(e) {
            if (isDragging) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const autoIndex = autoNum - 1;
            if (!temporaryEffects.automations || !temporaryEffects.automations[autoIndex]) return;
            
            const auto = temporaryEffects.automations[autoIndex];
            if (!auto.points) return;
            
            // Check if hovering near any point
            let nearPoint = false;
            for (let i = 0; i < auto.points.length; i++) {
                const point = auto.points[i];
                const pointX = point.time * canvas.width;
                const pointY = canvas.height - (point.value / 100 * canvas.height);
                
                if (Math.abs(x - pointX) < 10 && Math.abs(y - pointY) < 10) {
                    nearPoint = true;
                    break;
                }
            }
            
            if (nearPoint) {
                canvas.style.cursor = 'pointer';
            } else {
                canvas.style.cursor = 'crosshair';
            }
        });
    }
    
    // Helper function to update start/end sliders from points array
    function updateAutomationStartEndFromPoints(autoNum) {
        const autoIndex = autoNum - 1;
        if (!temporaryEffects.automations || !temporaryEffects.automations[autoIndex]) return;
        
        const auto = temporaryEffects.automations[autoIndex];
        if (!auto.points || auto.points.length < 2) return;
        
        // Update start value (first point)
        const startValue = Math.round(auto.points[0].value);
        auto.start = startValue;
        document.getElementById(`automation-${autoNum}-start`).value = startValue;
        document.getElementById(`automation-${autoNum}-start-value`).textContent = startValue;
        
        // Update end value (last point)
        const endValue = Math.round(auto.points[auto.points.length - 1].value);
        auto.end = endValue;
        document.getElementById(`automation-${autoNum}-end`).value = endValue;
        document.getElementById(`automation-${autoNum}-end-value`).textContent = endValue;
    }
    
    // Draw automation curve
    function drawAutomationCurve(autoNum) {
        const canvas = document.getElementById(`automation-${autoNum}-canvas`);
        if (!canvas) return;
        
        const ctx = canvas.getContext("2d");
        const width = canvas.width;
        const height = canvas.height;
        
        // Clear canvas
        ctx.fillStyle = "#111";
        ctx.fillRect(0, 0, width, height);
        
        // Get automation settings
        const autoIndex = autoNum - 1;
        if (!temporaryEffects.automations || !temporaryEffects.automations[autoIndex]) return;
        
        const auto = temporaryEffects.automations[autoIndex];
        const startVal = auto.start || 50;
        const endVal = auto.end || 50;
        const curve = auto.curve || "linear";
        const duration = auto.duration || 1; // Duration is now in bars
        
        // Initialize points array if it doesn't exist (backwards compatibility)
        if (!auto.points) {
            auto.points = [
                { time: 0, value: startVal },
                { time: 1, value: endVal }
            ];
        }
        
        // Draw sample waveform in background if available (convert bars to beats for waveform)
        if (currentSampleForPopup && currentPlaying[currentSampleForPopup] && currentPlaying[currentSampleForPopup].buffer) {
            drawSampleWaveformInAutomation(ctx, width, height, currentSampleForPopup, duration * 4);
        }
        
        // Draw beat markers based on automation duration (convert bars to beats)
        drawBeatMarkersInAutomation(ctx, width, height, duration * 4);
        
        // Draw grid lines
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 1;
        
        // Horizontal lines (25%, 50%, 75%)
        for (let i = 1; i <= 3; i++) {
            const y = height * (i / 4);
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();
        }
        
        // Different color for each automation lane
        const autoColors = {
            1: "#9C27B0",  // Purple
            2: "#E91E63",  // Pink
            3: "#673AB7",  // Deep Purple
            4: "#3F51B5"   // Indigo
        };
        
        // Draw automation curve using points
        if (auto.points && auto.points.length >= 2) {
            ctx.strokeStyle = autoColors[autoNum] || "#9C27B0";
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            // Sort points by time
            const sortedPoints = [...auto.points].sort((a, b) => a.time - b.time);
            
            // Draw lines between points
            for (let i = 0; i < sortedPoints.length; i++) {
                const point = sortedPoints[i];
                const x = point.time * width;
                const y = height - (point.value / 100 * height);
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.stroke();
            
            // Draw points as circles
            ctx.fillStyle = autoColors[autoNum] || "#9C27B0";
            for (let i = 0; i < sortedPoints.length; i++) {
                const point = sortedPoints[i];
                const x = point.time * width;
                const y = height - (point.value / 100 * height);
                
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw white outline for better visibility
                ctx.strokeStyle = "#fff";
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.strokeStyle = autoColors[autoNum] || "#9C27B0";
                ctx.lineWidth = 3;
            }
            
            // Draw labels for start and end points only
            ctx.fillStyle = "#fff";
            ctx.font = "10px Arial";
            
            const startPoint = sortedPoints[0];
            const startX = startPoint.time * width;
            const startY = height - (startPoint.value / 100 * height);
            ctx.fillText("Start", startX + 10, startY - 10);
            
            const endPoint = sortedPoints[sortedPoints.length - 1];
            const endX = endPoint.time * width;
            const endY = height - (endPoint.value / 100 * height);
            ctx.fillText("End", endX - 40, endY - 10);
        }
        
        // Draw duration label (now showing bars)
        ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
        ctx.font = "11px Arial";
        const barLabel = duration === 1 ? `${duration} bar` : `${duration} bars`;
        ctx.fillText(barLabel, width / 2 - 25, height - 5);
    }
    
    // Draw sample waveform in automation canvas background
    function drawSampleWaveformInAutomation(ctx, width, height, sampleNumber, automationDuration) {
        const sample = currentPlaying[sampleNumber];
        if (!sample || !sample.buffer) return;
        
        const buffer = sample.buffer;
        const channelData = buffer.getChannelData(0); // Use first channel
        const sampleRate = buffer.sampleRate;
        const bufferDuration = buffer.duration;
        
        // Calculate how many times the sample loops within the automation duration
        const beatDuration = 60 / tempo;
        const automationDurationSeconds = beatDuration * automationDuration;
        const loops = automationDurationSeconds / bufferDuration;
        
        ctx.strokeStyle = "rgba(100, 100, 100, 0.3)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        
        const step = Math.floor(channelData.length / width);
        const centerY = height / 2;
        const waveformHeight = height * 0.3; // Use 30% of canvas height for waveform
        
        // Draw the waveform, repeating if it loops
        for (let x = 0; x < width; x++) {
            // Calculate position in the looped sample
            const timePosition = (x / width) * automationDurationSeconds;
            const samplePosition = (timePosition % bufferDuration) / bufferDuration;
            const dataIndex = Math.floor(samplePosition * channelData.length);
            
            const sample = channelData[dataIndex] || 0;
            const y = centerY + (sample * waveformHeight);
            
            if (x === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        
        ctx.stroke();
        
        // Draw loop markers if sample loops
        if (loops > 1) {
            ctx.strokeStyle = "rgba(255, 255, 255, 0.15)";
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            
            const loopCount = Math.floor(loops);
            for (let i = 1; i < loopCount; i++) {
                const loopX = (i / loops) * width;
                ctx.beginPath();
                ctx.moveTo(loopX, 0);
                ctx.lineTo(loopX, height);
                ctx.stroke();
            }
            
            ctx.setLineDash([]);
        }
    }
    
    // Draw beat markers in automation canvas
    function drawBeatMarkersInAutomation(ctx, width, height, duration) {
        ctx.strokeStyle = "rgba(255, 255, 255, 0.2)";
        ctx.lineWidth = 1;
        ctx.setLineDash([2, 2]);
        
        // Draw a marker for each beat
        for (let beat = 1; beat < duration; beat++) {
            const x = (beat / duration) * width;
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
            ctx.stroke();
            
            // Draw beat number
            ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
            ctx.font = "9px Arial";
            ctx.fillText(`${beat}`, x + 2, 12);
        }
        
        ctx.setLineDash([]);
    }
    
    // ===== AUTOMATION PLAYBACK FUNCTIONS =====
    
    // Initialize all automations for a sample
    function initializeAllAutomations(sampleNumber, startTime) {
        const sample = currentPlaying[sampleNumber];
        if (!sample || !sample.effects || !sample.effects.automations) return;
        
        // Store automation intervals array if it doesn't exist
        if (!sample.automationIntervals) {
            sample.automationIntervals = [null, null, null, null];
        }
        
        // Clear any existing automation intervals
        sample.automationIntervals.forEach(interval => {
            if (interval) clearInterval(interval);
        });
        sample.automationIntervals = [null, null, null, null];
        
        // Initialize each automation
        for (let i = 0; i < 4; i++) {
            const auto = sample.effects.automations[i];
            if (auto && auto.target && auto.target !== "none") {
                initializeSingleAutomation(sampleNumber, i, startTime);
            }
        }
    }
    
    // Helper function to check if automation should be active for current bar
    function isAutomationActiveForBar(barPattern, currentBar) {
        if (!barPattern || barPattern.trim() === '' || barPattern === '*') {
            return true; // Always active
        }
        
        const patterns = barPattern.split(',').map(p => p.trim());
        
        for (const pattern of patterns) {
            if (pattern.includes('-')) {
                // Range pattern (e.g., "1-4")
                const [start, end] = pattern.split('-').map(n => parseInt(n.trim()));
                if (currentBar >= start && currentBar <= end) {
                    return true;
                }
            } else {
                // Single bar pattern (e.g., "1", "5")
                const bar = parseInt(pattern);
                if (currentBar === bar) {
                    return true;
                }
            }
        }
        
        return false;
    }

    // Initialize a single automation
    function initializeSingleAutomation(sampleNumber, autoIndex, startTime) {
        const sample = currentPlaying[sampleNumber];
        if (!sample) return;
        
        const auto = sample.effects.automations[autoIndex];
        if (!auto || auto.target === "none") return;
        
        console.log(`Initializing automation ${autoIndex + 1} for sample ${sampleNumber}:`, auto);
        
        const now = audioContext.currentTime;
        const relativeStartTime = Math.max(0, startTime - now);
        
        // Calculate duration in seconds based on tempo
        // Duration is now in BARS (4 beats per bar)
        const beatDuration = 60 / tempo;
        const automationDurationInBeats = auto.duration * 4; // Convert bars to beats
        const automationDuration = beatDuration * automationDurationInBeats;
        
        // Update automation value over time
        const updateInterval = 50; // Update every 50ms for smooth automation
        const updateFrequency = 1000 / updateInterval;
        
        let elapsedTime = 0;
        let hasCompletedOnce = false; // Track if non-looping automation completed
        
        const automationInterval = setInterval(() => {
            if (!currentPlaying[sampleNumber] || !currentPlaying[sampleNumber].isScheduled) {
                clearInterval(automationInterval);
                return;
            }
            
            // Check if automation should be active for current bar
            const barPattern = auto.bars || "*";
            if (!isAutomationActiveForBar(barPattern, currentBar)) {
                return; // Skip this update if not in active bar
            }
            
            elapsedTime += updateInterval / 1000;
            
            // Check if loop is enabled (default true for backward compatibility)
            const shouldLoop = auto.loop !== undefined ? auto.loop : true;
            
            let progress;
            if (shouldLoop) {
                // Loop the automation
                const loopedTime = elapsedTime % automationDuration;
                progress = loopedTime / automationDuration; // 0 to 1
                hasCompletedOnce = false;
            } else {
                // Don't loop - clamp to end value after duration
                const rawProgress = elapsedTime / automationDuration;
                if (rawProgress >= 1.0) {
                    progress = 1.0; // Stay at end value
                    if (!hasCompletedOnce) {
                        hasCompletedOnce = true;
                        console.log(`Automation ${autoIndex + 1} completed, staying at end value`);
                    }
                } else {
                    progress = rawProgress;
                }
            }
            
            // Calculate value from points array (linear interpolation between points)
            let value;
            if (auto.points && auto.points.length >= 2) {
                const sortedPoints = [...auto.points].sort((a, b) => a.time - b.time);
                
                // Find the two points to interpolate between
                let pointA = sortedPoints[0];
                let pointB = sortedPoints[sortedPoints.length - 1];
                
                for (let i = 0; i < sortedPoints.length - 1; i++) {
                    if (progress >= sortedPoints[i].time && progress <= sortedPoints[i + 1].time) {
                        pointA = sortedPoints[i];
                        pointB = sortedPoints[i + 1];
                        break;
                    }
                }
                
                // Linear interpolation between the two points
                const segmentProgress = (progress - pointA.time) / (pointB.time - pointA.time);
                value = pointA.value + (pointB.value - pointA.value) * segmentProgress;
            } else {
                // Fallback to old curve-based system
                let normalizedValue;
                switch (auto.curve) {
                    case "exponential":
                        normalizedValue = Math.pow(progress, 2);
                        break;
                    case "logarithmic":
                        normalizedValue = Math.sqrt(progress);
                        break;
                    case "linear":
                    default:
                        normalizedValue = progress;
                        break;
                }
                value = auto.start + (auto.end - auto.start) * normalizedValue;
            }
            
            // Apply automation to the target parameter
            applyAutomationValue(sampleNumber, auto.target, value);
            
        }, updateInterval);
        
        // Store the interval so we can clear it later
        sample.automationIntervals[autoIndex] = automationInterval;
    }
    
    // Apply automation value to a specific parameter
    function applyAutomationValue(sampleNumber, target, value) {
        const sample = currentPlaying[sampleNumber];
        if (!sample) return;
        
        // Convert 0-100 value to appropriate range for each parameter
        switch (target) {
            case "volume":
                if (sample.gainNode) {
                    // Value 0-100 maps to 0-2 (200% max)
                    const volumeMultiplier = (value / 100) * 2;
                    const groupVolume = getGroupVolumeForSample(sampleNumber);
                    const individualVolume = sample.individualVolume || 1;
                    sample.gainNode.gain.setValueAtTime(
                        volumeMultiplier * groupVolume * individualVolume,
                        audioContext.currentTime
                    );
                }
                break;
                
            case "pitch":
            case "speed":
                if (sample.source && sample.source.playbackRate) {
                    // Value 0-100 maps to 0.5-2.0 (half speed to double speed)
                    const rate = 0.5 + (value / 100) * 1.5;
                    sample.source.playbackRate.setValueAtTime(rate, audioContext.currentTime);
                }
                break;
                
            case "filter":
                // Create filter node if it doesn't exist
                if (!sample.filterNode) {
                    sample.filterNode = audioContext.createBiquadFilter();
                    sample.filterNode.type = 'lowpass';
                    sample.filterNode.Q.value = 1;
                    // Insert filter into audio chain
                    if (sample.individualVolumeGain && sample.dryPathNode) {
                        sample.individualVolumeGain.disconnect();
                        sample.individualVolumeGain.connect(sample.filterNode);
                        sample.filterNode.connect(sample.dryPathNode);
                        sample.filterNode.connect(sample.wetPathNode);
                    }
                }
                if (sample.filterNode) {
                    // Value 0-100 maps to 20Hz - 20000Hz (logarithmic)
                    const frequency = 20 * Math.pow(1000, value / 100);
                    sample.filterNode.frequency.setValueAtTime(frequency, audioContext.currentTime);
                }
                break;
                
            case "delay-time":
                if (sample.delayNode) {
                    // Value 0-100 maps to 0-1 second
                    const delayTime = value / 100;
                    sample.delayNode.delayTime.setValueAtTime(delayTime, audioContext.currentTime);
                }
                break;
                
            case "delay-feedback":
                if (sample.delayFeedbackNode) {
                    // Value 0-100 maps to 0-0.9 (avoid feedback explosion)
                    const feedback = (value / 100) * 0.9;
                    sample.delayFeedbackNode.gain.setValueAtTime(feedback, audioContext.currentTime);
                }
                break;
                
            case "reverb-mix":
                if (sample.wetPathNode && sample.dryPathNode) {
                    // Value 0-100 maps to wet/dry mix
                    const wetGain = value / 100;
                    const dryGain = 1 - wetGain;
                    sample.wetPathNode.gain.setValueAtTime(wetGain, audioContext.currentTime);
                    sample.dryPathNode.gain.setValueAtTime(dryGain, audioContext.currentTime);
                }
                break;
                
            case "reverb-time":
                // Reverb time is harder to modulate in real-time with convolver
                // Would need to switch impulse responses, which is expensive
                // For now, we can modulate the wet/dry mix instead
                break;
                
            case "eq-low":
                if (sample.eqLowNode) {
                    // Value 0-100 maps to -24dB to +24dB
                    const gain = -24 + (value / 100) * 48;
                    sample.eqLowNode.gain.setValueAtTime(gain, audioContext.currentTime);
                }
                break;
                
            case "eq-lowmid":
                if (sample.eqLowMidNode) {
                    const gain = -24 + (value / 100) * 48;
                    sample.eqLowMidNode.gain.setValueAtTime(gain, audioContext.currentTime);
                }
                break;
                
            case "eq-mid":
                if (sample.eqMidNode) {
                    const gain = -24 + (value / 100) * 48;
                    sample.eqMidNode.gain.setValueAtTime(gain, audioContext.currentTime);
                }
                break;
                
            case "eq-highmid":
                if (sample.eqHighMidNode) {
                    const gain = -24 + (value / 100) * 48;
                    sample.eqHighMidNode.gain.setValueAtTime(gain, audioContext.currentTime);
                }
                break;
                
            case "eq-high":
                if (sample.eqHighNode) {
                    const gain = -24 + (value / 100) * 48;
                    sample.eqHighNode.gain.setValueAtTime(gain, audioContext.currentTime);
                }
                break;
                
            case "pan":
                // Create panner node if it doesn't exist
                if (!sample.panNode) {
                    sample.panNode = audioContext.createStereoPanner();
                    sample.panNode.pan.value = 0;
                    // Insert panner before the output
                    if (sample.outputNode) {
                        sample.outputNode.disconnect();
                        sample.outputNode.connect(sample.panNode);
                        sample.panNode.connect(masterOutputNode);
                    }
                }
                if (sample.panNode) {
                    // Value 0-100 maps to -1 (left) to +1 (right)
                    const panValue = -1 + (value / 100) * 2;
                    sample.panNode.pan.setValueAtTime(panValue, audioContext.currentTime);
                }
                break;
                
            // LFO Targets
            case "lfo-1-depth":
                if (sample.effects && sample.effects.lfos && sample.effects.lfos[0]) {
                    sample.effects.lfos[0].depth = value;
                }
                break;
                
            case "lfo-1-rate":
                if (sample.effects && sample.effects.lfos && sample.effects.lfos[0]) {
                    // Value 0-100 maps to 0.1-20 Hz
                    const rate = 0.1 + (value / 100) * 19.9;
                    sample.effects.lfos[0].rate = rate;
                }
                break;
                
            case "lfo-2-depth":
                if (sample.effects && sample.effects.lfos && sample.effects.lfos[1]) {
                    sample.effects.lfos[1].depth = value;
                }
                break;
                
            case "lfo-2-rate":
                if (sample.effects && sample.effects.lfos && sample.effects.lfos[1]) {
                    const rate = 0.1 + (value / 100) * 19.9;
                    sample.effects.lfos[1].rate = rate;
                }
                break;
                
            case "lfo-3-depth":
                if (sample.effects && sample.effects.lfos && sample.effects.lfos[2]) {
                    sample.effects.lfos[2].depth = value;
                }
                break;
                
            case "lfo-3-rate":
                if (sample.effects && sample.effects.lfos && sample.effects.lfos[2]) {
                    const rate = 0.1 + (value / 100) * 19.9;
                    sample.effects.lfos[2].rate = rate;
                }
                break;
                
            case "lfo-4-depth":
                if (sample.effects && sample.effects.lfos && sample.effects.lfos[3]) {
                    sample.effects.lfos[3].depth = value;
                }
                break;
                
            case "lfo-4-rate":
                if (sample.effects && sample.effects.lfos && sample.effects.lfos[3]) {
                    const rate = 0.1 + (value / 100) * 19.9;
                    sample.effects.lfos[3].rate = rate;
                }
                break;
        }
    }

    function drawLFOWaveform_OLD_UNUSED() {
        // This is the old single-LFO function - kept for reference but not used
        // New multi-LFO function is drawLFOWaveform(lfoNum) defined above
        const lfoCanvas = document.getElementById("lfo-wave");
        if (!lfoCanvas) return;
        
        const ctx = lfoCanvas.getContext("2d");
        const width = lfoCanvas.width;
        const height = lfoCanvas.height;
        
        // Clear canvas
        ctx.fillStyle = "#111";
        ctx.fillRect(0, 0, width, height);
        
        // Get current LFO settings
        const waveform = document.getElementById("lfo-waveform").value;
        const rate = parseFloat(document.getElementById("lfo-rate").value);
        const depth = parseInt(document.getElementById("lfo-depth").value);
        
        // Draw grid
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, height / 2);
        ctx.lineTo(width, height / 2);
        ctx.stroke();
        
        // Draw waveform
        ctx.strokeStyle = "#4CAF50";
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        const samples = width;
        const period = samples / (rate * 10); // Scale for visualization
        const amplitude = (height / 2) * (depth / 100);
        
        for (let x = 0; x < samples; x++) {
            let y;
            const phase = (x % period) / period * Math.PI * 2;
            
            switch (waveform) {
                case "sine":
                    y = height / 2 - Math.sin(phase) * amplitude;
                    break;
                case "square":
                    y = height / 2 - (Math.sin(phase) > 0 ? 1 : -1) * amplitude;
                    break;
                case "triangle":
                    const t = (phase / Math.PI) % 2;
                    y = height / 2 - (t < 1 ? 2 * t - 1 : 3 - 2 * t) * amplitude;
                    break;
                case "sawtooth":
                    y = height / 2 - (2 * ((phase / Math.PI) % 1) - 1) * amplitude;
                    break;
                default:
                    y = height / 2;
            }
            
            if (x === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        
        ctx.stroke();
    }

    function handleMicrophoneRecording(sampleNumber) {
        const microphoneRecordBtn = document.getElementById("microphone-record-btn");
        const microphoneSaveBtn = document.getElementById("microphone-save-btn");
        const microphoneDownloadBtn = document.getElementById("microphone-download-btn");
        const microphoneDeleteBtn = document.getElementById("microphone-delete-btn");
        const recordStatus = document.getElementById("record-status");
        if (!isMicrophoneRecording) {
            navigator.mediaDevices.getUserMedia({
                audio: true
            }).then(stream => {
                microphoneMediaStream = stream;
                microphoneMediaRecorder = new MediaRecorder(stream);
                microphoneRecordedChunks = [];
                microphoneMediaRecorder.ondataavailable = function (event) {
                    if (event.data.size > 0) {
                        microphoneRecordedChunks.push(event.data);
                    }
                };
                microphoneMediaRecorder.onstop = function () {
                    const blob = new Blob(microphoneRecordedChunks, {
                        type: "audio/wav"
                    });
                    recordedBlobs[sampleNumber] = blob;
                    microphoneSaveBtn.style.display = "inline-block";
                    microphoneDownloadBtn.style.display = "inline-block";
                    microphoneDeleteBtn.style.display = "inline-block";
                    recordStatusPerSample[sampleNumber] = "Recording complete!";
                    recordStatus.textContent = recordStatusPerSample[sampleNumber];
                    recordStatus.style.color = "#7a7a7aff";
                };
                microphoneMediaRecorder.start();
                isMicrophoneRecording = true;
                microphoneRecordBtn.textContent = "Stop Recording";
                microphoneRecordBtn.classList.add("recording");
                recordStatusPerSample[sampleNumber] = "Recording...";
                recordStatus.textContent = recordStatusPerSample[sampleNumber];
                recordStatus.style.color = "#FF9800";
            })["catch"](error => {
                console.error("Error accessing microphone:", error);
                recordStatusPerSample[sampleNumber] = "Error: Could not access microphone";
                recordStatus.textContent = recordStatusPerSample[sampleNumber];
                recordStatus.style.color = "#F44336";
            });
        } else {
            if (microphoneMediaRecorder && microphoneMediaRecorder.state !== "inactive") {
                microphoneMediaRecorder.stop();
            }
            if (microphoneMediaStream) {
                microphoneMediaStream.getTracks().forEach(track => track.stop());
                microphoneMediaStream = null;
            }
            isMicrophoneRecording = false;
            microphoneRecordBtn.textContent = "Record New";
            microphoneRecordBtn.classList.remove("recording");
        }
    }

    function saveMicrophoneRecording(sampleNumber) {
        const blob = recordedBlobs[sampleNumber];
        if (!blob) return;
        const recordStatus = document.getElementById("record-status");
        const microphoneSaveBtn = document.getElementById("microphone-save-btn");
        const fileReader = new FileReader;
        fileReader.onload = function () {
            audioContext.decodeAudioData(fileReader.result).then(buffer => {
                currentPlaying[sampleNumber].buffer = buffer;
                currentPlaying[sampleNumber].loopDuration = buffer.duration;
                currentPlaying[sampleNumber].bufferSampleNumber = sampleNumber;
                currentPlaying[sampleNumber].isCustomSample = true;
                const button = currentPlaying[sampleNumber].button;
                if (button) {
                    addCustomIndicator(button);
                    button.classList.remove("no-sample");
                }
                if (currentPlaying[sampleNumber].isScheduled && currentPlaying[sampleNumber].isActive) {
                    stopSample(sampleNumber);
                    currentPlaying[sampleNumber].scheduledForNextBar = true;
                    scheduleSampleForNextBar(sampleNumber);
                }
                recordStatusPerSample[sampleNumber] = "Recording saved successfully!";
                recordStatus.textContent = recordStatusPerSample[sampleNumber];
                recordStatus.style.color = "#4CAF50";
            })["catch"](error => {
                console.error("Error decoding audio data:", error);
                recordStatusPerSample[sampleNumber] = "Error: Invalid audio data";
                recordStatus.textContent = recordStatusPerSample[sampleNumber];
                recordStatus.style.color = "#F44336";
            });
        };
        fileReader.readAsArrayBuffer(blob);
    }

    function addCustomIndicator(button) {
        let customIndicator = button.querySelector(".custom-indicator");
        if (!customIndicator) {
            customIndicator = document.createElement("div");
            customIndicator.className = "custom-indicator";
            button.appendChild(customIndicator);
        }
        customIndicator.style.display = "block";
    }

    function downloadMicrophoneRecording(sampleNumber) {
        const blob = recordedBlobs[sampleNumber];
        if (!blob) return;
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `psychological-studio-recording-sample-${sampleNumber}-${(new Date).toISOString().slice(0,19).replace(/:/g,"-")}.wav`;
        a.click();
        URL.revokeObjectURL(url);
    }

    function deleteMicrophoneRecording(sampleNumber) {
        delete recordedBlobs[sampleNumber];
        if (currentPlaying[sampleNumber] && currentPlaying[sampleNumber].isCustomSample) {
            currentPlaying[sampleNumber].isCustomSample = false;
            currentPlaying[sampleNumber].buffer = null;
            currentPlaying[sampleNumber].bufferSampleNumber = null;
            const button = currentPlaying[sampleNumber].button;
            if (button) {
                const customIndicator = button.querySelector(".custom-indicator");
                if (customIndicator) {
                    customIndicator.style.display = "none";
                }
                if (button.classList.contains("active")) {
                    button.classList.add("no-sample");
                }
            }
            if (currentPlaying[sampleNumber].isScheduled) {
                stopSample(sampleNumber);
            }
        }
        const microphoneRecordBtn = document.getElementById("microphone-record-btn");
        const microphoneSaveBtn = document.getElementById("microphone-save-btn");
        const microphoneDownloadBtn = document.getElementById("microphone-download-btn");
        const microphoneDeleteBtn = document.getElementById("microphone-delete-btn");
        const recordStatus = document.getElementById("record-status");
        microphoneSaveBtn.style.display = "none";
        microphoneDownloadBtn.style.display = "none";
        microphoneDeleteBtn.style.display = "none";
        microphoneRecordBtn.textContent = "Start Recording";
        recordStatusPerSample[sampleNumber] = "";
        recordStatus.textContent = "";
    }

    function hideEffectsPopup() {
        if (isPreviewingPianoRoll) {
            stopPianoRollPreview();
        }
        stopWaveformAnimation();
        if (waveformAnalyzer && currentSampleForPopup) {
            const sample = currentPlaying[currentSampleForPopup];
            if (sample.eqVeryHighNode) {
                sample.eqVeryHighNode.disconnect();
                sample.eqVeryHighNode.connect(masterOutputNode);
            } else if (sample.outputNode) {
                sample.outputNode.disconnect();
                sample.outputNode.connect(masterOutputNode);
            } else if (sample.gainNode) {
                sample.gainNode.disconnect();
                sample.gainNode.connect(masterOutputNode);
            }
            waveformAnalyzer = null;
        }
        if (isMicrophoneRecording) {
            if (microphoneMediaRecorder && microphoneMediaRecorder.state !== "inactive") {
                microphoneMediaRecorder.stop();
            }
            if (microphoneMediaStream) {
                microphoneMediaStream.getTracks().forEach(track => track.stop());
                microphoneMediaStream = null;
            }
            isMicrophoneRecording = false;
        }
        effectsPopup.style.display = "none";
        currentSampleForPopup = null;
        originalEffects = null;
        temporaryEffects = null;
    }

    function resetEffectsSettings() {
        if (!currentSampleForPopup) return;
        temporaryEffects = {
            delay: {
                time: 0,
                feedback: 0
            },
            reverb: {
                decay: 0,
                mix: 0,
                predelay: 0,
                diffusion: 50,
                lowcut: 20,
                highcut: 2e4,
                damping: 50
            },
            eq: [{
                frequency: 20,
                gain: 0,
                q: 1,
                type: "lowshelf",
                fixed: true
            }, {
                frequency: 2e4,
                gain: 0,
                q: 1,
                type: "highshelf",
                fixed: true
            }],
            volume: 100,
            speed: 1,
            individualTempo: 1,
            lfos: [
                { target: "none", waveform: "sine", rate: 1.0, depth: 0 },
                { target: "none", waveform: "sine", rate: 1.0, depth: 0 },
                { target: "none", waveform: "sine", rate: 1.0, depth: 0 },
                { target: "none", waveform: "sine", rate: 1.0, depth: 0 }
            ],
            pianoRoll: {
                notes: [],
                soundSource: "sounddesign",
                gridWidth: currentSampleForPopup > 60 ? 32 : 16,
                gridHeight: 84,
                scrollX: 0,
                scrollY: 0,
                sampleRange: {
                    start: 0,
                    end: 100
                },
                filters: {
                    lowShelf: 0,
                    highShelf: 0,
                    lowMid: 0,
                    mid: 0,
                    highMid: 0,
                    delay: {
                        time: 0,
                        feedback: 0
                    }
                },
                isEnabled: false
            }
        };
        document.getElementById("sample-volume").value = temporaryEffects.volume;
        document.getElementById("sample-volume-value").textContent = `${temporaryEffects.volume}%`;
        document.getElementById("delay-time").value = temporaryEffects.delay.time;
        document.getElementById("delay-time-value").textContent = temporaryEffects.delay.time;
        document.getElementById("delay-feedback").value = temporaryEffects.delay.feedback;
        document.getElementById("delay-feedback-value").textContent = temporaryEffects.delay.feedback;
        document.getElementById("reverb-decay").value = temporaryEffects.reverb.decay;
        document.getElementById("reverb-decay-value").textContent = temporaryEffects.reverb.decay;
        document.getElementById("reverb-predelay").value = temporaryEffects.reverb.predelay;
        document.getElementById("reverb-predelay-value").textContent = temporaryEffects.reverb.predelay;
        document.getElementById("reverb-diffusion").value = temporaryEffects.reverb.diffusion;
        document.getElementById("reverb-diffusion-value").textContent = temporaryEffects.reverb.diffusion;
        document.getElementById("reverb-lowcut").value = temporaryEffects.reverb.lowcut;
        document.getElementById("reverb-lowcut-value").textContent = temporaryEffects.reverb.lowcut;
        document.getElementById("reverb-highcut").value = temporaryEffects.reverb.highcut;
        document.getElementById("reverb-highcut-value").textContent = temporaryEffects.reverb.highcut;
        document.getElementById("reverb-damping").value = temporaryEffects.reverb.damping;
        document.getElementById("reverb-damping-value").textContent = temporaryEffects.reverb.damping;
        document.getElementById("reverb-mix").value = temporaryEffects.reverb.mix;
        document.getElementById("reverb-mix-value").textContent = temporaryEffects.reverb.mix;
        document.getElementById("speed-select").value = temporaryEffects.speed;
        const individualTempoSection = document.querySelector(".individual-tempo-section");
        if (individualTempoSection && individualTempoSection.style.display !== "none") {
            document.getElementById("individual-tempo").value = temporaryEffects.individualTempo;
            document.getElementById("individual-tempo-value").textContent = temporaryEffects.individualTempo;
        }
        
        // Reset LFO values for all 4 LFOs
        for (let i = 1; i <= 4; i++) {
            document.getElementById(`lfo-${i}-target`).value = "none";
            document.getElementById(`lfo-${i}-waveform`).value = "sine";
            document.getElementById(`lfo-${i}-rate`).value = 1.0;
            document.getElementById(`lfo-${i}-rate-value`).textContent = "1.0";
            document.getElementById(`lfo-${i}-depth`).value = 0;
            document.getElementById(`lfo-${i}-depth-value`).textContent = "0%";
            drawLFOWaveform(i);
        }
        
        const pianoRollToggle = document.getElementById("piano-roll-toggle");
        const pianoRollContent = document.querySelector(".piano-roll-content");
        if (pianoRollToggle) {
            pianoRollToggle.checked = false;
        }
        if (pianoRollContent) {
            pianoRollContent.classList.remove("visible");
        }
        // Ensure SD controls hidden initially
        const sdControls = document.querySelector('.sound-design-controls');
        if (sdControls) sdControls.style.display = 'none';
        document.getElementById("piano-roll-lowshelf").value = temporaryEffects.pianoRoll.filters.lowShelf;
        document.getElementById("piano-roll-lowshelf-value").textContent = `${temporaryEffects.pianoRoll.filters.lowShelf}dB`;
        document.getElementById("piano-roll-lowmid").value = temporaryEffects.pianoRoll.filters.lowMid;
        document.getElementById("piano-roll-lowmid-value").textContent = `${temporaryEffects.pianoRoll.filters.lowMid}dB`;
        document.getElementById("piano-roll-mid").value = temporaryEffects.pianoRoll.filters.mid;
        document.getElementById("piano-roll-mid-value").textContent = `${temporaryEffects.pianoRoll.filters.mid}dB`;
        document.getElementById("piano-roll-highmid").value = temporaryEffects.pianoRoll.filters.highMid;
        document.getElementById("piano-roll-highmid-value").textContent = `${temporaryEffects.pianoRoll.filters.highMid}dB`;
        document.getElementById("piano-roll-highshelf").value = temporaryEffects.pianoRoll.filters.highShelf;
        document.getElementById("piano-roll-highshelf-value").textContent = `${temporaryEffects.pianoRoll.filters.highShelf}dB`;
        document.getElementById("piano-roll-delay-time").value = temporaryEffects.pianoRoll.filters.delay.time;
        document.getElementById("piano-roll-delay-time-value").textContent = `${temporaryEffects.pianoRoll.filters.delay.time}ms`;
        document.getElementById("piano-roll-delay-feedback").value = temporaryEffects.pianoRoll.filters.delay.feedback;
        document.getElementById("piano-roll-delay-feedback-value").textContent = `${temporaryEffects.pianoRoll.filters.delay.feedback}%`;
        if (currentSampleForPopup) {
            const sample = currentPlaying[currentSampleForPopup];
            if (sample.eqLowNode) sample.eqLowNode.gain.value = 0;
            if (sample.eqLowMidNode) sample.eqLowMidNode.gain.value = 0;
            if (sample.eqMidNode) sample.eqMidNode.gain.value = 0;
            if (sample.eqHighMidNode) sample.eqHighMidNode.gain.value = 0;
            if (sample.eqHighMid2Node) sample.eqHighMid2Node.gain.value = 0;
            if (sample.eqHighNode) sample.eqHighNode.gain.value = 0;
            if (sample.eqVeryHighNode) sample.eqVeryHighNode.gain.value = 0;
        }
        updateSampleVolumeInRealTime();
        updateDelayInRealTime();
        updateReverbInRealTime();
        updateSpeedInRealTime();
        updateIndividualTempoInRealTime();
        // Update all 4 LFOs
        for (let i = 1; i <= 4; i++) {
            updateSingleLFOInRealTime(currentSampleForPopup, i);
        }
        drawEQVisual();
        initPianoRoll();
    }
    async function applyEffectsSettings() {
        if (!currentSampleForPopup) return;
        const loadingIndicator = document.getElementById("piano-roll-loading");
        if (loadingIndicator) {
            loadingIndicator.style.display = "block";
        }
        
        // Save the EQ visualizer state
        const eqVisualizerToggle = document.getElementById("eq-visualizer-toggle");
        if (eqVisualizerToggle) {
            currentPlaying[currentSampleForPopup].eqVisualizerEnabled = eqVisualizerToggle.checked;
        }
        
        console.log('Saving LFO values for sample', currentSampleForPopup, ':', temporaryEffects.lfos);
        
        try {
            applyPianoRollSettings();
            if (pianoRollData[currentSampleForPopup] && pianoRollData[currentSampleForPopup].notes && pianoRollData[currentSampleForPopup].notes.length > 0) {
                await savePianoRollAsSampleForCurrentButton();
            }
            currentPlaying[currentSampleForPopup].effects = JSON.parse(JSON.stringify(temporaryEffects));
            console.log('Saved effects for sample', currentSampleForPopup, ':', currentPlaying[currentSampleForPopup].effects);
            
            // Restart automations if sample is currently playing
            if (currentPlaying[currentSampleForPopup].isScheduled && currentPlaying[currentSampleForPopup].source) {
                // Clear existing automation intervals
                if (currentPlaying[currentSampleForPopup].automationIntervals) {
                    currentPlaying[currentSampleForPopup].automationIntervals.forEach(interval => {
                        if (interval) clearInterval(interval);
                    });
                }
                // Restart automations with new settings
                initializeAllAutomations(currentSampleForPopup, audioContext.currentTime);
            }
            
            hideEffectsPopup();
        } catch (error) {
            console.error("Error applying effects settings:", error);
            if (loadingIndicator) {
                loadingIndicator.style.display = "none";
            }
            const uploadStatus = document.getElementById("upload-status");
            if (uploadStatus) {
                uploadStatus.textContent = "Error saving piano roll. Please try again.";
                uploadStatus.style.color = "#F44336";
            }
        }
    }

    function handleSampleUpload(event) {
        if (!currentSampleForPopup) return;
        const file = event.target.files[0];
        if (!file) return;
        if (!file.type.startsWith("audio/")) {
            uploadStatusPerSample[currentSampleForPopup] = "Error: Please select an audio file";
            const uploadStatus = document.getElementById("upload-status");
            uploadStatus.textContent = uploadStatusPerSample[currentSampleForPopup];
            uploadStatus.style.color = "#F44336";
            return;
        }
        const uploadStatus = document.getElementById("upload-status");
        uploadStatusPerSample[currentSampleForPopup] = "Uploading...";
        uploadStatus.textContent = uploadStatusPerSample[currentSampleForPopup];
        uploadStatus.style.color = "";
        const reader = new FileReader;
        reader.onload = function (e) {
            audioContext.decodeAudioData(e.target.result).then(buffer => {
                currentPlaying[currentSampleForPopup].buffer = buffer;
                currentPlaying[currentSampleForPopup].loopDuration = buffer.duration;
                currentPlaying[currentSampleForPopup].bufferSampleNumber = currentSampleForPopup;
                currentPlaying[currentSampleForPopup].isCustomSample = true;
                uploadedFileNames[currentSampleForPopup] = file.name;
                const button = currentPlaying[currentSampleForPopup].button;
                if (button) {
                    addCustomIndicator(button);
                    button.classList.remove("no-sample");
                }
                if (currentPlaying[currentSampleForPopup].isScheduled && currentPlaying[currentSampleForPopup].isActive) {
                    stopSample(currentSampleForPopup);
                    currentPlaying[currentSampleForPopup].scheduledForNextBar = true;
                    scheduleSampleForNextBar(currentSampleForPopup);
                }
                uploadStatusPerSample[currentSampleForPopup] = `Upload successful: ${file.name}`;
                uploadStatus.textContent = uploadStatusPerSample[currentSampleForPopup];
                uploadStatus.style.color = "#4CAF50";
            })["catch"](error => {
                console.error("Error decoding audio data:", error);
                uploadStatusPerSample[currentSampleForPopup] = "Error: Invalid audio file";
                uploadStatus.textContent = uploadStatusPerSample[currentSampleForPopup];
                uploadStatus.style.color = "#F44336";
            });
        };
        reader.onerror = function () {
            uploadStatusPerSample[currentSampleForPopup] = "Error reading file";
            uploadStatus.textContent = uploadStatusPerSample[currentSampleForPopup];
            uploadStatus.style.color = "#F44336";
        };
        reader.readAsArrayBuffer(file);
    }

    function updateSampleEffects(sampleNumber) {
        if (!currentPlaying[sampleNumber].isScheduled || !currentPlaying[sampleNumber].source) return;
        const effects = currentPlaying[sampleNumber].effects;
        const sample = currentPlaying[sampleNumber];
        if (!sample.outputNode) {
            initializeEffectsForSample(sampleNumber);
            return;
        }
        if (sample.gainNode && effects.volume !== undefined) {
            // Store the individual volume as a decimal (0-2)
            const individualVolume = effects.volume / 100;
            sample.individualVolume = individualVolume;
            
            // Update the actual gain by combining with group volume
            updateActualGain(sampleNumber);
        }
        if (sample.delayNode) {
            sample.delayNode.delayTime.value = effects.delay.time / 1e3;
            if (sample.delayFeedbackNode) {
                sample.delayFeedbackNode.gain.value = effects.delay.feedback / 100;
            }
        }
        if (sample.reverbMixNode) {
            sample.reverbMixNode.gain.value = effects.reverb.mix / 100;
        }
        if (effects.reverb.decay > 0) {
            const convolver = audioContext.createConvolver();
            const length = audioContext.sampleRate * effects.reverb.decay;
            const impulse = audioContext.createBuffer(2, length, audioContext.sampleRate);
            const predelaySamples = audioContext.sampleRate * (effects.reverb.predelay / 1e3);
            for (let channel = 0; channel < 2; channel++) {
                const channelData = impulse.getChannelData(channel);
                for (let i = 0; i < length; i++) {
                    if (i < predelaySamples) {
                        channelData[i] = 0;
                    } else {
                        const decayFactor = Math.pow(1 - (i - predelaySamples) / (length - predelaySamples), 2);
                        const diffusionFactor = effects.reverb.diffusion / 100;
                        channelData[i] = (Math.random() * 2 - 1) * decayFactor * diffusionFactor;
                        const dampingFactor = 1 - effects.reverb.damping / 100 * (i / length);
                        channelData[i] *= dampingFactor;
                    }
                }
            }
            convolver.buffer = impulse;
            if (sample.reverbNode) {
                sample.reverbNode.disconnect();
            }
            sample.reverbNode = convolver;
            if (sample.wetPathNode && sample.reverbMixNode) {
                sample.wetPathNode.connect(convolver);
                convolver.connect(sample.reverbMixNode);
                sample.reverbMixNode.connect(sample.outputNode);
            }
        } else {
            if (sample.reverbNode) {
                sample.reverbNode.disconnect();
                sample.reverbNode = null;
            }
        }
        if (sample.eqLowNode) {
            sample.eqLowNode.gain.value = 0;
            sample.eqLowMidNode.gain.value = 0;
            sample.eqMidNode.gain.value = 0;
            sample.eqHighMidNode.gain.value = 0;
            sample.eqHighMid2Node.gain.value = 0;
            sample.eqHighNode.gain.value = 0;
            sample.eqVeryHighNode.gain.value = 0;
            if (effects.eq && effects.eq.length > 0) {
                const sortedEqPoints = [...effects.eq].sort((a, b) => a.frequency - b.frequency);
                if (sortedEqPoints[0] && sortedEqPoints[0].type === "lowshelf") {
                    sample.eqLowNode.frequency.value = sortedEqPoints[0].frequency;
                    sample.eqLowNode.gain.value = sortedEqPoints[0].gain;
                }
                if (sortedEqPoints[sortedEqPoints.length - 1] && sortedEqPoints[sortedEqPoints.length - 1].type === "highshelf") {
                    sample.eqHighNode.frequency.value = sortedEqPoints[sortedEqPoints.length - 1].frequency;
                    sample.eqHighNode.gain.value = sortedEqPoints[sortedEqPoints.length - 1].gain;
                }
                let peakingIndex = 0;
                for (let i = 0; i < sortedEqPoints.length; i++) {
                    if (sortedEqPoints[i].type === "peaking") {
                        let filterNode;
                        switch (peakingIndex) {
                        case 0:
                            filterNode = sample.eqLowMidNode;
                            break;
                        case 1:
                            filterNode = sample.eqMidNode;
                            break;
                        case 2:
                            filterNode = sample.eqHighMidNode;
                            break;
                        case 3:
                            filterNode = sample.eqHighMid2Node;
                            break;
                        default:
                            break;
                        }
                        if (filterNode) {
                            filterNode.frequency.value = sortedEqPoints[i].frequency;
                            filterNode.gain.value = sortedEqPoints[i].gain;
                            filterNode.Q.value = sortedEqPoints[i].q || 1;
                            peakingIndex++;
                        }
                    }
                }
            }
        }
        let wetLevel = 0;
        if (effects.delay.time > 0) {
            wetLevel += .5;
        }
        if (effects.reverb.mix > 0) {
            wetLevel += effects.reverb.mix / 100;
        }
        wetLevel = Math.min(wetLevel, .8);
        if (sample.wetPathNode) {
            sample.wetPathNode.gain.value = wetLevel;
        }
        if (sample.dryPathNode) {
            sample.dryPathNode.gain.value = 1 - wetLevel;
        }
        if (sample.source && effects.speed) {
            let basePlaybackRate;
            if (sample.isLongSample) {
                const longLoopBeatDuration = 60 / longLoopTempo;
                const longLoopBarDuration = longLoopBeatDuration * 4;
                const desiredLoopDuration = longLoopBarDuration * longLoopLength;
                basePlaybackRate = sample.loopDuration / desiredLoopDuration;
            } else {
                const effectiveTempo = tempo + highTempo;
                const effectiveBeatDuration = 60 / effectiveTempo;
                const effectiveBarDuration = effectiveBeatDuration * 4;
                const desiredLoopDuration = effectiveBarDuration * loopLength;
                basePlaybackRate = sample.loopDuration / desiredLoopDuration;
            }
            let individualTempo = 1;
            if (sample.isLongSample && effects.individualTempo) {
                individualTempo = effects.individualTempo;
            }
            const newPlaybackRate = basePlaybackRate * individualTempo * effects.speed;
            const currentPlaybackRate = sample.source.playbackRate.value;
            const currentTime = audioContext.currentTime;
            const elapsedTime = currentTime - sample.loopStartTime;
            const currentPosition = elapsedTime * currentPlaybackRate % sample.loopDuration;
            sample.source.playbackRate.value = newPlaybackRate;
            sample.loopStartTime = currentTime - currentPosition / newPlaybackRate;
            
            // Update LFO base rate if pitch modulation is active
            if (sample.lfoTarget === "pitch") {
                sample.lfoBaseRate = newPlaybackRate;
            }
        }
        
        // Update LFO - ensure it only affects this specific sample
        if (effects.lfo && effects.lfo.depth > 0) {
            // Update LFO parameters directly without recreating the node
            sample.lfoNode.type = effects.lfo.waveform;
            sample.lfoNode.frequency.value = effects.lfo.rate;
            sample.lfoGainNode.gain.value = effects.lfo.depth / 100;
            
            // Clear any existing update timeout
            if (sample.lfoUpdateTimeout) {
                clearTimeout(sample.lfoUpdateTimeout);
                sample.lfoUpdateTimeout = null;
            }
            
            // Disconnect all previous connections
            if (sample.lfoGainNode) {
                try {
                    sample.lfoGainNode.disconnect();
                } catch (e) {}
            }
            
            // Disconnect filter offset node if it exists
            if (sample.lfoFilterOffsetNode) {
                try {
                    sample.lfoFilterOffsetNode.disconnect();
                    sample.lfoFilterOffsetNode.stop();
                    sample.lfoFilterOffsetNode = null;
                } catch (e) {}
            }
            
            // FIX: Handle LFO filter bypass based on target
            if (sample.lfoFilterBypass && sample.lfoFilter) {
                if (effects.lfo.target === "filter") {
                    // Use the LFO filter path
                    sample.lfoFilterBypass.gain.value = 0.0;
                    sample.lfoFilter.connect(sample.eqVeryHighNode);
                } else {
                    // Use the bypass path
                    sample.lfoFilterBypass.gain.value = 1.0;
                    try {
                        sample.lfoFilter.disconnect();
                    } catch (e) {}
                }
            }
            
            // Connect to the appropriate target
            const target = effects.lfo.target;
            
            if (target === "pitch") {
                // Check if detune is supported
                const supportsDetune = typeof sample.source.detune !== 'undefined';
                
                if (supportsDetune) {
                    // For pitch modulation, we'll use the detune property
                    // which changes pitch without affecting playback rate
                    sample.lfoTarget = "pitch";
                    
                    // Create a loop to continuously update the detune
                    const updateDetune = () => {
                        if (!sample.source || sample.lfoTarget !== "pitch") return;
                        
                        const time = audioContext.currentTime;
                        const lfoRate = effects.lfo.rate;
                        const lfoDepth = effects.lfo.depth / 100;
                        const waveform = effects.lfo.waveform;
                        
                        const lfoDuration = 1 / lfoRate;
                        const phase = (time % lfoDuration) / lfoDuration * Math.PI * 2;
                        
                        let modulationValue = 0;
                        switch (waveform) {
                            case "sine":
                                modulationValue = Math.sin(phase);
                                break;
                            case "square":
                                modulationValue = Math.sin(phase) > 0 ? 1 : -1;
                                break;
                            case "triangle":
                                const t = (phase / Math.PI) % 2;
                                modulationValue = t < 1 ? 2 * t - 1 : 3 - 2 * t;
                                break;
                            case "sawtooth":
                                modulationValue = 2 * ((phase / Math.PI) % 1) - 1;
                                break;
                        }
                        
                        // Calculate the detune value in cents
                        // Maximum detune is 1200 cents (one octave) in either direction
                        const maxDetune = 1200;
                        const detuneValue = maxDetune * lfoDepth * modulationValue;
                        
                        // Apply the detune to the source
                        sample.source.detune.setValueAtTime(detuneValue, time);
                        
                        // Schedule the next update
                        sample.lfoUpdateTimeout = setTimeout(updateDetune, 50); // Update every 50ms for smooth modulation
                    };
                    
                    // Start the update loop
                    updateDetune();
                } else {
                    // Fall back to the current implementation using playbackRate
                    // For pitch modulation, we'll use a more direct approach
                    // by updating the playback rate in a scheduled manner
                    sample.lfoTarget = "pitch";
                    
                    // Store the current base playback rate
                    if (sample.source) {
                        sample.lfoBaseRate = sample.source.playbackRate.value;
                    }
                    
                    // Create a loop to continuously update the playback rate
                    const updatePlaybackRate = () => {
                        if (!sample.source || sample.lfoTarget !== "pitch") return;
                        
                        const time = audioContext.currentTime;
                        const lfoRate = effects.lfo.rate;
                        const lfoDepth = effects.lfo.depth / 100;
                        const waveform = effects.lfo.waveform;
                        
                        const lfoDuration = 1 / lfoRate;
                        const phase = (time % lfoDuration) / lfoDuration * Math.PI * 2;
                        
                        let modulationValue = 0;
                        switch (waveform) {
                            case "sine":
                                modulationValue = Math.sin(phase);
                                break;
                            case "square":
                                modulationValue = Math.sin(phase) > 0 ? 1 : -1;
                                break;
                            case "triangle":
                                const t = (phase / Math.PI) % 2;
                                modulationValue = t < 1 ? 2 * t - 1 : 3 - 2 * t;
                                break;
                            case "sawtooth":
                                modulationValue = 2 * ((phase / Math.PI) % 1) - 1;
                                break;
                        }
                        
                        // Use the stored base rate which should be updated when tempo changes
                        const baseRate = sample.lfoBaseRate || 1.0;
                        
                        // Limit the modulation depth to prevent extreme values
                        // Maximum modulation is 50% of the base rate in either direction
                        const maxModulation = baseRate * 0.5;
                        const modulationAmount = maxModulation * lfoDepth * modulationValue;
                        
                        // Ensure the playback rate never goes below 0.1 to prevent audio stopping
                        const newPlaybackRate = Math.max(0.1, baseRate + modulationAmount);
                        
                        sample.source.playbackRate.setValueAtTime(newPlaybackRate, time);
                        
                        // Schedule the next update
                        sample.lfoUpdateTimeout = setTimeout(updatePlaybackRate, 50); // Update every 50ms for smooth modulation
                    };
                    
                    // Start the update loop
                    updatePlaybackRate();
                }
            } else if (target === "filter") {
                // Connect to the dedicated LFO filter cutoff frequency
                const baseFrequency = sample.lfoFilter ? sample.lfoFilter.frequency.value : 2000;
                const lfoDepth = effects.lfo.depth / 100;
                
                // Calculate the modulation range in octaves
                // Maximum modulation is 2 octaves in either direction
                const maxOctaves = 2;
                const modulationOctaves = maxOctaves * lfoDepth;
                
                // Calculate the frequency range
                const minFrequency = baseFrequency / Math.pow(2, modulationOctaves);
                const maxFrequency = baseFrequency * Math.pow(2, modulationOctaves);
                
                // Create a scale factor to map the LFO output to the frequency range
                const scaleFactor = (maxFrequency - minFrequency) / 2;
                const offset = (maxFrequency + minFrequency) / 2;
                
                // Connect the LFO to the filter frequency
                sample.lfoGainNode.gain.value = scaleFactor;
                sample.lfoGainNode.connect(sample.lfoFilter.frequency);
                
                // Set the base frequency
                sample.lfoFilter.frequency.value = baseFrequency;
                
                // Create a constant source node to add the offset
                const offsetNode = audioContext.createConstantSource();
                offsetNode.offset.value = offset;
                offsetNode.connect(sample.lfoFilter.frequency);
                offsetNode.start();
                
                // Store the offset node for cleanup
                sample.lfoFilterOffsetNode = offsetNode;
                
                sample.lfoTarget = "filter";
            } else if (target === "volume") {
                // Connect to the individual volume gain node
                if (sample.individualVolumeGain) {
                    const baseGain = sample.individualVolumeGain.gain.value;
                    const lfoDepth = effects.lfo.depth / 100;
                    
                    // Calculate the modulation range
                    // Maximum modulation is 50% of the base gain in either direction
                    const maxModulation = baseGain * 0.5;
                    const modulationAmount = maxModulation * lfoDepth;
                    
                    // Connect the LFO to the individual volume gain
                    sample.lfoGainNode.gain.value = modulationAmount;
                    sample.lfoGainNode.connect(sample.individualVolumeGain.gain);
                    sample.lfoTarget = "volume";
                }
            }
        }
        
        if (effects.pianoRoll && effects.pianoRoll.notes.length > 0) {
            pianoRollData[sampleNumber] = JSON.parse(JSON.stringify(effects.pianoRoll));
        }
        if (currentSampleForPopup === sampleNumber && waveformAnalyzer) {
            const sample = currentPlaying[sampleNumber];
            if (sample.eqVeryHighNode) {
                sample.eqVeryHighNode.disconnect();
                sample.eqVeryHighNode.connect(waveformAnalyzer);
                waveformAnalyzer.connect(masterOutputNode);
            } else if (sample.outputNode) {
                sample.outputNode.disconnect();
                sample.outputNode.connect(waveformAnalyzer);
                waveformAnalyzer.connect(masterOutputNode);
            } else if (sample.gainNode) {
                sample.gainNode.disconnect();
                sample.gainNode.connect(waveformAnalyzer);
                waveformAnalyzer.connect(masterOutputNode);
            }
        }
    }

    function setupPopupEventListeners(popup) {
        const closeBtn = popup.querySelector(".popup-close-btn");
        const acceptBtn = popup.querySelector(".popup-accept-btn");
        const resetBtn = popup.querySelector(".popup-reset-btn");
        if (closeBtn) {
            closeBtn.addEventListener("click", function () {
                if (currentSampleForPopup) {
                    currentPlaying[currentSampleForPopup].effects = JSON.parse(JSON.stringify(originalEffects));
                    if (currentPlaying[currentSampleForPopup].isScheduled && currentPlaying[currentSampleForPopup].isActive) {
                        updateSampleEffects(currentSampleForPopup);
                    }
                }
                hideEffectsPopup();
            });
        }
        if (acceptBtn) {
            acceptBtn.addEventListener("click", async function () {
                await applyEffectsSettings();
            });
        }
        if (resetBtn) {
            resetBtn.addEventListener("click", resetEffectsSettings);
        }
    }
    setupPopupEventListeners(effectsPopup);
    document.getElementById("sample-upload").addEventListener("change", handleSampleUpload);
    document.getElementById("delay-time").addEventListener("input", function () {
        document.getElementById("delay-time-value").textContent = this.value;
        updateDelayInRealTime();
        if (temporaryEffects) {
            temporaryEffects.delay.time = parseInt(this.value);
        }
    });
    document.getElementById("delay-feedback").addEventListener("input", function () {
        document.getElementById("delay-feedback-value").textContent = this.value;
        updateDelayInRealTime();
        if (temporaryEffects) {
            temporaryEffects.delay.feedback = parseInt(this.value);
        }
    });
    document.getElementById("reverb-decay").addEventListener("input", function () {
        document.getElementById("reverb-decay-value").textContent = this.value;
        updateReverbInRealTime();
        if (temporaryEffects) {
            temporaryEffects.reverb.decay = parseFloat(this.value);
        }
    });
    document.getElementById("reverb-predelay").addEventListener("input", function () {
        document.getElementById("reverb-predelay-value").textContent = this.value;
        updateReverbInRealTime();
        if (temporaryEffects) {
            temporaryEffects.reverb.predelay = parseFloat(this.value);
        }
    });
    document.getElementById("reverb-diffusion").addEventListener("input", function () {
        document.getElementById("reverb-diffusion-value").textContent = this.value;
        updateReverbInRealTime();
        if (temporaryEffects) {
            temporaryEffects.reverb.diffusion = parseFloat(this.value);
        }
    });
    document.getElementById("reverb-lowcut").addEventListener("input", function () {
        document.getElementById("reverb-lowcut-value").textContent = this.value;
        updateReverbInRealTime();
        if (temporaryEffects) {
            temporaryEffects.reverb.lowcut = parseFloat(this.value);
        }
    });
    document.getElementById("reverb-highcut").addEventListener("input", function () {
        document.getElementById("reverb-highcut-value").textContent = this.value;
        updateReverbInRealTime();
        if (temporaryEffects) {
            temporaryEffects.reverb.highcut = parseFloat(this.value);
        }
    });
    document.getElementById("reverb-damping").addEventListener("input", function () {
        document.getElementById("reverb-damping-value").textContent = this.value;
        updateReverbInRealTime();
        if (temporaryEffects) {
            temporaryEffects.reverb.damping = parseFloat(this.value);
        }
    });
    document.getElementById("reverb-mix").addEventListener("input", function () {
        document.getElementById("reverb-mix-value").textContent = this.value;
        updateReverbInRealTime();
        if (temporaryEffects) {
            temporaryEffects.reverb.mix = parseInt(this.value);
        }
    });
    const highTempoSlider = document.querySelector(".high-tempo-slider");
    const highTempoDisplay = document.querySelector(".high-tempo-display");
    const longLoopTempoSlider = document.querySelector(".long-loop-tempo-slider");
    const longLoopTempoDisplay = document.querySelector(".long-loop-tempo-display");
    const volumeControlsContainer = document.querySelector(".volume-controls");
    
    // Add Save/Load Set controls
    const setControls = document.createElement("div");
    setControls.className = "set-controls";
    
    const saveSetBtn = document.createElement("button");
    saveSetBtn.className = "set-btn";
    saveSetBtn.textContent = "Save Set";
    
    const loadSetBtn = document.createElement("button");
    loadSetBtn.className = "set-btn load-btn";
    loadSetBtn.textContent = "Load Set";
    
    setControls.appendChild(saveSetBtn);
    setControls.appendChild(loadSetBtn);
    volumeControlsContainer.parentNode.insertBefore(setControls, volumeControlsContainer.nextSibling);
    
    // Save Set functionality
    saveSetBtn.addEventListener("click", async function() {
        await saveCurrentSet();
    });
    
    // Load Set functionality
    loadSetBtn.addEventListener("click", function() {
        loadSet();
    });
    
    // Function to save the current set
    async function saveCurrentSet() {
        try {
            showNotification("Saving set... This may take a moment for large files.");
            
            // Create a set object to store all the data
            const set = {
                tempo: tempo,
                highTempo: highTempo,
                longLoopTempo: longLoopTempo,
                loopLength: loopLength,
                longLoopLength: longLoopLength,
                samples: {},
                pianoRollData: {},
                groupVolumes: {},
                timestamp: new Date().toISOString()
            };
            
            // Save group volumes
            for (let group = 0; group < 10; group++) {
                const groupSlider = document.getElementById(`volumeSlider${group}`);
                if (groupSlider) {
                    set.groupVolumes[group] = parseFloat(groupSlider.value);
                }
            }
            
            // Save sample data with progress tracking
            let processedSamples = 0;
            let totalSamples = 0;
            
            // Count total samples first
            for (let i = 1; i <= 100; i++) {
                if (currentPlaying[i] && (currentPlaying[i].button || currentPlaying[i].buffer || currentPlaying[i].effects)) {
                    totalSamples++;
                }
            }
            
            // Process samples in batches to prevent memory issues
            for (let i = 1; i <= 100; i++) {
                if (currentPlaying[i]) {
                    const sample = currentPlaying[i];
                    
                    // Only save samples that have been used
                    if (sample.button || sample.buffer || sample.effects) {
                        set.samples[i] = {
                            isActive: sample.isActive,
                            isScheduled: sample.isScheduled,
                            isLongSample: sample.isLongSample,
                            isCustomSample: sample.isCustomSample,
                            individualVolume: sample.individualVolume,
                            effects: sample.effects,
                            eqVisualizerEnabled: sample.eqVisualizerEnabled
                        };
                        
                        // Save audio buffer as base64 if it exists (skip for very large buffers)
                        if (sample.buffer && sample.buffer.length < 44100 * 10) { // Skip if longer than 10 seconds
                            try {
                                set.samples[i].buffer = audioBufferToBase64(sample.buffer);
                                set.samples[i].bufferSampleNumber = sample.bufferSampleNumber;
                                set.samples[i].loopDuration = sample.loopDuration;
                            } catch (error) {
                                console.warn(`Skipping large audio buffer for sample ${i}:`, error);
                            }
                        }
                        
                        // Save recorded blob if it exists (skip very large blobs)
                        if (recordedBlobs[i] && recordedBlobs[i] instanceof Blob) {
                            if (recordedBlobs[i].size < 50 * 1024 * 1024) { // Skip if larger than 50MB
                                try {
                                    set.samples[i].recordedBlob = await blobToBase64(recordedBlobs[i]);
                                } catch (error) {
                                    console.warn(`Skipping large recorded blob for sample ${i}:`, error);
                                }
                            } else {
                                console.warn(`Skipping very large recorded blob for sample ${i} (${(recordedBlobs[i].size / 1024 / 1024).toFixed(1)}MB)`);
                            }
                        }
                        
                        // Save upload status and file name
                        if (uploadStatusPerSample[i]) {
                            set.samples[i].uploadStatus = uploadStatusPerSample[i];
                        }
                        if (uploadedFileNames[i]) {
                            set.samples[i].fileName = uploadedFileNames[i];
                        }
                        
                        processedSamples++;
                        
                        // Update progress every 10 samples
                        if (processedSamples % 10 === 0) {
                            showNotification(`Processing samples... ${processedSamples}/${totalSamples}`);
                            // Allow UI to update
                            await new Promise(resolve => setTimeout(resolve, 10));
                        }
                    }
                }
            }
            
            // Save piano roll data
            for (let i in pianoRollData) {
                if (pianoRollData.hasOwnProperty(i)) {
                    set.pianoRollData[i] = JSON.parse(JSON.stringify(pianoRollData[i]));
                }
            }
            
            showNotification("Creating save file...");
            
            // Create downloadable file (don't save to localStorage for large files)
            const setJSON = JSON.stringify(set);
            const blob = new Blob([setJSON], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `psychological-studio-set-${new Date().toISOString().slice(0,10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            // Only save to localStorage if the file is small enough
            if (setJSON.length < 5 * 1024 * 1024) { // 5MB limit for localStorage
                localStorage.setItem("psychologicalStudioSet", setJSON);
                showNotification("Set saved successfully! (Also saved to browser storage)");
            } else {
                showNotification("Set saved successfully! (File too large for browser storage - download only)");
            }
            
        } catch (error) {
            console.error("Error saving set:", error);
            showNotification("Error saving set. File may be too large. Try reducing sample sizes.");
        }
    }
    
    // Function to load a set
    function loadSet() {
        try {
            // Always prompt for file selection
            const input = document.createElement("input");
            input.type = "file";
            input.accept = ".json";
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        try {
                            processLoadedSet(event.target.result);
                        } catch (error) {
                            console.error("Error processing loaded set:", error);
                            showNotification("Error loading set. Invalid file format.");
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        } catch (error) {
            console.error("Error loading set:", error);
            showNotification("Error loading set. Please try again.");
        }
    }
    
    // Function to process the loaded set data
    function processLoadedSet(setJSON) {
        const set = JSON.parse(setJSON);
        
        // Stop playback if playing
        if (isPlaying) {
            playButton.click();
        }
        
        // Set loading flag to prevent automatic scheduling
        window.isLoadingSet = true;
        
        // Reset all samples
        for (let i = 1; i <= 100; i++) {
            // Stop any scheduled or playing samples
            if (currentPlaying[i].isScheduled || currentPlaying[i].source) {
                stopSample(i);
            }
            currentPlaying[i].isActive = false;
            currentPlaying[i].scheduledForNextBar = false;
            if (currentPlaying[i].button) {
                currentPlaying[i].button.classList.remove("active", "no-sample");
                currentPlaying[i].button = null;
            }
        }
        
        // Load tempo settings
        tempo = set.tempo || 120;
        highTempo = set.highTempo || 0;
        longLoopTempo = set.longLoopTempo || 120;
        loopLength = set.loopLength || 1;
        longLoopLength = set.longLoopLength || 1;
        
        // Update UI
        tempoSlider.value = tempo;
        tempoDisplay.textContent = `${tempo} BPM`;
        highTempoSlider.value = 240 + highTempo;
        highTempoDisplay.textContent = `${240 + highTempo} BPM`;
        longLoopTempoSlider.value = longLoopTempo;
        longLoopTempoDisplay.textContent = `${longLoopTempo} BPM`;
        
        // Update loop buttons
        document.querySelectorAll(".loop-button").forEach(btn => {
            btn.classList.remove("active");
            if (btn.dataset.loop == loopLength) {
                btn.classList.add("active");
            }
        });
        
        document.querySelectorAll(".long-loop-button").forEach(btn => {
            btn.classList.remove("active");
            if (btn.dataset.longLoop == longLoopLength / 4) {
                btn.classList.add("active");
            }
        });
        
        // Load group volumes
        for (let group = 0; group < 10; group++) {
            if (set.groupVolumes && set.groupVolumes[group] !== undefined) {
                const groupSlider = document.getElementById(`volumeSlider${group}`);
                const groupValue = document.getElementById(`volumeValue${group}`);
                if (groupSlider && groupValue) {
                    groupSlider.value = set.groupVolumes[group];
                    groupValue.textContent = `${set.groupVolumes[group]}%`;
                }
            }
        }
        
        // Load samples
        for (let i in set.samples) {
            if (set.samples.hasOwnProperty(i)) {
                const sampleData = set.samples[i];
                const sampleNumber = parseInt(i);
                
                // Find the button
                const button = document.getElementById(`but${sampleNumber}`);
                if (button) {
                    // DON'T activate any buttons during loading - just load the sample data
                    // User will manually click buttons to activate them
                    currentPlaying[sampleNumber].button = null;
                    
                    // Set visual state to show sample is available
                    if (sampleData.buffer) {
                        button.classList.remove("no-sample");
                        if (sampleData.isCustomSample) {
                            addCustomIndicator(button);
                        }
                    } else {
                        button.classList.add("no-sample");
                    }
                    
                    // Load buffer if available
                    if (sampleData.buffer) {
                        base64ToAudioBuffer(sampleData.buffer).then(buffer => {
                            currentPlaying[sampleNumber].buffer = buffer;
                            currentPlaying[sampleNumber].bufferSampleNumber = sampleData.bufferSampleNumber || sampleNumber;
                            currentPlaying[sampleNumber].loopDuration = sampleData.loopDuration || buffer.duration;
                            currentPlaying[sampleNumber].isCustomSample = sampleData.isCustomSample || false;
                        }).catch(error => {
                            console.error(`Error loading buffer for sample ${sampleNumber}:`, error);
                        });
                    }
                    
                    // Load recorded blob if available
                    if (sampleData.recordedBlob) {
                        base64ToBlob(sampleData.recordedBlob).then(blob => {
                            recordedBlobs[sampleNumber] = blob;
                        }).catch(error => {
                            console.error(`Error loading recorded blob for sample ${sampleNumber}:`, error);
                        });
                    }
                    
                    // Load effects
                    if (sampleData.effects) {
                        currentPlaying[sampleNumber].effects = sampleData.effects;
                    }
                    
                    // Load other properties
                    currentPlaying[sampleNumber].eqVisualizerEnabled = sampleData.eqVisualizerEnabled || false;
                    currentPlaying[sampleNumber].individualVolume = sampleData.individualVolume || 1.0;
                    
                    // IMPORTANT: Always set scheduled state to false when loading
                    // This prevents all buttons from being automatically scheduled
                    currentPlaying[sampleNumber].isScheduled = false;
                    currentPlaying[sampleNumber].scheduledForNextBar = false;
                    currentPlaying[sampleNumber].isActive = false;
                    
                    // Load upload status
                    if (sampleData.uploadStatus) {
                        uploadStatusPerSample[sampleNumber] = sampleData.uploadStatus;
                    }
                    
                    // Load file name
                    if (sampleData.fileName) {
                        uploadedFileNames[sampleNumber] = sampleData.fileName;
                    }
                }
            }
        }
        
        // Load piano roll data
        if (set.pianoRollData) {
            pianoRollData = JSON.parse(JSON.stringify(set.pianoRollData));
        }
        
        // Replicate the exact behavior of tempo slider change
        updateTiming();
        updateMasterBarGrid();
        
        // Reschedule all active samples with new tempo
        for (let i = 1; i <= 100; i++) {
            if (currentPlaying[i].button && currentPlaying[i].buffer && currentPlaying[i].isActive) {
                if (currentPlaying[i].isScheduled) {
                    // Stop current scheduling
                    if (currentPlaying[i].source) {
                        currentPlaying[i].source.stop();
                        currentPlaying[i].source = null;
                    }
                    currentPlaying[i].isScheduled = false;
                    currentPlaying[i].scheduledForNextBar = false;
                }
                // Reschedule for next bar with new tempo
                scheduleSampleForNextBar(i);
            }
        }
        
        // Clear loading flag
        window.isLoadingSet = false;
        
        showNotification("Set loaded successfully!");
    }
    
    // Helper function to convert audio buffer to base64
    function audioBufferToBase64(buffer) {
        const length = buffer.length * buffer.numberOfChannels * 2 + 44;
        const arrayBuffer = new ArrayBuffer(length);
        const view = new DataView(arrayBuffer);
        const channels = [];
        let offset = 0;
        let pos = 0;
        
        // Write WAV header
        const setUint16 = (data) => {
            view.setUint16(pos, data, true);
            pos += 2;
        };
        
        const setUint32 = (data) => {
            view.setUint32(pos, data, true);
            pos += 4;
        };
        
        // RIFF identifier
        setUint32(0x46464952);
        // file length
        setUint32(length - 8);
        // WAVE identifier
        setUint32(0x45564157);
        // fmt chunk identifier
        setUint32(0x20746d66);
        // chunk length
        setUint32(16);
        // sample format (PCM)
        setUint16(1);
        // channel count
        setUint16(buffer.numberOfChannels);
        // sample rate
        setUint32(buffer.sampleRate);
        // byte rate
        setUint32(buffer.sampleRate * 2 * buffer.numberOfChannels);
        // block align
        setUint16(buffer.numberOfChannels * 2);
        // bits per sample
        setUint16(16);
        // data chunk identifier
        setUint32(0x61746164);
        // data chunk length
        setUint32(length - pos - 4);
        
        // Write interleaved data
        for (let i = 0; i < buffer.numberOfChannels; i++) {
            channels.push(buffer.getChannelData(i));
        }
        
        while (pos < length) {
            for (let i = 0; i < buffer.numberOfChannels; i++) {
                let sample = Math.max(-1, Math.min(1, channels[i][offset]));
                sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                view.setInt16(pos, sample, true);
                pos += 2;
            }
            offset++;
        }
        
        // Convert to base64
        const bytes = new Uint8Array(arrayBuffer);
        let binary = '';
        for (let i = 0; i < bytes.byteLength; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
    }
    
    // Helper function to convert base64 to audio buffer
    function base64ToAudioBuffer(base64) {
        return new Promise((resolve, reject) => {
            try {
                const binaryString = atob(base64);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                
                audioContext.decodeAudioData(bytes.buffer).then(buffer => {
                    resolve(buffer);
                }).catch(error => {
                    reject(error);
                });
            } catch (error) {
                reject(error);
            }
        });
    }
    
    // Helper function to convert blob to base64
    function blobToBase64(blob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            const timeout = setTimeout(() => {
                reject(new Error('Blob conversion timeout'));
            }, 10000); // 10 second timeout
            
            reader.onload = () => {
                clearTimeout(timeout);
                const dataUrl = reader.result;
                const base64 = dataUrl.split(',')[1];
                resolve(base64);
            };
            reader.onerror = (error) => {
                clearTimeout(timeout);
                reject(error);
            };
            reader.readAsDataURL(blob);
        });
    }
    
    // Helper function to convert base64 to blob
    function base64ToBlob(base64, mimeType = 'audio/wav') {
        return new Promise((resolve, reject) => {
            try {
                const binaryString = atob(base64);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                
                const blob = new Blob([bytes], { type: mimeType });
                resolve(blob);
            } catch (error) {
                reject(error);
            }
        });
    }
    
    for (let group = 0; group < 10; group++) {
        const volumeControl = document.createElement("div");
        volumeControl.className = `volume-control group-${group}`;
        const volumeLabel = document.createElement("label");
        volumeLabel.textContent = `${group}: `;
        const volumeSlider = document.createElement("input");
        volumeSlider.type = "range";
        volumeSlider.min = "0";
        volumeSlider.max = "100";
        volumeSlider.value = "80";
        volumeSlider.step = "1";
        volumeSlider.className = `volume-slider`;
        volumeSlider.id = `volumeSlider${group}`;
        const volumeValue = document.createElement("span");
        volumeValue.className = "volume-value";
        volumeValue.textContent = "80%";
        volumeValue.id = `volumeValue${group}`;
        volumeControl.appendChild(volumeLabel);
        volumeControl.appendChild(volumeSlider);
        volumeControl.appendChild(volumeValue);
        volumeControlsContainer.appendChild(volumeControl);
        volumeSlider.addEventListener("input", function () {
            const volume = this.value;
            volumeValue.textContent = `${volume}%`;
            for (let i = 1; i <= 100; i++) {
                if (currentPlaying[i] && currentPlaying[i].gainNode && Math.floor((i - 1) / 10) === group) {
                    // Store the group volume as a decimal (0-1)
                    currentPlaying[i].groupVolume = volume / 100;
                    
                    // Update the actual gain by combining with individual volume
                    updateActualGain(i);
                }
            }
        });
    }
    for (let i = 1; i <= 100; i++) {
        const button = document.createElement("button");
        button.className = "audio-button";
        button.textContent = i;
        button.id = `but${i}`;
        button.style.position = "relative";
        const loopIndicator = document.createElement("div");
        loopIndicator.className = "loop-indicator";
        button.appendChild(loopIndicator);
        const customIndicator = document.createElement("div");
        customIndicator.className = "custom-indicator";
        customIndicator.style.display = "none";
        button.appendChild(customIndicator);
        const group = Math.floor((i - 1) / 10);
        button.classList.add(`group-${group}`);
        if (!currentPlaying[i]) {
            currentPlaying[i] = {
                button: null,
                buffer: null,
                source: null,
                gainNode: null,
                loopDuration: null,
                sampleNumber: null,
                isScheduled: false,
                startTime: 0,
                scheduledForNextBar: false,
                isLongSample: i > 60,
                nextLoopTime: 0,
                scheduledTimeout: null,
                loopStartTime: 0,
                originalTempo: tempo,
                volume: .8,
                bufferSampleNumber: null,
                isActive: false,
                tempoChangeTime: 0,
                positionAtTempoChange: 0,
                masterStartBar: 0,
                masterStartOffset: 0,
                barGridAligned: false,
                isCustomSample: false,
                // Initialize group and individual volume properties
                groupVolume: 0.8,
                individualVolume: 1.0,
                effects: {
                    delay: {
                        time: 0,
                        feedback: 0
                    },
                    reverb: {
                        decay: 0,
                        mix: 0,
                        predelay: 0,
                        diffusion: 50,
                        lowcut: 20,
                        highcut: 2e4,
                        damping: 50
                    },
                    eq: [{
                        frequency: 20,
                        gain: 0,
                        q: 1,
                        type: "lowshelf",
                        fixed: true
                    }, {
                        frequency: 2e4,
                        gain: 0,
                        q: 1,
                        type: "highshelf",
                        fixed: true
                    }],
                    volume: 100,
                    speed: 1,
                    individualTempo: 1,
                    lfo: {
                        target: "pitch",
                        waveform: "sine",
                        rate: 1.0,
                        depth: 0
                    },
                    pianoRoll: {
                        notes: [],
                        soundSource: "sounddesign",
                        gridWidth: i > 60 ? 32 : 16,
                        gridHeight: 84,
                        scrollX: 0,
                        scrollY: 0,
                        sampleRange: {
                            start: 0,
                            end: 100
                        },
                        filters: {
                            lowShelf: 0,
                            highShelf: 0,
                            lowMid: 0,
                            mid: 0,
                            highMid: 0,
                            delay: {
                                time: 0,
                                feedback: 0
                            }
                        },
                        isEnabled: false
                    }
                },
                delayNode: null,
                delayFeedbackNode: null,
                reverbNode: null,
                reverbMixNode: null,
                wetPathNode: null,
                dryPathNode: null,
                outputNode: null,
                eqLowNode: null,
                eqLowMidNode: null,
                eqMidNode: null,
                eqHighMidNode: null,
                eqHighMid2Node: null,
                eqHighNode: null,
                eqVeryHighNode: null,
                lfoNode: null,
                lfoGainNode: null,
                lfoTarget: null,
                lfoBaseRate: 1.0,
                lfoUpdateTimeout: null,
                individualVolumeGain: null,
                lfoFilterOffsetNode: null,
                lfoFilter: null,
                lfoFilterBypass: null,
                eqVisualizerEnabled: false
            };
        }
        button.addEventListener("click", function () {
            const group = Math.floor((i - 1) / 10);
            if (currentPlaying[i].button === button) {
                if (button.classList.contains("no-sample")) {
                    button.classList.remove("active", "no-sample");
                    currentPlaying[i].isActive = false;
                    currentPlaying[i].scheduledForNextBar = false;
                    currentPlaying[i].button = null;
                } else if (currentPlaying[i].isScheduled) {
                    stopSample(i);
                    button.classList.remove("active", "no-sample");
                    currentPlaying[i].isActive = false;
                    button.classList.remove("loading");
                } else {
                    button.classList.add("active");
                    currentPlaying[i].isActive = true;
                    
                    // Don't schedule during loading - only when user manually clicks
                    if (!window.isLoadingSet) {
                        currentPlaying[i].scheduledForNextBar = true;
                        addIndicatorsForActiveSample(button, i);
                        if (currentPlaying[i].buffer && isPlaying) {
                            button.classList.remove("no-sample");
                            scheduleSampleForNextBar(i);
                        } else {
                            button.classList.add("no-sample");
                        }
                    } else {
                        // During loading, just mark as active but not scheduled
                        button.classList.add("no-sample");
                    }
                }
            } else {
                for (let j = 1; j <= 100; j++) {
                    if (Math.floor((j - 1) / 10) === group && currentPlaying[j].button) {
                        currentPlaying[j].button.classList.remove("active", "no-sample", "loading", "error");
                        stopSample(j);
                        currentPlaying[j].isActive = false;
                        currentPlaying[j].scheduledForNextBar = false;
                        currentPlaying[j].button = null;
                    }
                }
                currentPlaying[i].button = button;
                currentPlaying[i].sampleNumber = i;
                currentPlaying[i].isLongSample = i > 60;
                currentPlaying[i].originalTempo = tempo;
                button.classList.add("active");
                currentPlaying[i].isActive = true;
                currentPlaying[i].scheduledForNextBar = true;
                currentPlaying[i].barGridAligned = false;
                addIndicatorsForActiveSample(button, i);
                if (currentPlaying[i].buffer) {
                    button.classList.remove("no-sample");
                    if (isPlaying) {
                        scheduleSampleForNextBar(i);
                    }
                } else {
                    button.classList.add("no-sample");
                    loadAudio(i, i);
                }
            }
        });
        button.addEventListener("contextmenu", function (e) {
            e.preventDefault();
            showEffectsPopup(i, button);
        });
        button.addEventListener("touchstart", function (e) {
            isLongPress = false;
            longPressTimer = setTimeout(function () {
                isLongPress = true;
                showEffectsPopup(i, button);
            }, 500);
        });
        button.addEventListener("touchend", function (e) {
            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }
            if (isLongPress) {
                e.preventDefault();
                isLongPress = false;
            }
        });
        button.addEventListener("touchmove", function (e) {
            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }
        });
        buttonGrid.appendChild(button);
    }

    function addIndicatorsForActiveSample(button, sampleNumber) {
        if (currentPlaying[sampleNumber] && currentPlaying[sampleNumber].isCustomSample) {
            addCustomIndicator(button);
        }
    }

    function setCustomIndicatorVisibility(button, visible) {
        let customIndicator = button.querySelector(".custom-indicator");
        if (customIndicator) {
            customIndicator.style.display = visible ? "block" : "none";
        }
    }
    const loopButtons = document.querySelectorAll(".loop-button");
    loopButtons.forEach(button => {
        button.addEventListener("click", function () {
            const isLongLoopButton = button.classList.contains("long-loop-button");
            const buttonsToClear = isLongLoopButton ? document.querySelectorAll(".long-loop-button") : document.querySelectorAll(".loop-button:not(.long-loop-button)");
            buttonsToClear.forEach(btn => btn.classList.remove("active"));
            this.classList.add("active");
            const newLoopLength = parseInt(this.dataset.loop || this.dataset.longLoop);
            if (isNaN(newLoopLength) || newLoopLength <= 0) {
                console.error("Invalid loop length value:", this.dataset.loop || this.dataset.longLoop);
                return;
            }
            if (isLongLoopButton) {
                const newLongLoopLength = newLoopLength * 4;
                longLoopLength = newLongLoopLength;
                if (isPlaying) {
                    for (let i = 1; i <= 100; i++) {
                        if (currentPlaying[i].button && currentPlaying[i].buffer && currentPlaying[i].scheduledForNextBar && currentPlaying[i].isActive && currentPlaying[i].isScheduled && currentPlaying[i].isLongSample) {
                            updateLongSampleLoop(i);
                        }
                    }
                }
                console.log(`Long sample loop length set to ${longLoopLength} bars (double of ${newLoopLength})`);
            } else {
                loopLength = newLoopLength;
                if (isPlaying) {
                    for (let i = 1; i <= 100; i++) {
                        if (currentPlaying[i].button && currentPlaying[i].buffer && currentPlaying[i].scheduledForNextBar && currentPlaying[i].isActive && currentPlaying[i].isScheduled && !currentPlaying[i].isLongSample) {
                            updateDrumSampleLoop(i);
                        }
                    }
                }
                console.log(`Loop length set to ${loopLength} bars`);
            }
        });
    });
    const defaultLoopButton = document.querySelector('.loop-button[data-loop="1"]');
    if (defaultLoopButton) {
        defaultLoopButton.classList.add("active");
    }
    const defaultLongLoopButton = document.querySelector('.long-loop-button[data-long-loop="1"]');
    if (defaultLongLoopButton) {
        defaultLongLoopButton.classList.add("active");
    }

    function loadAudio(sampleNumber, index) {
        if (!audioContext) {
            console.error("Audio context not initialized");
            return;
        }
        if (currentPlaying[index].button) {
            currentPlaying[index].button.classList.add("loading");
        }
        const audio = new Audio;
        audio.addEventListener("error", function (e) {
            console.error(`Error loading audio for sample ${sampleNumber}:`, e);
            if (currentPlaying[index].button) {
                currentPlaying[index].button.classList.remove("loading");
                currentPlaying[index].button.classList.add("error");
                if (currentPlaying[index].button.classList.contains("active")) {
                    currentPlaying[index].button.classList.add("no-sample");
                }
            }
            loadFallbackAudio(index);
        });
        try {
            audio.src = `./${currentSampleFolder}/${sampleNumber}.wav`;
        } catch (e) {
            console.error(`Error setting audio source for sample ${sampleNumber}:`, e);
            loadFallbackAudio(index);
            return;
        }
        audio.addEventListener("canplaythrough", function () {
            fetch(audio.src).then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.arrayBuffer();
            }).then(arrayBuffer => {
                if (!audioContext) {
                    throw new Error("Audio context not available");
                }
                return audioContext.decodeAudioData(arrayBuffer);
            }).then(audioBuffer => {
                currentPlaying[index].buffer = audioBuffer;
                currentPlaying[index].loopDuration = audioBuffer.duration;
                currentPlaying[index].bufferSampleNumber = sampleNumber;
                if (currentPlaying[index].button) {
                    currentPlaying[index].button.classList.remove("loading", "no-sample");
                }
                if (isPlaying && currentPlaying[index].scheduledForNextBar && currentPlaying[index].isActive) {
                    if (currentPlaying[index].scheduledTimeout) {
                        clearTimeout(currentPlaying[index].scheduledTimeout);
                        currentPlaying[index].scheduledTimeout = null;
                    }
                    scheduleSampleForNextBar(index);
                }
            })["catch"](e => {
                console.error("Error decoding audio data:", e);
                if (currentPlaying[index].button) {
                    currentPlaying[index].button.classList.remove("loading");
                    currentPlaying[index].button.classList.add("error");
                    if (currentPlaying[index].button.classList.contains("active")) {
                        currentPlaying[index].button.classList.add("no-sample");
                    }
                }
                loadFallbackAudio(index);
            });
        });
        audio.load();
    }

    function loadFallbackAudio(index) {
        if (!audioContext) return;
        const sampleRate = audioContext.sampleRate;
        const duration = .5;
        const buffer = audioContext.createBuffer(1, sampleRate * duration, sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) {
            data[i] = Math.sin(2 * Math.PI * 440 * i / sampleRate) * .3;
        }
        currentPlaying[index].buffer = buffer;
        currentPlaying[index].loopDuration = duration;
        currentPlaying[index].bufferSampleNumber = index;
        if (currentPlaying[index].button) {
            currentPlaying[index].button.classList.remove("loading", "error");
            currentPlaying[index].button.classList.add("no-sample");
        }
        if (isPlaying && currentPlaying[index].scheduledForNextBar && currentPlaying[index].isActive) {
            if (currentPlaying[index].scheduledTimeout) {
                clearTimeout(currentPlaying[index].scheduledTimeout);
                currentPlaying[index].scheduledTimeout = null;
            }
            scheduleSampleForNextBar(index);
        }
    }

    function updateMasterBarGrid() {
        if (!audioContext) return;
        const currentTime = audioContext.currentTime;
        const currentBarProgress = (currentTime - masterBarGrid.startTime) / masterBarGrid.duration;
        const effectiveTempo = tempo + highTempo;
        const newBarDuration = 60 / effectiveTempo * 4;
        if (!isFinite(newBarDuration) || newBarDuration <= 0) {
            console.error("Invalid bar duration:", newBarDuration);
            return;
        }
        masterBarGrid.startTime = currentTime - currentBarProgress * newBarDuration;
        masterBarGrid.duration = newBarDuration;
        masterBarGrid.nextStartTime = masterBarGrid.startTime + masterBarGrid.duration;
        console.log(`Master bar grid updated: bar progress ${currentBarProgress}, new duration ${newBarDuration}`);
    }

    function resetMasterBarGrid() {
        if (!audioContext) return;
        const currentTime = audioContext.currentTime;
        const effectiveTempo = tempo + highTempo;
        const newBarDuration = 60 / effectiveTempo * 4;
        if (!isFinite(newBarDuration) || newBarDuration <= 0) {
            console.error("Invalid bar duration:", newBarDuration);
            return;
        }
        masterBarGrid.startTime = currentTime;
        masterBarGrid.duration = newBarDuration;
        masterBarGrid.nextStartTime = masterBarGrid.startTime + masterBarGrid.duration;
        console.log(`Master bar grid reset: startTime=${masterBarGrid.startTime}, duration=${newBarDuration}, nextStartTime=${masterBarGrid.nextStartTime}`);
    }

    function updateDrumSampleTempo(sampleNumber) {
        if (!currentPlaying[sampleNumber].source || currentPlaying[sampleNumber].isLongSample) return;
        const sample = currentPlaying[sampleNumber];
        const currentTime = audioContext.currentTime;
        const effectiveTempo = tempo + highTempo;
        const effectiveBeatDuration = 60 / effectiveTempo;
        const effectiveBarDuration = effectiveBeatDuration * 4;
        const desiredLoopDuration = effectiveBarDuration * loopLength;
        if (!isFinite(desiredLoopDuration) || desiredLoopDuration <= 0 || !isFinite(currentPlaying[sampleNumber].loopDuration) || currentPlaying[sampleNumber].loopDuration <= 0) {
            console.error("Invalid values for drum sample:", {
                desiredLoopDuration: desiredLoopDuration,
                loopDuration: currentPlaying[sampleNumber].loopDuration
            });
            return;
        }
        const basePlaybackRate = sample.loopDuration / desiredLoopDuration;
        const effects = sample.effects || {};
        const speed = effects.speed || 1;
        const newPlaybackRate = basePlaybackRate * speed;
        const currentPlaybackRate = sample.source.playbackRate.value;
        const elapsedTime = currentTime - sample.loopStartTime;
        const currentPosition = elapsedTime * currentPlaybackRate % sample.loopDuration;
        sample.source.playbackRate.value = newPlaybackRate;
        sample.loopStartTime = currentTime - currentPosition / newPlaybackRate;
        
        // Update LFO base rate if pitch modulation is active
        if (sample.lfoTarget === "pitch") {
            sample.lfoBaseRate = newPlaybackRate;
        }
        
        console.log(`Sample ${sampleNumber} tempo updated: new rate ${newPlaybackRate}, position ${currentPosition}`);
    }

    function updateLongSampleTempo(sampleNumber) {
        if (!currentPlaying[sampleNumber].source || !currentPlaying[sampleNumber].isLongSample) return;
        const sample = currentPlaying[sampleNumber];
        const currentTime = audioContext.currentTime;
        const longLoopBeatDuration = 60 / longLoopTempo;
        const longLoopBarDuration = longLoopBeatDuration * 4;
        const desiredLoopDuration = longLoopBarDuration * longLoopLength;
        if (!isFinite(desiredLoopDuration) || desiredLoopDuration <= 0 || !isFinite(currentPlaying[sampleNumber].loopDuration) || currentPlaying[sampleNumber].loopDuration <= 0) {
            console.error("Invalid values for long sample:", {
                desiredLoopDuration: desiredLoopDuration,
                loopDuration: currentPlaying[sampleNumber].loopDuration
            });
            return;
        }
        const basePlaybackRate = sample.loopDuration / desiredLoopDuration;
        const effects = sample.effects || {};
        const individualTempo = effects.individualTempo || 1;
        const speed = effects.speed || 1;
        const newPlaybackRate = basePlaybackRate * individualTempo * speed;
        const currentPlaybackRate = sample.source.playbackRate.value;
        const elapsedTime = currentTime - sample.loopStartTime;
        const currentPosition = elapsedTime * currentPlaybackRate % sample.loopDuration;
        sample.source.playbackRate.value = newPlaybackRate;
        sample.loopStartTime = currentTime - currentPosition / newPlaybackRate;
        
        // Update LFO base rate if pitch modulation is active
        if (sample.lfoTarget === "pitch") {
            sample.lfoBaseRate = newPlaybackRate;
        }
        
        console.log(`Sample ${sampleNumber} long tempo updated: new rate ${newPlaybackRate}, position ${currentPosition}`);
    }

    function scheduleSampleForNextBar(sampleNumber) {
        if (!currentPlaying[sampleNumber].scheduledForNextBar) return;
        const effects = currentPlaying[sampleNumber].effects || {};
        const pianoRoll = effects.pianoRoll;
        const hasPianoRoll = pianoRoll && pianoRoll.notes && pianoRoll.notes.length > 0;

        // If we have a rendered buffer, align to bar grid as before
        if (currentPlaying[sampleNumber].buffer) {
            const nextBarTime = masterBarGrid.nextStartTime;
            const currentTime = audioContext.currentTime;
            const timeUntilNextBar = (nextBarTime - currentTime) * 1e3;
            if (currentPlaying[sampleNumber].scheduledTimeout) {
                clearTimeout(currentPlaying[sampleNumber].scheduledTimeout);
            }
            currentPlaying[sampleNumber].scheduledTimeout = setTimeout(() => {
                if (currentPlaying[sampleNumber].scheduledForNextBar && currentPlaying[sampleNumber].isActive) {
                    playSampleAtTime(sampleNumber, audioContext.currentTime);
                    currentPlaying[sampleNumber].barGridAligned = true;
                }
                currentPlaying[sampleNumber].scheduledTimeout = null;
            }, Math.max(0, timeUntilNextBar));
            return;
        }

        // Piano-roll-only looping by grid length
        if (!hasPianoRoll) return;
        // Compute loop duration from grid width and tempo
        const isLongSample = currentPlaying[sampleNumber].isLongSample;
        let beatDuration, barDuration;
        if (isLongSample) {
            beatDuration = 60 / longLoopTempo;
            barDuration = beatDuration * 4;
        } else {
            const effectiveTempo = tempo + highTempo;
            beatDuration = 60 / effectiveTempo;
            barDuration = beatDuration * 4;
        }
        const sixteenthDuration = barDuration / 16;
        const loopDuration = (pianoRoll.gridWidth || 16) * sixteenthDuration; // seconds
        if (!isFinite(loopDuration) || loopDuration <= 0) return;
        const now = audioContext.currentTime;
        const loopStart = currentPlaying[sampleNumber].loopStartTime || now;
        const elapsed = Math.max(0, now - loopStart);
        const timeUntilNextLoop = (loopDuration - (elapsed % loopDuration)) * 1e3;
        if (currentPlaying[sampleNumber].scheduledTimeout) {
            clearTimeout(currentPlaying[sampleNumber].scheduledTimeout);
        }
        currentPlaying[sampleNumber].scheduledTimeout = setTimeout(() => {
            if (currentPlaying[sampleNumber].scheduledForNextBar && currentPlaying[sampleNumber].isActive) {
                const startAt = audioContext.currentTime;
                playSampleAtTime(sampleNumber, startAt);
                currentPlaying[sampleNumber].loopStartTime = startAt;
                scheduleSampleForNextBar(sampleNumber);
            }
            currentPlaying[sampleNumber].scheduledTimeout = null;
        }, Math.max(0, timeUntilNextLoop));
    }

    function playSampleAtTime(sampleNumber, startTime) {
        if (!currentPlaying[sampleNumber].scheduledForNextBar) return;
        if (currentPlaying[sampleNumber].source) {
            try {
                if (currentPlaying[sampleNumber].isScheduled) {
                    currentPlaying[sampleNumber].source.stop();
                }
                currentPlaying[sampleNumber].source.disconnect();
                currentPlaying[sampleNumber].source = null;
                currentPlaying[sampleNumber].gainNode = null;
                if (currentPlaying[sampleNumber].delayNode) {
                    currentPlaying[sampleNumber].delayNode.disconnect();
                    currentPlaying[sampleNumber].delayNode = null;
                }
                if (currentPlaying[sampleNumber].delayFeedbackNode) {
                    currentPlaying[sampleNumber].delayFeedbackNode.disconnect();
                    currentPlaying[sampleNumber].delayFeedbackNode = null;
                }
                if (currentPlaying[sampleNumber].reverbNode) {
                    currentPlaying[sampleNumber].reverbNode.disconnect();
                    currentPlaying[sampleNumber].reverbNode = null;
                }
                if (currentPlaying[sampleNumber].reverbMixNode) {
                    currentPlaying[sampleNumber].reverbMixNode.disconnect();
                    currentPlaying[sampleNumber].reverbMixNode = null;
                }
                if (currentPlaying[sampleNumber].wetPathNode) {
                    currentPlaying[sampleNumber].wetPathNode.disconnect();
                    currentPlaying[sampleNumber].wetPathNode = null;
                }
                if (currentPlaying[sampleNumber].dryPathNode) {
                    currentPlaying[sampleNumber].dryPathNode.disconnect();
                    currentPlaying[sampleNumber].dryPathNode = null;
                }
                if (currentPlaying[sampleNumber].outputNode) {
                    currentPlaying[sampleNumber].outputNode.disconnect();
                    currentPlaying[sampleNumber].outputNode = null;
                }
                if (currentPlaying[sampleNumber].eqLowNode) {
                    currentPlaying[sampleNumber].eqLowNode.disconnect();
                    currentPlaying[sampleNumber].eqLowNode = null;
                }
                if (currentPlaying[sampleNumber].eqLowMidNode) {
                    currentPlaying[sampleNumber].eqLowMidNode.disconnect();
                    currentPlaying[sampleNumber].eqLowMidNode = null;
                }
                if (currentPlaying[sampleNumber].eqMidNode) {
                    currentPlaying[sampleNumber].eqMidNode.disconnect();
                    currentPlaying[sampleNumber].eqMidNode = null;
                }
                if (currentPlaying[sampleNumber].eqHighMidNode) {
                    currentPlaying[sampleNumber].eqHighMidNode.disconnect();
                    currentPlaying[sampleNumber].eqHighMidNode = null;
                }
                if (currentPlaying[sampleNumber].eqHighMid2Node) {
                    currentPlaying[sampleNumber].eqHighMid2Node.disconnect();
                    currentPlaying[sampleNumber].eqHighMid2Node = null;
                }
                if (currentPlaying[sampleNumber].eqHighNode) {
                    currentPlaying[sampleNumber].eqHighNode.disconnect();
                    currentPlaying[sampleNumber].eqHighNode = null;
                }
                if (currentPlaying[sampleNumber].eqVeryHighNode) {
                    currentPlaying[sampleNumber].eqVeryHighNode.disconnect();
                    currentPlaying[sampleNumber].eqVeryHighNode = null;
                }
                // Disconnect LFO
                if (currentPlaying[sampleNumber].lfoNode) {
                    currentPlaying[sampleNumber].lfoNode.disconnect();
                    currentPlaying[sampleNumber].lfoNode = null;
                }
                if (currentPlaying[sampleNumber].lfoGainNode) {
                    currentPlaying[sampleNumber].lfoGainNode.disconnect();
                    currentPlaying[sampleNumber].lfoGainNode = null;
                }
                // Clear LFO update timeout
                if (currentPlaying[sampleNumber].lfoUpdateTimeout) {
                    clearTimeout(currentPlaying[sampleNumber].lfoUpdateTimeout);
                    currentPlaying[sampleNumber].lfoUpdateTimeout = null;
                }
                // Disconnect filter offset node if it exists
                if (currentPlaying[sampleNumber].lfoFilterOffsetNode) {
                    try {
                        currentPlaying[sampleNumber].lfoFilterOffsetNode.disconnect();
                        currentPlaying[sampleNumber].lfoFilterOffsetNode.stop();
                        currentPlaying[sampleNumber].lfoFilterOffsetNode = null;
                    } catch (e) {}
                }
                // Disconnect individual volume gain
                if (currentPlaying[sampleNumber].individualVolumeGain) {
                    currentPlaying[sampleNumber].individualVolumeGain.disconnect();
                    currentPlaying[sampleNumber].individualVolumeGain = null;
                }
                // Disconnect LFO filter
                if (currentPlaying[sampleNumber].lfoFilter) {
                    currentPlaying[sampleNumber].lfoFilter.disconnect();
                    currentPlaying[sampleNumber].lfoFilter = null;
                }
                // Disconnect LFO filter bypass
                if (currentPlaying[sampleNumber].lfoFilterBypass) {
                    currentPlaying[sampleNumber].lfoFilterBypass.disconnect();
                    currentPlaying[sampleNumber].lfoFilterBypass = null;
                }
            } catch (e) {
                console.warn("Error stopping audio source:", e);
                currentPlaying[sampleNumber].source = null;
                currentPlaying[sampleNumber].gainNode = null;
            }
        }
        const source = audioContext.createBufferSource();
        source.buffer = currentPlaying[sampleNumber].buffer || null;
        const gainNode = audioContext.createGain();
        const effects = currentPlaying[sampleNumber].effects || {};
        const volumePercent = effects.volume || 100;
        
        // Set the individual volume from effects
        const individualVolume = mapVolumePercentToGain(volumePercent);
        currentPlaying[sampleNumber].individualVolume = individualVolume;
        
        // Get the current group volume for this sample
        const groupVolume = getGroupVolumeForSample(sampleNumber);
        currentPlaying[sampleNumber].groupVolume = groupVolume;
        
        // Create a separate gain node for individual volume modulation
        const individualVolumeGain = audioContext.createGain();
        individualVolumeGain.gain.value = individualVolume;
        currentPlaying[sampleNumber].individualVolumeGain = individualVolumeGain;
        
        // Apply the combined gain (group volume * individual volume)
        const combinedGain = groupVolume * individualVolume;
        gainNode.gain.value = combinedGain;
        currentPlaying[sampleNumber].volume = combinedGain;
        
        source.connect(gainNode);
        gainNode.connect(individualVolumeGain);
        currentPlaying[sampleNumber].source = source;
        currentPlaying[sampleNumber].gainNode = gainNode;
        currentPlaying[sampleNumber].startTime = startTime;
        currentPlaying[sampleNumber].isScheduled = true;
        currentPlaying[sampleNumber].loopStartTime = startTime;
        currentPlaying[sampleNumber].tempoChangeTime = startTime;
        if (effects.pianoRoll && effects.pianoRoll.notes.length > 0) {
            const pianoRoll = effects.pianoRoll;
            const isLongSample = currentPlaying[sampleNumber].isLongSample;
            let beatDuration, barDuration;
            if (isLongSample) {
                beatDuration = 60 / longLoopTempo;
                barDuration = beatDuration * 4;
            } else {
                const effectiveTempo = tempo + highTempo;
                beatDuration = 60 / effectiveTempo;
                barDuration = beatDuration * 4;
            }
            const sixteenthDuration = barDuration / 16;
            const sortedNotes = [...pianoRoll.notes].sort((a, b) => a.col - b.col);
            sortedNotes.forEach(note => {
                const noteTime = startTime + note.col * sixteenthDuration;
                const noteDuration = (note.length || 1) * sixteenthDuration;
            if (pianoRoll.soundSource === "piano") {
                    playPianoNoteForSample(note.row, noteTime, noteDuration, individualVolumeGain, sampleNumber);
                } else if (pianoRoll.soundSource === "synth") {
                    playSynthNoteForSample(note.row, noteTime, noteDuration, individualVolumeGain, sampleNumber);
                } else if (pianoRoll.soundSource === "strings") {
                    playStringsNoteForSample(note.row, noteTime, noteDuration, individualVolumeGain, sampleNumber);
                } else if (pianoRoll.soundSource === "bass") {
                    playBassNoteForSample(note.row, noteTime, noteDuration, individualVolumeGain, sampleNumber);
                } else if (pianoRoll.soundSource === "lead") {
                    playLeadNoteForSample(note.row, noteTime, noteDuration, individualVolumeGain, sampleNumber);
                } else if (pianoRoll.soundSource === "pad") {
                    playPadNoteForSample(note.row, noteTime, noteDuration, individualVolumeGain, sampleNumber);
                } else if (pianoRoll.soundSource === "pluck") {
                    playPluckNoteForSample(note.row, noteTime, noteDuration, individualVolumeGain, sampleNumber);
            } else if (pianoRoll.soundSource === "sounddesign") {
                playSoundDesignNoteForSample(note.row, noteTime, noteDuration, individualVolumeGain, sampleNumber);
                } else {
                    playSampleNoteForSample(note.row, noteTime, noteDuration, individualVolumeGain, sampleNumber, pianoRoll.sampleRange);
                }
            });
        } else {
            if (currentPlaying[sampleNumber].isLongSample) {
                const longLoopBeatDuration = 60 / longLoopTempo;
                const longLoopBarDuration = longLoopBeatDuration * 4;
                const desiredLoopDuration = longLoopBarDuration * longLoopLength;
                if (!isFinite(desiredLoopDuration) || desiredLoopDuration <= 0 || !isFinite(currentPlaying[sampleNumber].loopDuration) || currentPlaying[sampleNumber].loopDuration <= 0) {
                    console.error("Invalid values for long sample:", {
                        desiredLoopDuration: desiredLoopDuration,
                        loopDuration: currentPlaying[sampleNumber].loopDuration
                    });
                    return;
                }
                const basePlaybackRate = currentPlaying[sampleNumber].loopDuration / desiredLoopDuration;
                let individualTempo = 1;
                if (effects.individualTempo) {
                    individualTempo = effects.individualTempo;
                }
                const speed = effects.speed || 1;
                const playbackRate = basePlaybackRate * individualTempo * speed;
                if (!isFinite(playbackRate) || playbackRate <= 0) {
                    console.error("Invalid playback rate for long sample:", playbackRate);
                    return;
                }
                source.loop = true;
                source.loopStart = 0;
                source.loopEnd = currentPlaying[sampleNumber].loopDuration;
                source.playbackRate.value = playbackRate;
                
                // Store the base rate for LFO
                currentPlaying[sampleNumber].lfoBaseRate = playbackRate;
                
                source.start(startTime);
            } else {
                const effectiveTempo = tempo + highTempo;
                const effectiveBeatDuration = 60 / effectiveTempo;
                const effectiveBarDuration = effectiveBeatDuration * 4;
                const desiredLoopDuration = effectiveBarDuration * loopLength;
                if (!isFinite(desiredLoopDuration) || desiredLoopDuration <= 0 || !isFinite(currentPlaying[sampleNumber].loopDuration) || currentPlaying[sampleNumber].loopDuration <= 0) {
                    console.error("Invalid values for drum sample:", {
                        desiredLoopDuration: desiredLoopDuration,
                        loopDuration: currentPlaying[sampleNumber].loopDuration,
                        effectiveBarDuration: effectiveBarDuration,
                        loopLength: loopLength
                    });
                    return;
                }
                const basePlaybackRate = currentPlaying[sampleNumber].loopDuration / desiredLoopDuration;
                const speed = effects.speed || 1;
                const individualTempo = effects.individualTempo || 1;
                const playbackRate = basePlaybackRate * individualTempo * speed;
                if (!isFinite(playbackRate) || playbackRate <= 0) {
                    console.error("Invalid playback rate for drum sample:", playbackRate);
                    return;
                }
                source.loop = true;
                source.loopStart = 0;
                source.loopEnd = currentPlaying[sampleNumber].loopDuration;
                source.playbackRate.value = playbackRate;
                
                // Store the base rate for LFO
                currentPlaying[sampleNumber].lfoBaseRate = playbackRate;
                
                source.start(startTime);
            }
        }
        initializeEffectsForSample(sampleNumber);
        
        // Initialize multi-LFO system for this sample
        // Store the base pitch rate for LFO pitch modulation
        if (source) {
            currentPlaying[sampleNumber].basePitchRate = source.playbackRate.value;
        }
        
        // Initialize all 4 LFOs if they are configured
        initializeAllLFOConnections(sampleNumber);
        
        // Initialize all 4 automations if they are configured
        initializeAllAutomations(sampleNumber, startTime);
        
        setTimeout(() => {
            if (currentPlaying[sampleNumber].isScheduled) {
                updateSampleEffects(sampleNumber);
            }
        }, 50);
        console.log(`Sample ${sampleNumber} (${currentPlaying[sampleNumber].isLongSample?"long":"drum"}) started at ${startTime} with volume ${volumePercent}%, speed ${effects.speed||1} and individual tempo ${effects.individualTempo||1}`);
    }

    function updateDrumSampleLoop(sampleNumber) {
        if (!currentPlaying[sampleNumber].source || currentPlaying[sampleNumber].isLongSample) return;
        const effectiveTempo = tempo + highTempo;
        const effectiveBeatDuration = 60 / effectiveTempo;
        const effectiveBarDuration = effectiveBeatDuration * 4;
        const desiredLoopDuration = effectiveBarDuration * loopLength;
        if (!isFinite(desiredLoopDuration) || desiredLoopDuration <= 0 || !isFinite(currentPlaying[sampleNumber].loopDuration) || currentPlaying[sampleNumber].loopDuration <= 0) {
            console.error("Invalid values for updating drum sample:", {
                desiredLoopDuration: desiredLoopDuration,
                loopDuration: currentPlaying[sampleNumber].loopDuration,
                effectiveBarDuration: effectiveBarDuration,
                loopLength: loopLength
            });
            return;
        }
        const basePlaybackRate = currentPlaying[sampleNumber].loopDuration / desiredLoopDuration;
        const effects = currentPlaying[sampleNumber].effects || {};
        const speed = effects.speed || 1;
        const individualTempo = effects.individualTempo || 1;
        const playbackRate = basePlaybackRate * individualTempo * speed;
        if (!isFinite(playbackRate) || playbackRate <= 0) {
            console.error("Invalid playback rate for updating drum sample:", playbackRate);
            return;
        }
        const currentTime = audioContext.currentTime;
        const elapsedTime = currentTime - currentPlaying[sampleNumber].loopStartTime;
        const loopProgress = elapsedTime * currentPlaying[sampleNumber].source.playbackRate.value % currentPlaying[sampleNumber].loopDuration;
        currentPlaying[sampleNumber].source.playbackRate.value = playbackRate;
        currentPlaying[sampleNumber].loopStartTime = currentTime - loopProgress / playbackRate;
        
        // Update base pitch rate for all active LFO pitch modulations
        currentPlaying[sampleNumber].basePitchRate = playbackRate;
        
        console.log(`Sample ${sampleNumber} tempo updated: loop progress ${loopProgress/currentPlaying[sampleNumber].loopDuration} with speed ${speed}`);
    }

    function updateLongSampleLoop(sampleNumber) {
        if (!currentPlaying[sampleNumber].source || !currentPlaying[sampleNumber].isLongSample) return;
        const longLoopBeatDuration = 60 / longLoopTempo;
        const longLoopBarDuration = longLoopBeatDuration * 4;
        const desiredLoopDuration = longLoopBarDuration * longLoopLength;
        if (!isFinite(desiredLoopDuration) || desiredLoopDuration <= 0 || !isFinite(currentPlaying[sampleNumber].loopDuration) || currentPlaying[sampleNumber].loopDuration <= 0) {
            console.error("Invalid values for updating long sample:", {
                desiredLoopDuration: desiredLoopDuration,
                loopDuration: currentPlaying[sampleNumber].loopDuration,
                longLoopBarDuration: longLoopBarDuration,
                longLoopLength: longLoopLength
            });
            return;
        }
        const basePlaybackRate = currentPlaying[sampleNumber].loopDuration / desiredLoopDuration;
        const effects = currentPlaying[sampleNumber].effects || {};
        const individualTempo = effects.individualTempo || 1;
        const speed = effects.speed || 1;
        const playbackRate = basePlaybackRate * individualTempo * speed;
        if (!isFinite(playbackRate) || playbackRate <= 0) {
            console.error("Invalid playback rate for updating long sample:", playbackRate);
            return;
        }
        const currentTime = audioContext.currentTime;
        const elapsedTime = currentTime - currentPlaying[sampleNumber].loopStartTime;
        const loopProgress = elapsedTime * currentPlaying[sampleNumber].source.playbackRate.value % currentPlaying[sampleNumber].loopDuration;
        currentPlaying[sampleNumber].source.playbackRate.value = playbackRate;
        currentPlaying[sampleNumber].loopStartTime = currentTime - loopProgress / playbackRate;
        
        // Update base pitch rate for all active LFO pitch modulations
        currentPlaying[sampleNumber].basePitchRate = playbackRate;
        
        console.log(`Sample ${sampleNumber} long tempo updated: loop progress ${loopProgress/currentPlaying[sampleNumber].loopDuration} with individual tempo ${individualTempo} and speed ${speed}`);
    }

    function stopSample(sampleNumber) {
        if (currentPlaying[sampleNumber].scheduledTimeout) {
            clearTimeout(currentPlaying[sampleNumber].scheduledTimeout);
            currentPlaying[sampleNumber].scheduledTimeout = null;
        }
        if (currentPlaying[sampleNumber].source) {
            try {
                if (currentPlaying[sampleNumber].isScheduled) {
                    currentPlaying[sampleNumber].source.stop();
                }
                currentPlaying[sampleNumber].source.disconnect();
                currentPlaying[sampleNumber].source = null;
                currentPlaying[sampleNumber].gainNode = null;
                if (currentPlaying[sampleNumber].delayNode) {
                    currentPlaying[sampleNumber].delayNode.disconnect();
                    currentPlaying[sampleNumber].delayNode = null;
                }
                if (currentPlaying[sampleNumber].delayFeedbackNode) {
                    currentPlaying[sampleNumber].delayFeedbackNode.disconnect();
                    currentPlaying[sampleNumber].delayFeedbackNode = null;
                }
                if (currentPlaying[sampleNumber].reverbNode) {
                    currentPlaying[sampleNumber].reverbNode.disconnect();
                    currentPlaying[sampleNumber].reverbNode = null;
                }
                if (currentPlaying[sampleNumber].reverbMixNode) {
                    currentPlaying[sampleNumber].reverbMixNode.disconnect();
                    currentPlaying[sampleNumber].reverbMixNode = null;
                }
                if (currentPlaying[sampleNumber].wetPathNode) {
                    currentPlaying[sampleNumber].wetPathNode.disconnect();
                    currentPlaying[sampleNumber].wetPathNode = null;
                }
                if (currentPlaying[sampleNumber].dryPathNode) {
                    currentPlaying[sampleNumber].dryPathNode.disconnect();
                    currentPlaying[sampleNumber].dryPathNode = null;
                }
                if (currentPlaying[sampleNumber].outputNode) {
                    currentPlaying[sampleNumber].outputNode.disconnect();
                    currentPlaying[sampleNumber].outputNode = null;
                }
                if (currentPlaying[sampleNumber].eqLowNode) {
                    currentPlaying[sampleNumber].eqLowNode.disconnect();
                    currentPlaying[sampleNumber].eqLowNode = null;
                }
                if (currentPlaying[sampleNumber].eqLowMidNode) {
                    currentPlaying[sampleNumber].eqLowMidNode.disconnect();
                    currentPlaying[sampleNumber].eqLowMidNode = null;
                }
                if (currentPlaying[sampleNumber].eqMidNode) {
                    currentPlaying[sampleNumber].eqMidNode.disconnect();
                    currentPlaying[sampleNumber].eqMidNode = null;
                }
                if (currentPlaying[sampleNumber].eqHighMidNode) {
                    currentPlaying[sampleNumber].eqHighMidNode.disconnect();
                    currentPlaying[sampleNumber].eqHighMidNode = null;
                }
                if (currentPlaying[sampleNumber].eqHighMid2Node) {
                    currentPlaying[sampleNumber].eqHighMid2Node.disconnect();
                    currentPlaying[sampleNumber].eqHighMid2Node = null;
                }
                if (currentPlaying[sampleNumber].eqHighNode) {
                    currentPlaying[sampleNumber].eqHighNode.disconnect();
                    currentPlaying[sampleNumber].eqHighNode = null;
                }
                if (currentPlaying[sampleNumber].eqVeryHighNode) {
                    currentPlaying[sampleNumber].eqVeryHighNode.disconnect();
                    currentPlaying[sampleNumber].eqVeryHighNode = null;
                }
                // Disconnect LFO
                if (currentPlaying[sampleNumber].lfoNode) {
                    currentPlaying[sampleNumber].lfoNode.disconnect();
                    currentPlaying[sampleNumber].lfoNode = null;
                }
                if (currentPlaying[sampleNumber].lfoGainNode) {
                    currentPlaying[sampleNumber].lfoGainNode.disconnect();
                    currentPlaying[sampleNumber].lfoGainNode = null;
                }
                // Clear LFO update timeout
                if (currentPlaying[sampleNumber].lfoUpdateTimeout) {
                    clearTimeout(currentPlaying[sampleNumber].lfoUpdateTimeout);
                    currentPlaying[sampleNumber].lfoUpdateTimeout = null;
                }
                // Clear automation intervals
                if (currentPlaying[sampleNumber].automationIntervals) {
                    currentPlaying[sampleNumber].automationIntervals.forEach(interval => {
                        if (interval) clearInterval(interval);
                    });
                    currentPlaying[sampleNumber].automationIntervals = [null, null, null, null];
                }
                // Disconnect filter offset node if it exists
                if (currentPlaying[sampleNumber].lfoFilterOffsetNode) {
                    try {
                        currentPlaying[sampleNumber].lfoFilterOffsetNode.disconnect();
                        currentPlaying[sampleNumber].lfoFilterOffsetNode.stop();
                        currentPlaying[sampleNumber].lfoFilterOffsetNode = null;
                    } catch (e) {}
                }
                // Disconnect individual volume gain
                if (currentPlaying[sampleNumber].individualVolumeGain) {
                    currentPlaying[sampleNumber].individualVolumeGain.disconnect();
                    currentPlaying[sampleNumber].individualVolumeGain = null;
                }
                // Disconnect LFO filter
                if (currentPlaying[sampleNumber].lfoFilter) {
                    currentPlaying[sampleNumber].lfoFilter.disconnect();
                    currentPlaying[sampleNumber].lfoFilter = null;
                }
                // Disconnect LFO filter bypass
                if (currentPlaying[sampleNumber].lfoFilterBypass) {
                    currentPlaying[sampleNumber].lfoFilterBypass.disconnect();
                    currentPlaying[sampleNumber].lfoFilterBypass = null;
                }
            } catch (e) {
                console.warn("Error stopping audio source:", e);
                currentPlaying[sampleNumber].source = null;
                currentPlaying[sampleNumber].gainNode = null;
            }
        }
        currentPlaying[sampleNumber].isScheduled = false;
        currentPlaying[sampleNumber].barGridAligned = false;
    }

    function updateTiming() {
        if (!isFinite(tempo) || tempo <= 0) {
            console.error("Invalid tempo value:", tempo);
            return;
        }
        const effectiveTempo = tempo + highTempo;
        beatDuration = 60 / effectiveTempo;
        barDuration = beatDuration * 4;
    }

    function scheduler() {
        const currentTime = audioContext.currentTime;
        if (currentTime >= masterBarGrid.nextStartTime) {
            masterBarGrid.startTime = masterBarGrid.nextStartTime;
            masterBarGrid.nextStartTime = masterBarGrid.startTime + masterBarGrid.duration;
        }
        if (isPlaying) {
            timerId = setTimeout(scheduler, lookahead);
        }
    }

    function startRecording() {
        if (isRecording) return;
        recordingDestination = audioContext.createMediaStreamDestination();
        masterOutputNode.connect(recordingDestination);
        mediaRecorder = new MediaRecorder(recordingDestination.stream);
        recordedChunks = [];
        mediaRecorder.ondataavailable = function (event) {
            if (event.data.size > 0) {
                recordedChunks.push(event.data);
            }
        };
        mediaRecorder.onstop = function () {
            recordedBlob = new Blob(recordedChunks, {
                type: "audio/wav"
            });
            saveButton.style.display = "block";
        };
        mediaRecorder.start();
        isRecording = true;
        recordingStartTime = Date.now();
        recordButton.textContent = "Stop Recording";
        recordButton.classList.add("recording");
        saveButton.style.display = "block";
    }

    function stopRecording() {
        if (!isRecording) return;
        mediaRecorder.stop();
        isRecording = false;
        recordingDuration = (Date.now() - recordingStartTime) / 1e3;
        recordButton.textContent = "Record";
        recordButton.classList.remove("recording");
        if (recordingDestination) {
            masterOutputNode.disconnect(recordingDestination);
            recordingDestination = null;
        }
    }
    tempoSlider.addEventListener("input", function () {
        tempo = parseInt(this.value);
        if (!isFinite(tempo) || tempo <= 0) {
            console.error("Invalid tempo value from slider:", tempo);
            return;
        }
        tempoDisplay.textContent = `${tempo} BPM`;
        if (tempo >= 240) {
            highTempoSlider.disabled = false;
            highTempoSlider.style.opacity = "1";
        } else {
            highTempoSlider.disabled = true;
            highTempoSlider.style.opacity = "0.5";
            highTempo = 0;
            highTempoSlider.value = "240";
            highTempoDisplay.textContent = "240 BPM";
        }
        updateTiming();
        updateMasterBarGrid();
        for (let i = 1; i <= 100; i++) {
            if (currentPlaying[i].button && currentPlaying[i].buffer && currentPlaying[i].scheduledForNextBar && currentPlaying[i].isActive && currentPlaying[i].isScheduled && !currentPlaying[i].isLongSample) {
                updateDrumSampleTempo(i);
            }
        }
    });
    highTempoSlider.addEventListener("input", function () {
        highTempo = parseInt(this.value) - 240;
        if (!isFinite(highTempo) || highTempo < 0) {
            console.error("Invalid high tempo value from slider:", highTempo);
            return;
        }
        highTempoDisplay.textContent = `${parseInt(this.value)} BPM`;
        updateTiming();
        updateMasterBarGrid();
        for (let i = 1; i <= 100; i++) {
            if (currentPlaying[i].button && currentPlaying[i].buffer && currentPlaying[i].scheduledForNextBar && currentPlaying[i].isActive && currentPlaying[i].isScheduled && !currentPlaying[i].isLongSample) {
                updateDrumSampleTempo(i);
            }
        }
    });
    longLoopTempoSlider.addEventListener("input", function () {
        longLoopTempo = parseInt(this.value);
        if (!isFinite(longLoopTempo) || longLoopTempo <= 0) {
            console.error("Invalid long loop tempo value from slider:", longLoopTempo);
            return;
        }
        longLoopTempoDisplay.textContent = `${longLoopTempo} BPM`;
        for (let i = 1; i <= 100; i++) {
            if (currentPlaying[i].button && currentPlaying[i].buffer && currentPlaying[i].scheduledForNextBar && currentPlaying[i].isActive && currentPlaying[i].isScheduled && currentPlaying[i].isLongSample) {
                updateLongSampleTempo(i);
            }
        }
    });

    // Bar Counter Functions
    function startBarCounter() {
        barCounterStartTime = audioContext.currentTime;
        lastCounterUpdateTime = audioContext.currentTime;
        totalBeatsElapsed = 0;
        currentBar = 0;
        currentBeat = 0;
        updateBarCounterDisplay();
        
        // Update counter every 50ms for smooth display
        if (barCounterInterval) {
            clearInterval(barCounterInterval);
        }
        
        barCounterInterval = setInterval(() => {
            if (!isPlaying) {
                clearInterval(barCounterInterval);
                return;
            }
            
            const now = audioContext.currentTime;
            const deltaTime = now - lastCounterUpdateTime;
            lastCounterUpdateTime = now;
            
            // Calculate beats elapsed since last update using current tempo
            // Combine base tempo and high tempo (for tempos above 240)
            const actualTempo = tempo + highTempo;
            const beatsPerSecond = actualTempo / 60;
            const beatsThisUpdate = deltaTime * beatsPerSecond;
            
            // Add to total beats (this accumulates regardless of tempo changes)
            totalBeatsElapsed += beatsThisUpdate;
            
            // Subtract 4 beats (1 bar) for the initial delay
            const adjustedBeats = totalBeatsElapsed - 4;
            
            if (adjustedBeats < 0) {
                // Still in the delay period
                currentBar = 0;
                currentBeat = 0;
            } else {
                // Calculate bar and beat (4 beats per bar)
                currentBar = Math.floor(adjustedBeats / 4) + 1;
                currentBeat = Math.floor(adjustedBeats % 4) + 1;
            }
            
            updateBarCounterDisplay();
        }, 50);
    }
    
    function stopBarCounter() {
        if (barCounterInterval) {
            clearInterval(barCounterInterval);
            barCounterInterval = null;
        }
        totalBeatsElapsed = 0;
        lastCounterUpdateTime = 0;
        currentBar = 0;
        currentBeat = 0;
        updateBarCounterDisplay();
    }
    
    function updateBarCounterDisplay() {
        const barCounterDisplay = document.getElementById('barCounterDisplay');
        if (barCounterDisplay) {
            barCounterDisplay.textContent = `${currentBar}.${currentBeat}`;
        }
    }

    playButton.addEventListener("click", function () {
        resumeAudioContext();
        if (!isPlaying) {
            isPlaying = true;
            playButton.textContent = "Stop";
            playButton.classList.add("playing");
            if (audioContext.state === "suspended") {
                audioContext.resume()["catch"](e => console.error("Error resuming audio context:", e));
            }
            const currentTime = audioContext.currentTime;
            masterBarGrid.startTime = currentTime;
            masterBarGrid.duration = barDuration;
            masterBarGrid.nextStartTime = masterBarGrid.startTime + masterBarGrid.duration;
            
            // Start bar counter
            startBarCounter();
            
            for (let i = 1; i <= 100; i++) {
                if (currentPlaying[i].button && currentPlaying[i].buffer && currentPlaying[i].scheduledForNextBar && currentPlaying[i].isActive) {
                    if (currentPlaying[i].scheduledTimeout) {
                        clearTimeout(currentPlaying[i].scheduledTimeout);
                        currentPlaying[i].scheduledTimeout = null;
                    }
                    scheduleSampleForNextBar(i);
                }
            }
            scheduler();
        } else {
            isPlaying = false;
            playButton.textContent = "Play";
            playButton.classList.remove("playing");
            clearTimeout(timerId);
            
            // Stop bar counter
            stopBarCounter();
            
            for (let i = 1; i <= 100; i++) {
                stopSample(i);
            }
        }
    });
    recordButton.addEventListener("click", function () {
        if (isRecording) {
            stopRecording();
        } else {
            startRecording();
        }
    });
    saveButton.addEventListener("click", function () {
        if (recordedBlob) {
            // Enhanced save with offline storage
            const timestamp = new Date().toISOString().slice(0,19).replace(/:/g,"-");
            const fileName = `psychological-studio-recording-${timestamp}.wav`;
            
            // Save to offline storage
            offlineStorage.saveAudioData(fileName, recordedBlob).then(() => {
                console.log('Recording saved offline');
            }).catch(error => {
                console.error('Failed to save recording offline:', error);
            });
            
            // Also provide download option
            const url = URL.createObjectURL(recordedBlob);
            const a = document.createElement("a");
            a.href = url;
            a.download = fileName;
            a.click();
            URL.revokeObjectURL(url);
        }
    });


    // Offline/Online Status Management
    function initializeOfflineStatus() {
        const offlineIndicator = document.getElementById('offlineIndicator');
        
        function updateOnlineStatus() {
            if (navigator.onLine) {
                offlineIndicator.style.display = 'none';
            } else {
                offlineIndicator.style.display = 'flex';
            }
        }

        // Listen for online/offline events
        window.addEventListener('online', updateOnlineStatus);
        window.addEventListener('offline', updateOnlineStatus);
        
        // Initial status check
        updateOnlineStatus();
        
        // Periodic status check (in case events don't fire)
        setInterval(updateOnlineStatus, 5000);
    }

    // Initialize offline status monitoring
    initializeOfflineStatus();

    // Sample folder management
    let currentSampleFolder = 'mykicks'; // Default folder
    
    // Initialize folder selection
    function initializeFolderSelection() {
        const selectFolderBtn = document.getElementById('selectFolderBtn');
        const currentFolderDisplay = document.getElementById('currentFolderDisplay');
        
        if (!selectFolderBtn || !currentFolderDisplay) {
            console.error('Folder selection elements not found');
            return;
        }
        
        // Update display
        function updateFolderDisplay() {
            currentFolderDisplay.textContent = `Current: ${currentSampleFolder}`;
        }
        
        // Load folder from localStorage if available
        const savedFolder = localStorage.getItem('psychologicalStudioSampleFolder');
        if (savedFolder) {
            currentSampleFolder = savedFolder;
            updateFolderDisplay();
        }
        
        // Folder selection handler
        selectFolderBtn.addEventListener('click', function() {
            const folderName = prompt('Enter sample folder name (e.g., mykicks, drums, bass, etc.):', currentSampleFolder);
            if (folderName && folderName.trim()) {
                const newFolder = folderName.trim();
                
                // Validate folder exists by trying to load a sample
                const testAudio = new Audio();
                testAudio.oncanplaythrough = function() {
                    // Folder exists, update current folder
                    currentSampleFolder = newFolder;
                    localStorage.setItem('psychologicalStudioSampleFolder', newFolder);
                    updateFolderDisplay();
                    showNotification(`Sample folder changed to: ${newFolder}`);
                    
                    // Cache new folder samples for offline use
                    cacheFolderSamples(newFolder);
                    
                    // Reload all current samples with new folder
                    reloadAllSamples();
                };
                testAudio.onerror = function() {
                    showNotification(`Folder "${newFolder}" not found. Please check the folder name.`);
                };
                testAudio.src = `./${newFolder}/1.wav`;
            }
        });
        
        updateFolderDisplay();
    }
    
    // Reload all currently loaded samples with new folder
    function reloadAllSamples() {
        for (let i = 1; i <= 100; i++) {
            if (currentPlaying[i] && currentPlaying[i].button) {
                // Reload the sample with new folder
                loadSample(i);
            }
        }
    }
    
    // Cache all samples from a folder for offline use
    function cacheFolderSamples(folderName) {
        if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
            // Generate list of all sample files in the folder
            const sampleFiles = [];
            for (let i = 1; i <= 100; i++) {
                sampleFiles.push(`./${folderName}/${i}.wav`);
            }
            
            // Send message to service worker to cache the files
            navigator.serviceWorker.controller.postMessage({
                type: 'CACHE_AUDIO',
                files: sampleFiles
            });
            
            showNotification(`Caching ${folderName} samples for offline use...`);
        }
    }
    
    // Initialize folder selection
    initializeFolderSelection();

    // Theme management
    let currentTheme = 'default';
    
    const themes = {
        default: {
            background: '#1a1a2e',
            controlsBg: '#1d1d1d',
            buttonBg: '#4a4a4a',
            buttonHover: '#5a5a5a',
            buttonActive: '#3a3a3a',
            accent: '#007bff',
            text: '#f0f0f0',
            border: '#444'
        },
        dark: {
            background: '#0a0a0a',
            controlsBg: '#111111',
            buttonBg: '#333333',
            buttonHover: '#444444',
            buttonActive: '#222222',
            accent: '#666666',
            text: '#cccccc',
            border: '#333'
        },
        blue: {
            background: '#0f1419',
            controlsBg: '#1a2332',
            buttonBg: '#2c3e50',
            buttonHover: '#34495e',
            buttonActive: '#1a252f',
            accent: '#3498db',
            text: '#ecf0f1',
            border: '#34495e'
        },
        green: {
            background: '#0f1a0f',
            controlsBg: '#1a2f1a',
            buttonBg: '#2c5f2c',
            buttonHover: '#3d7a3d',
            buttonActive: '#1f4a1f',
            accent: '#27ae60',
            text: '#d5f4e6',
            border: '#2c5f2c'
        },
        purple: {
            background: '#1a0f1a',
            controlsBg: '#2f1a2f',
            buttonBg: '#5f2c5f',
            buttonHover: '#7a3d7a',
            buttonActive: '#4a1f4a',
            accent: '#9b59b6',
            text: '#f4d5f4',
            border: '#5f2c5f'
        },
        red: {
            background: '#1a0f0f',
            controlsBg: '#2f1a1a',
            buttonBg: '#5f2c2c',
            buttonHover: '#7a3d3d',
            buttonActive: '#4a1f1f',
            accent: '#e74c3c',
            text: '#f4d5d5',
            border: '#5f2c2c'
        },
        orange: {
            background: '#1a140f',
            controlsBg: '#2f241a',
            buttonBg: '#5f4a2c',
            buttonHover: '#7a623d',
            buttonActive: '#4a3d1f',
            accent: '#e67e22',
            text: '#f4e6d5',
            border: '#5f4a2c'
        },
        pink: {
            background: '#1a0f14',
            controlsBg: '#2f1a24',
            buttonBg: '#5f2c4a',
            buttonHover: '#7a3d63',
            buttonActive: '#4a1f35',
            accent: '#e91e63',
            text: '#f4d5e1',
            border: '#5f2c4a'
        },
        cyan: {
            background: '#0f1a1a',
            controlsBg: '#1a2f2f',
            buttonBg: '#2c5f5f',
            buttonHover: '#3d7a7a',
            buttonActive: '#1f4a4a',
            accent: '#00bcd4',
            text: '#d5f4f4',
            border: '#2c5f5f'
        }
    };
    
    function applyTheme(themeName) {
        const theme = themes[themeName];
        if (!theme) return;
        
        // Apply to body
        document.body.style.backgroundColor = theme.background;
        
        // Add/remove theme class for conditional styling
        if (themeName === 'default') {
            document.body.classList.add('theme-default');
        } else {
            document.body.classList.remove('theme-default');
        }
        
        // Apply to controls panel
        const controlsPanel = document.querySelector('.controls-panel');
        if (controlsPanel) {
            controlsPanel.style.backgroundColor = theme.controlsBg;
        }
        
        // Apply to buttons
        const buttons = document.querySelectorAll('.audio-button, .folder-button, .theme-button, .loop-button, .save-button');
        buttons.forEach(btn => {
            // Handle group buttons specially for default theme
            if (themeName === 'default' && (btn.classList.contains('group-0') || btn.classList.contains('group-1') || btn.classList.contains('group-2') ||
                btn.classList.contains('group-3') || btn.classList.contains('group-4') || btn.classList.contains('group-5') ||
                btn.classList.contains('group-6') || btn.classList.contains('group-7') || btn.classList.contains('group-8') ||
                btn.classList.contains('group-9'))) {
                // Set original group colors for default theme
                const groupColors = {
                    'group-0': '#e53935',
                    'group-1': '#fb8c00',
                    'group-2': '#fdd835',
                    'group-3': '#43a047',
                    'group-4': '#00acc1',
                    'group-5': '#039be5',
                    'group-6': '#5e35b1',
                    'group-7': '#8e24aa',
                    'group-8': '#d81b60',
                    'group-9': '#546e7a'
                };
                for (const [className, color] of Object.entries(groupColors)) {
                    if (btn.classList.contains(className)) {
                        btn.style.backgroundColor = color;
                        break;
                    }
                }
                btn.style.borderColor = theme.border;
                btn.style.color = '#000000'; // Keep audio button numbers black
                return;
            }
            if (btn.classList.contains('audio-button')) {
                btn.style.backgroundColor = theme.buttonBg;
                btn.style.borderColor = theme.border;
                btn.style.color = '#000000'; // Keep audio button numbers black
            } else {
                btn.style.backgroundColor = theme.buttonBg;
                btn.style.borderColor = theme.border;
                btn.style.color = theme.text;
            }
        });
        
        // Preserve original play and record button colors
        const playButton = document.querySelector('.play-button');
        if (playButton) {
            playButton.style.backgroundColor = '#930018';
            playButton.style.color = '#000000';
        }
        const recordButton = document.querySelector('.record-button');
        if (recordButton) {
            recordButton.style.backgroundColor = '#91d32f';
            recordButton.style.color = '#000000';
        }
        
        // Apply to sections
        const sections = document.querySelectorAll('.controls-section, .folder-controls, .theme-controls');
        sections.forEach(section => {
            section.style.backgroundColor = theme.controlsBg;
            section.style.borderColor = theme.border;
        });
        
        // Apply to labels and text
        const labels = document.querySelectorAll('label, .tempo-display, .current-folder, .section-title');
        labels.forEach(label => {
            label.style.color = theme.text;
        });
        
        // Apply to active theme button
        const themeButtons = document.querySelectorAll('.theme-button');
        themeButtons.forEach(btn => {
            btn.classList.remove('active');
            if (btn.dataset.theme === themeName) {
                btn.classList.add('active');
                btn.style.backgroundColor = theme.accent;
                btn.style.borderColor = theme.accent;
            }
        });
        
        // Save theme preference
        localStorage.setItem('psychologicalStudioTheme', themeName);
    }
    
    function initializeThemeSelection() {
        const themeButtons = document.querySelectorAll('.theme-button');
        const themeToggle = document.getElementById('themeToggle');
        const themeButtonsContainer = document.getElementById('themeButtonsContainer');
        
        // Load saved theme
        const savedTheme = localStorage.getItem('psychologicalStudioTheme') || 'default';
        currentTheme = savedTheme;
        applyTheme(savedTheme);
        
        // Add event listeners
        themeButtons.forEach(button => {
            button.addEventListener('click', function() {
                const themeName = this.dataset.theme;
                currentTheme = themeName;
                applyTheme(themeName);
                showNotification(`Theme changed to: ${themeName}`);
            });
        });
        
        // Add theme toggle functionality
        if (themeToggle && themeButtonsContainer) {
            themeToggle.addEventListener('change', function() {
                if (this.checked) {
                    themeButtonsContainer.classList.add('visible');
                } else {
                    themeButtonsContainer.classList.remove('visible');
                }
            });
        }
    }
    
    // Initialize theme selection
    initializeThemeSelection();


    // Disable Developer Tools and Right-Click
    function disableDevTools() {
        // Disable right-click context menu
        document.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            return false;
        });

        // Disable F12, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+U
        document.addEventListener('keydown', function(e) {
            // F12
            if (e.keyCode === 123) {
                e.preventDefault();
                return false;
            }
            // Ctrl+Shift+I (DevTools)
            if (e.ctrlKey && e.shiftKey && e.keyCode === 73) {
                e.preventDefault();
                return false;
            }
            // Ctrl+Shift+J (Console)
            if (e.ctrlKey && e.shiftKey && e.keyCode === 74) {
                e.preventDefault();
                return false;
            }
            // Ctrl+U (View Source)
            if (e.ctrlKey && e.keyCode === 85) {
                e.preventDefault();
                return false;
            }
            // Ctrl+Shift+C (Element Inspector)
            if (e.ctrlKey && e.shiftKey && e.keyCode === 67) {
                e.preventDefault();
                return false;
            }
        });

        // Disable text selection
        document.addEventListener('selectstart', function(e) {
            e.preventDefault();
            return false;
        });

        // Disable drag and drop
        document.addEventListener('dragstart', function(e) {
            e.preventDefault();
            return false;
        });

        // Console warning
        console.clear();
        console.log('%c⚠️ Developer Tools Disabled', 'color: red; font-size: 20px; font-weight: bold;');
        console.log('%cThis is a professional application. Please do not attempt to access developer tools.', 'color: red; font-size: 14px;');

        // Disable console methods
        const noop = function() {};
        console.log = noop;
        console.warn = noop;
        console.error = noop;
        console.info = noop;
        console.debug = noop;
        console.trace = noop;
        console.table = noop;
        console.group = noop;
        console.groupEnd = noop;
        console.time = noop;
        console.timeEnd = noop;
        console.count = noop;
        console.assert = noop;
        console.clear = noop;
    }

    // Initialize dev tools disabling
    disableDevTools();

    // Piano roll zoom and scroll functionality
    let pianoRollZoomLevel = 1.0;
    let pianoRollScrollX = 0;
    
    function updatePianoRollZoomDisplay() {
        document.getElementById("zoom-level-display").textContent = `${Math.round(pianoRollZoomLevel * 100)}%`;
    }
    
    function updatePianoRollCellWidth() {
        const grid = document.querySelector(".piano-roll-grid");
        if (!grid) return;
        
        // Preserve current scroll position
        const scrollable = document.querySelector(".piano-roll-scrollable");
        const barNumbersWrapper = document.querySelector(".piano-roll-bar-numbers-wrapper");
        const barNumbers = document.querySelector(".piano-roll-bar-numbers");
        const currentScrollLeft = scrollable ? scrollable.scrollLeft : 0;
        
        const baseCellWidth = 20; // Base width in pixels
        const cellWidth = baseCellWidth * pianoRollZoomLevel;
        
        // Update virtualization settings
        pianoRollVirtualization.colWidth = cellWidth;
        pianoRollVirtualization.rowHeight = 20; // Keep row height constant
        
        // Update CSS custom property for cell width
        document.documentElement.style.setProperty('--piano-roll-cell-width', `${cellWidth}px`);
        
        if (pianoRollVirtualization.enabled) {
            // For virtualized grid, update container dimensions
            const gridContainer = document.querySelector(".piano-roll-grid-container");
            if (gridContainer) {
                gridContainer.style.width = `${pianoRollVirtualization.totalCols * cellWidth}px`;
            }
            
            // Re-render virtualized grid
            calculateVisibleRange();
            renderVirtualizedGrid();
        } else {
            // Traditional grid update
            const gridWidth = document.getElementById("grid-size-display").textContent;
            grid.style.gridTemplateColumns = `repeat(${gridWidth}, ${cellWidth}px)`;
            
            // Update the grid container width to accommodate all cells
            const gridContainer = document.querySelector(".piano-roll-grid-container");
            if (gridContainer) {
                gridContainer.style.width = `${gridWidth * cellWidth}px`;
            }
        }
        
        // Update the bar numbers container width to match
        if (barNumbers) {
            const gridWidth = pianoRollVirtualization.enabled ? pianoRollVirtualization.totalCols : document.getElementById("grid-size-display").textContent;
            barNumbers.style.width = `${gridWidth * cellWidth}px`;
            
            // Update individual bar number widths to match zoom level
            const barNumberElements = barNumbers.querySelectorAll(".piano-roll-bar-number");
            const stepsPerBeat = 4; // 4 steps per beat (16th notes)
            barNumberElements.forEach((barElement) => {
                // Each bar number represents 4 cells (stepsPerBeat)
                const newWidth = `${stepsPerBeat * cellWidth}px`;
                const newFontSize = Math.max(8, 10 * pianoRollZoomLevel); // Scale font size with zoom, minimum 8px
                barElement.style.width = newWidth;
                barElement.style.fontSize = `${newFontSize}px`;
            });
        }
        
        // Restore scroll position after layout update
        if (scrollable) {
            // Use requestAnimationFrame to ensure layout is complete
            requestAnimationFrame(() => {
                scrollable.scrollLeft = currentScrollLeft;
                if (barNumbersWrapper) {
                    barNumbersWrapper.scrollLeft = currentScrollLeft;
                }
            });
        }
    }

    function setupPianoRollZoomControls() {
        const zoomDecreaseBtn = document.getElementById("zoom-decrease");
        const zoomIncreaseBtn = document.getElementById("zoom-increase");
        const zoomResetBtn = document.getElementById("zoom-reset");
        
        if (zoomDecreaseBtn) {
            zoomDecreaseBtn.addEventListener("click", function() {
                if (pianoRollZoomLevel > 0.5) {
                    pianoRollZoomLevel -= 0.25;
                    updatePianoRollZoomDisplay();
                    updatePianoRollCellWidth();
                }
            });
        }
        
        if (zoomIncreaseBtn) {
            zoomIncreaseBtn.addEventListener("click", function() {
                if (pianoRollZoomLevel < 4.0) {
                    pianoRollZoomLevel += 0.25;
                    updatePianoRollZoomDisplay();
                    updatePianoRollCellWidth();
                }
            });
        }
        
        if (zoomResetBtn) {
            zoomResetBtn.addEventListener("click", function() {
                pianoRollZoomLevel = 1.0;
                updatePianoRollZoomDisplay();
                updatePianoRollCellWidth();
                
                // Reset scroll position
                const scrollable = document.querySelector(".piano-roll-scrollable");
                if (scrollable) {
                    scrollable.scrollLeft = 0;
                }
            });
        }
    }

    // Piano roll virtualization functions
    function calculateVisibleRange() {
        const virt = pianoRollVirtualization;
        virt.startRow = Math.floor(virt.scrollTop / virt.rowHeight);
        virt.endRow = Math.min(virt.startRow + Math.ceil(virt.containerHeight / virt.rowHeight) + 2, virt.totalRows);
        virt.startCol = Math.floor(virt.scrollLeft / virt.colWidth);
        virt.endCol = Math.min(virt.startCol + Math.ceil(virt.containerWidth / virt.colWidth) + 2, virt.totalCols);
    }
    
    function renderVirtualizedGrid() {
        if (!pianoRollVirtualization.enabled) return;
        
        const virt = pianoRollVirtualization;
        const pianoRollGrid = document.querySelector(".piano-roll-grid");
        if (!pianoRollGrid) return;
        
        // Clear existing cells
        pianoRollGrid.innerHTML = "";
        
        // Create document fragment for better performance
        const fragment = document.createDocumentFragment();
        
        // Pre-calculate note positions for better performance
        const data = pianoRollData[currentSampleForPopup];
        const noteMap = new Map();
        if (data && data.notes) {
            data.notes.forEach(note => {
                for (let c = note.col; c < note.col + (note.length || 1); c++) {
                    const key = `${note.row}-${c}`;
                    noteMap.set(key, { isStart: c === note.col, isPart: true });
                }
            });
        }
        
        // Only render visible cells
        for (let row = virt.startRow; row < virt.endRow; row++) {
            for (let col = virt.startCol; col < virt.endCol; col++) {
                const cell = document.createElement("div");
                cell.className = "piano-roll-cell";
                
                // Optimize class additions
                if (col % 4 === 0) cell.classList.add("bar-start");
                if ((col + 1) % 4 === 0) cell.classList.add("bar-end");
                
                cell.dataset.row = row;
                cell.dataset.col = col;
                
                // Position the cell absolutely within the virtualized container
                cell.style.position = "absolute";
                cell.style.top = `${row * virt.rowHeight}px`;
                cell.style.left = `${col * virt.colWidth}px`;
                cell.style.width = `${virt.colWidth}px`;
                cell.style.height = `${virt.rowHeight}px`;
                
                // Use pre-calculated note map for better performance
                const noteInfo = noteMap.get(`${row}-${col}`);
                if (noteInfo) {
                    cell.classList.add("active");
                    if (!noteInfo.isStart) {
                        cell.classList.add("note-long");
                    }
                }
                
                fragment.appendChild(cell);
            }
        }
        
        // Single DOM append for better performance
        pianoRollGrid.appendChild(fragment);
        
        // Update grid container size to maintain scrollbar behavior
        pianoRollGrid.style.width = `${virt.totalCols * virt.colWidth}px`;
        pianoRollGrid.style.height = `${virt.totalRows * virt.rowHeight}px`;
    }
    
    function throttledScrollHandler() {
        if (pianoRollVirtualization.scrollThrottleTimer) {
            clearTimeout(pianoRollVirtualization.scrollThrottleTimer);
        }
        
        pianoRollVirtualization.scrollThrottleTimer = setTimeout(() => {
            const scrollable = document.querySelector(".piano-roll-scrollable");
            if (scrollable) {
                pianoRollVirtualization.scrollTop = scrollable.scrollTop;
                pianoRollVirtualization.scrollLeft = scrollable.scrollLeft;
                calculateVisibleRange();
                renderVirtualizedGrid();
            }
        }, 16); // ~60fps throttling
    }
    
    function setupPianoRollScrollSync() {
        const scrollable = document.querySelector(".piano-roll-scrollable");
        const barNumbersWrapper = document.querySelector(".piano-roll-bar-numbers-wrapper");
        
        if (!scrollable || !barNumbersWrapper) {
            console.log("Piano roll scroll sync: Elements not found", { scrollable, barNumbersWrapper });
            return;
        }
        
        console.log("Setting up piano roll scroll sync");
        
        // Initialize virtualization container dimensions
        const pianoRollGrid = document.querySelector(".piano-roll-grid");
        if (pianoRollGrid && pianoRollVirtualization.enabled) {
            pianoRollVirtualization.containerHeight = scrollable.clientHeight;
            pianoRollVirtualization.containerWidth = scrollable.clientWidth;
            pianoRollGrid.style.position = "relative";
            pianoRollGrid.style.overflow = "hidden";
        }
        
        // Use passive event listeners for better mobile performance
        const scrollOptions = { passive: true };
        
        // Sync bar numbers scroll with grid scroll
        scrollable.addEventListener("scroll", function() {
            if (pianoRollVirtualization.enabled) {
                throttledScrollHandler();
            } else {
                barNumbersWrapper.scrollLeft = scrollable.scrollLeft;
            }
        }, scrollOptions);
        
        // Sync grid scroll with bar numbers scroll
        barNumbersWrapper.addEventListener("scroll", function() {
            scrollable.scrollLeft = barNumbersWrapper.scrollLeft;
        }, scrollOptions);
    }

    function initPianoRoll() {
        if (!currentSampleForPopup) return;
        const isLongSample = currentSampleForPopup > 60;
        if (!pianoRollData[currentSampleForPopup]) {
            pianoRollData[currentSampleForPopup] = {
                notes: [],
                soundSource: "sounddesign",
                gridWidth: isLongSample ? 32 : 16,
                gridHeight: 84,
                scrollX: 0,
                scrollY: 0,
                sampleRange: {
                    start: 0,
                    end: 100
                },
                filters: {
                    lowShelf: 0,
                    highShelf: 0,
                    lowMid: 0,
                    mid: 0,
                    highMid: 0,
                    delay: {
                        time: 0,
                        feedback: 0
                    }
                },
                isEnabled: false
            };
        }
        
        // Initialize zoom controls
        setupPianoRollZoomControls();
        
        // Initialize scroll synchronization
        setupPianoRollScrollSync();
        
        // Set initial zoom level
        pianoRollZoomLevel = 1.0;
        updatePianoRollZoomDisplay();
        
        const noteLengths = [
            { value: 1, display: "1/16" },
            { value: 2, display: "1/8" },
            { value: 4, display: "1/4" },
            { value: 8, display: "1/2" },
            { value: 16, display: "1/1" },
            { value: 32, display: "2 bars" },
            { value: 64, display: "4 bars" }
        ];

        const pianoKeys = document.querySelector(".piano-keys");
        const pianoRollGrid = document.querySelector(".piano-roll-grid");
        const pianoRollBarNumbers = document.querySelector(".piano-roll-bar-numbers");
        const soundSourceSelect = document.getElementById("piano-roll-sound-source");
        const noteLengthDecreaseBtn = document.getElementById("note-length-decrease");
        const noteLengthIncreaseBtn = document.getElementById("note-length-increase");
        const noteLengthDisplay = document.getElementById("note-length-display");
        const gridSizeDecreaseBtn = document.getElementById("grid-size-decrease");
        const gridSizeIncreaseBtn = document.getElementById("grid-size-increase");
        const gridSizeDisplay = document.getElementById("grid-size-display");
        
        // Clear existing content and remove old event listeners by cloning the grid
        pianoKeys.innerHTML = "";
        pianoRollBarNumbers.innerHTML = "";
        
        // Clone the grid to remove all event listeners
        const newPianoRollGrid = pianoRollGrid.cloneNode(false);
        pianoRollGrid.parentNode.replaceChild(newPianoRollGrid, pianoRollGrid);
        
        // IMPORTANT: Remove the click handler flag so we can re-attach the event listener
        newPianoRollGrid.removeAttribute('data-click-handler-attached');
        
        // Update reference to the new grid
        const updatedPianoRollGrid = document.querySelector(".piano-roll-grid");
        
        const data = pianoRollData[currentSampleForPopup];
        
        // Set the grid width and update cell width
        gridSizeDisplay.textContent = data.gridWidth;
        updatePianoRollCellWidth();
        
        // Create bar/beat labels based on actual grid size
        const stepsPerBeat = 4; // 4 steps per beat (16th notes)
        const totalBeats = Math.ceil(data.gridWidth / stepsPerBeat);
        for (let beatIdx = 0; beatIdx < totalBeats; beatIdx++) {
            const barNumber = Math.floor(beatIdx / 4) + 1;
            const beatNumber = (beatIdx % 4) + 1;
            const beatDiv = document.createElement("div");
            beatDiv.className = "piano-roll-bar-number";
            if (beatNumber === 1) beatDiv.classList.add("bar-start");
            
            // Calculate width based on actual cell width and zoom
            const baseCellWidth = 20;
            const cellWidth = baseCellWidth * pianoRollZoomLevel;
            const fontSize = Math.max(8, 10 * pianoRollZoomLevel); // Scale font size with zoom, minimum 8px
            beatDiv.style.width = `${stepsPerBeat * cellWidth}px`;
            beatDiv.style.fontSize = `${fontSize}px`;
            beatDiv.style.display = "flex";
            beatDiv.style.justifyContent = "center";
            
            const span = document.createElement("span");
            span.textContent = `${barNumber}.${beatNumber}`;
            beatDiv.appendChild(span);
            pianoRollBarNumbers.appendChild(beatDiv);
        }
        
        const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const octaves = 7;
        for (let octave = octaves - 1; octave >= 0; octave--) {
            for (let i = 0; i < 12; i++) {
                const key = document.createElement("div");
                key.className = `piano-key ${noteNames[i].includes("#")?"black":"white"}`;
                key.textContent = noteNames[i] + octave;
                key.dataset.note = noteNames[i];
                key.dataset.octave = octave;
                
                // Fix: Make sure the event listener is properly attached
                key.addEventListener("click", function () {
                    // Resume audio context if suspended
                    if (audioContext.state === "suspended") {
                        audioContext.resume().then(() => {
                            playPianoKey(noteNames[i], octave);
                        }).catch(e => console.error("Error resuming audio context:", e));
                    } else {
                        playPianoKey(noteNames[i], octave);
                    }
                });
                
                pianoKeys.appendChild(key);
            }
        }
        // Update virtualization settings based on current data
        pianoRollVirtualization.totalRows = data.gridHeight;
        pianoRollVirtualization.totalCols = data.gridWidth;
        
        // Use virtualization if enabled, otherwise use traditional rendering
        if (pianoRollVirtualization.enabled) {
            // Initialize virtualization
            calculateVisibleRange();
            renderVirtualizedGrid();
        } else {
            // Traditional grid creation for desktop
            const fragment = document.createDocumentFragment();
            
            // Clear cell cache for rebuild
            pianoRollCellCache = {};
            
            // Pre-calculate note positions for better performance
            const noteMap = new Map();
            data.notes.forEach(note => {
                for (let c = note.col; c < note.col + (note.length || 1); c++) {
                    const key = `${note.row}-${c}`;
                    noteMap.set(key, { isStart: c === note.col, isPart: true });
                }
            });
            
            for (let row = data.gridHeight - 1; row >= 0; row--) {
                for (let col = 0; col < data.gridWidth; col++) {
                    const cell = document.createElement("div");
                    cell.className = "piano-roll-cell";
                    
                    // Optimize class additions
                    if (col % 4 === 0) cell.classList.add("bar-start");
                    if ((col + 1) % 4 === 0) cell.classList.add("bar-end");
                    
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    // Use pre-calculated note map for better performance
                    const noteInfo = noteMap.get(`${row}-${col}`);
                    if (noteInfo) {
                        cell.classList.add("active");
                        if (!noteInfo.isStart) {
                            cell.classList.add("note-long");
                        }
                    }
                    
                    // Store row/col data for event delegation
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    // PERFORMANCE: Cache cell reference for instant access
                    const cacheKey = `${row}-${col}`;
                    pianoRollCellCache[cacheKey] = cell;
                    
                    fragment.appendChild(cell);
                }
            }
            
            // Single DOM append for better performance
            updatedPianoRollGrid.appendChild(fragment);
        }
        
        // DON'T add click listener here - it's handled globally below
        
        soundSourceSelect.value = data.soundSource;
        // Set note length display
        const currentNoteLength = noteLengths.find(nl => nl.value === pianoRollNoteLength);
        if (currentNoteLength) {
            noteLengthDisplay.textContent = currentNoteLength.display;
        }
        // Note length controls
        if (noteLengthDecreaseBtn) {
            noteLengthDecreaseBtn.onclick = function() {
                const currentIndex = noteLengths.findIndex(nl => nl.value === pianoRollNoteLength);
                if (currentIndex > 0) {
                    pianoRollNoteLength = noteLengths[currentIndex - 1].value;
                    noteLengthDisplay.textContent = noteLengths[currentIndex - 1].display;
                }
            };
        }
        if (noteLengthIncreaseBtn) {
            noteLengthIncreaseBtn.onclick = function() {
                const currentIndex = noteLengths.findIndex(nl => nl.value === pianoRollNoteLength);
                if (currentIndex < noteLengths.length - 1) {
                    pianoRollNoteLength = noteLengths[currentIndex + 1].value;
                    noteLengthDisplay.textContent = noteLengths[currentIndex + 1].display;
                }
            };
        }
        // Initialize Sound Design controls with saved values
        const sd = document.querySelector('.sound-design-controls');
        const ensureSD = () => {
            if (!pianoRollData[currentSampleForPopup].soundDesign) {
                pianoRollData[currentSampleForPopup].soundDesign = { osc1:{wave:'sine',detune:0,level:50}, osc2:{wave:'sawtooth',detune:0,level:50}, filter:{type:'lowpass',cutoff:2000,resonance:0}, envelope:{attack:10,decay:100,sustain:70,release:200} };
            }
        };
        ensureSD();
        if (sd) {
            const s = pianoRollData[currentSampleForPopup].soundDesign;
            sd.querySelector('#sd-osc1-wave').value = s.osc1.wave;
            sd.querySelector('#sd-osc1-level').value = s.osc1.level; sd.querySelector('#sd-osc1-level-val').textContent = s.osc1.level + '%';
            sd.querySelector('#sd-osc1-detune').value = s.osc1.detune; sd.querySelector('#sd-osc1-detune-val').textContent = s.osc1.detune + 'c';
            sd.querySelector('#sd-osc2-wave').value = s.osc2.wave;
            sd.querySelector('#sd-osc2-level').value = s.osc2.level; sd.querySelector('#sd-osc2-level-val').textContent = s.osc2.level + '%';
            sd.querySelector('#sd-osc2-detune').value = s.osc2.detune; sd.querySelector('#sd-osc2-detune-val').textContent = s.osc2.detune + 'c';
            sd.querySelector('#sd-filter-type').value = s.filter.type;
            sd.querySelector('#sd-filter-cutoff').value = s.filter.cutoff; sd.querySelector('#sd-filter-cutoff-val').textContent = s.filter.cutoff + 'Hz';
            sd.querySelector('#sd-filter-res').value = s.filter.resonance; sd.querySelector('#sd-filter-res-val').textContent = s.filter.resonance;
            sd.querySelector('#sd-env-attack').value = s.envelope.attack; sd.querySelector('#sd-env-attack-val').textContent = s.envelope.attack + 'ms';
            sd.querySelector('#sd-env-decay').value = s.envelope.decay; sd.querySelector('#sd-env-decay-val').textContent = s.envelope.decay + 'ms';
            sd.querySelector('#sd-env-sustain').value = s.envelope.sustain; sd.querySelector('#sd-env-sustain-val').textContent = s.envelope.sustain + '%';
            sd.querySelector('#sd-env-release').value = s.envelope.release; sd.querySelector('#sd-env-release-val').textContent = s.envelope.release + 'ms';
            
            // Envelope to Pitch controls
            if (!s.envToPitch) s.envToPitch = { enabled: false, amount: 0 };
            sd.querySelector('#sd-env-pitch-enable').checked = s.envToPitch.enabled || false;
            sd.querySelector('#sd-env-pitch-amount').value = s.envToPitch.amount || 0;
            sd.querySelector('#sd-env-pitch-amount-val').textContent = (s.envToPitch.amount || 0);
            
            sd.style.display = (data.soundSource === 'sounddesign' && pianoRollData[currentSampleForPopup].isEnabled) ? '' : 'none';
            
            // Draw ADSR canvas immediately after controls are set up
            requestAnimationFrame(() => {
                drawADSRCanvas();
            });
        }
        soundSourceSelect.addEventListener("change", function () {
            data.soundSource = this.value;
            if (this.value === "sample") {
                openSampleSelectionPopup();
            }
            const sd = document.querySelector('.sound-design-controls');
            if (sd) {
                sd.style.display = (this.value === 'sounddesign' && pianoRollData[currentSampleForPopup].isEnabled) ? '' : 'none';
                
                // Draw ADSR canvas when sound design becomes visible
                if (this.value === 'sounddesign') {
                    setTimeout(drawADSRCanvas, 50);
                }
            }
        });
        // SD listeners
        const bind = (sel, ev, fn) => { const el = document.querySelector(sel); if (el) { el.replaceWith(el.cloneNode(true)); const ne = document.querySelector(sel); ne.addEventListener(ev, fn); } };
        bind('#sd-osc1-wave','change', e=>{ ensureSD(); pianoRollData[currentSampleForPopup].soundDesign.osc1.wave = e.target.value; });
        bind('#sd-osc1-level','input', e=>{ ensureSD(); const v=+e.target.value; const s=pianoRollData[currentSampleForPopup].soundDesign; s.osc1.level=v; document.getElementById('sd-osc1-level-val').textContent=v+'%'; if(isPreviewingPianoRoll){const n=pianoRollPreviewNodes[currentSampleForPopup]; n.soundDesign=s; // live update active voices
            Object.values(pianoRollPreviewActiveVoices).forEach(vv=>{ if(vv && vv.g1) vv.g1.gain.value = (s.osc1.level||0)/100; }); }});
        bind('#sd-osc1-detune','input', e=>{ ensureSD(); const v=+e.target.value; const s=pianoRollData[currentSampleForPopup].soundDesign; s.osc1.detune=v; document.getElementById('sd-osc1-detune-val').textContent=v+'c'; if(isPreviewingPianoRoll){const n=pianoRollPreviewNodes[currentSampleForPopup]; n.soundDesign=s; Object.values(pianoRollPreviewActiveVoices).forEach(vv=>{ if(vv && vv.osc1) vv.osc1.detune.setValueAtTime(s.osc1.detune, audioContext.currentTime); }); }});
        bind('#sd-osc2-wave','change', e=>{ ensureSD(); pianoRollData[currentSampleForPopup].soundDesign.osc2.wave = e.target.value; });
        bind('#sd-osc2-level','input', e=>{ ensureSD(); const v=+e.target.value; const s=pianoRollData[currentSampleForPopup].soundDesign; s.osc2.level=v; document.getElementById('sd-osc2-level-val').textContent=v+'%'; if(isPreviewingPianoRoll){const n=pianoRollPreviewNodes[currentSampleForPopup]; n.soundDesign=s; Object.values(pianoRollPreviewActiveVoices).forEach(vv=>{ if(vv && vv.g2) vv.g2.gain.value = (s.osc2.level||0)/100; }); }});
        bind('#sd-osc2-detune','input', e=>{ ensureSD(); const v=+e.target.value; const s=pianoRollData[currentSampleForPopup].soundDesign; s.osc2.detune=v; document.getElementById('sd-osc2-detune-val').textContent=v+'c'; if(isPreviewingPianoRoll){const n=pianoRollPreviewNodes[currentSampleForPopup]; n.soundDesign=s; Object.values(pianoRollPreviewActiveVoices).forEach(vv=>{ if(vv && vv.osc2) vv.osc2.detune.setValueAtTime(s.osc2.detune, audioContext.currentTime); }); }});
        bind('#sd-filter-type','change', e=>{ ensureSD(); const s=pianoRollData[currentSampleForPopup].soundDesign; s.filter.type=e.target.value; if(isPreviewingPianoRoll){const n=pianoRollPreviewNodes[currentSampleForPopup]; n.soundDesign=s; Object.values(pianoRollPreviewActiveVoices).forEach(vv=>{ if(vv && vv.filter) vv.filter.type = s.filter.type; }); }});
        bind('#sd-filter-cutoff','input', e=>{ ensureSD(); const v=+e.target.value; const s=pianoRollData[currentSampleForPopup].soundDesign; s.filter.cutoff=v; document.getElementById('sd-filter-cutoff-val').textContent=v+'Hz'; if(isPreviewingPianoRoll){const n=pianoRollPreviewNodes[currentSampleForPopup]; n.soundDesign=s; Object.values(pianoRollPreviewActiveVoices).forEach(vv=>{ if(vv && vv.filter) vv.filter.frequency.setValueAtTime(Math.max(20, s.filter.cutoff||2000), audioContext.currentTime); }); }});
        bind('#sd-filter-res','input', e=>{ ensureSD(); const v=+e.target.value; const s=pianoRollData[currentSampleForPopup].soundDesign; s.filter.resonance=v; document.getElementById('sd-filter-res-val').textContent=v; if(isPreviewingPianoRoll){const n=pianoRollPreviewNodes[currentSampleForPopup]; n.soundDesign=s; Object.values(pianoRollPreviewActiveVoices).forEach(vv=>{ if(vv && vv.filter) vv.filter.Q.setValueAtTime((s.filter.resonance||0)/10, audioContext.currentTime); }); }});
        bind('#sd-env-attack','input', e=>{ ensureSD(); const v=+e.target.value; const s=pianoRollData[currentSampleForPopup].soundDesign; s.envelope.attack=v; document.getElementById('sd-env-attack-val').textContent=v+'ms'; if(isPreviewingPianoRoll){const n=pianoRollPreviewNodes[currentSampleForPopup]; n.soundDesign=s; const now=audioContext.currentTime; Object.values(pianoRollPreviewActiveVoices).forEach(vv=>{ if(vv && vv.env){ vv.env.gain.cancelScheduledValues(now); vv.env.gain.setValueAtTime(0, now); vv.env.gain.linearRampToValueAtTime(1, now + (s.envelope.attack||0)/1000); } }); }});
        bind('#sd-env-decay','input', e=>{ ensureSD(); const v=+e.target.value; const s=pianoRollData[currentSampleForPopup].soundDesign; s.envelope.decay=v; document.getElementById('sd-env-decay-val').textContent=v+'ms'; if(isPreviewingPianoRoll){const n=pianoRollPreviewNodes[currentSampleForPopup]; n.soundDesign=s; const now=audioContext.currentTime; const sustain=(s.envelope.sustain||0)/100; Object.values(pianoRollPreviewActiveVoices).forEach(vv=>{ if(vv && vv.env){ vv.env.gain.cancelScheduledValues(now); vv.env.gain.setValueAtTime(vv.env.gain.value, now); vv.env.gain.linearRampToValueAtTime(sustain, now + (s.envelope.decay||0)/1000); } }); }});
        bind('#sd-env-sustain','input', e=>{ ensureSD(); const v=+e.target.value; const s=pianoRollData[currentSampleForPopup].soundDesign; s.envelope.sustain=v; document.getElementById('sd-env-sustain-val').textContent=v+'%'; if(isPreviewingPianoRoll){const n=pianoRollPreviewNodes[currentSampleForPopup]; n.soundDesign=s; Object.values(pianoRollPreviewActiveVoices).forEach(vv=>{ if(vv && vv.env){ const now=audioContext.currentTime; vv.env.gain.cancelScheduledValues(now); vv.env.gain.setValueAtTime(vv.env.gain.value, now); vv.env.gain.linearRampToValueAtTime((s.envelope.sustain||0)/100, now+0.02); }}); }});
        bind('#sd-env-release','input', e=>{ ensureSD(); const v=+e.target.value; const s=pianoRollData[currentSampleForPopup].soundDesign; s.envelope.release=v; document.getElementById('sd-env-release-val').textContent=v+'ms'; if(isPreviewingPianoRoll){const n=pianoRollPreviewNodes[currentSampleForPopup]; n.soundDesign=s; const now=audioContext.currentTime; Object.values(pianoRollPreviewActiveVoices).forEach(vv=>{ if(vv && vv.env){ vv.env.gain.cancelScheduledValues(now); vv.env.gain.setValueAtTime(vv.env.gain.value, now); vv.env.gain.linearRampToValueAtTime(0, now + Math.max(0,(s.envelope.release||0)/1000)); } }); }});
        
        // Envelope to Pitch modulation controls
        bind('#sd-env-pitch-enable','change', e=>{ ensureSD(); const s=pianoRollData[currentSampleForPopup].soundDesign; if(!s.envToPitch) s.envToPitch = {enabled:false, amount:0}; s.envToPitch.enabled = e.target.checked; if(isPreviewingPianoRoll){const n=pianoRollPreviewNodes[currentSampleForPopup]; n.soundDesign=s;} });
        bind('#sd-env-pitch-amount','input', e=>{ ensureSD(); const v=+e.target.value; const s=pianoRollData[currentSampleForPopup].soundDesign; if(!s.envToPitch) s.envToPitch = {enabled:false, amount:0}; s.envToPitch.amount=v; document.getElementById('sd-env-pitch-amount-val').textContent=v; if(isPreviewingPianoRoll){const n=pianoRollPreviewNodes[currentSampleForPopup]; n.soundDesign=s;} });
        
        // ADSR Visual Canvas - Serum Style
        function drawADSRCanvas() {
            const canvas = document.getElementById('adsr-canvas');
            if (!canvas) return;
            
            // FIX: Set canvas resolution to match display size for crisp rendering
            const rect = canvas.getBoundingClientRect();
            
            // Safety check: don't draw if canvas has no dimensions yet
            if (rect.width === 0 || rect.height === 0) {
                console.log('⚠️ ADSR canvas not ready, retrying...');
                setTimeout(drawADSRCanvas, 50);
                return;
            }
            
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            
            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);
            
            const width = rect.width;
            const height = rect.height;
            const s = pianoRollData[currentSampleForPopup]?.soundDesign;
            if (!s) return;
            
            const attack = s.envelope.attack || 0;
            const decay = s.envelope.decay || 0;
            const sustain = (s.envelope.sustain || 0) / 100;
            const release = s.envelope.release || 0;
            
            // Fixed time scale - no stretching!
            // Total fixed time window: 10000ms (10 seconds)
            const FIXED_TOTAL_TIME = 10000;
            const SUSTAIN_DISPLAY_TIME = 1000; // Fixed 1 second sustain display
            
            const padding = 40;
            const availableWidth = width - (padding * 2);
            
            // Calculate X positions based on FIXED time scale
            const attackX = padding + (attack / FIXED_TOTAL_TIME) * availableWidth;
            const decayX = padding + ((attack + decay) / FIXED_TOTAL_TIME) * availableWidth;
            
            // Sustain time is now adjustable (0-2000ms for kick drums)
            // FIX: Ensure minimum visual separation for sustain point
            const sustainTime = s.envelope.sustainTime || 10; // Default 10ms for tight kicks
            const minSustainDisplay = 50; // Minimum 50ms visual display for clarity
            const displaySustainTime = Math.max(sustainTime, minSustainDisplay);
            const sustainX = padding + ((attack + decay + displaySustainTime) / FIXED_TOTAL_TIME) * availableWidth;
            const releaseX = padding + ((attack + decay + displaySustainTime + release) / FIXED_TOTAL_TIME) * availableWidth;
            
            // Clamp release to canvas width if it exceeds
            const maxReleaseX = width - padding;
            const clampedReleaseX = Math.min(releaseX, maxReleaseX);
            
            const marginTop = 40;
            const marginBottom = 40;
            const availableHeight = height - marginTop - marginBottom;
            
            const peakY = marginTop;
            const sustainY = marginTop + ((1 - sustain) * availableHeight);
            const endY = height - marginBottom;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Grid lines
            ctx.strokeStyle = '#2a2a2a';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = marginTop + (i * availableHeight / 4);
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }
            
            // Vertical grid lines (time markers every second)
            ctx.strokeStyle = '#222';
            for (let i = 1; i <= 10; i++) {
                const x = padding + (i * 1000 / FIXED_TOTAL_TIME) * availableWidth;
                ctx.beginPath();
                ctx.moveTo(x, marginTop);
                ctx.lineTo(x, height - marginBottom);
                ctx.stroke();
                
                // Time labels at bottom
                ctx.fillStyle = '#444';
                ctx.font = '9px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${i}s`, x, height - marginBottom + 12);
            }
            
            // Draw envelope curve with gradient - PURPLE theme
            const gradient = ctx.createLinearGradient(0, peakY, 0, endY);
            gradient.addColorStop(0, '#B388FF');
            gradient.addColorStop(1, '#7C4DFF');
            
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            ctx.beginPath();
            ctx.moveTo(padding, endY);
            ctx.lineTo(attackX, peakY); // Attack
            ctx.lineTo(decayX, sustainY); // Decay
            ctx.lineTo(sustainX, sustainY); // Sustain
            ctx.lineTo(clampedReleaseX, endY); // Release (clamped)
            ctx.stroke();
            
            // Draw glow effect
            ctx.shadowColor = '#B388FF';
            ctx.shadowBlur = 20;
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Fill under curve
            ctx.fillStyle = 'rgba(179, 136, 255, 0.15)';
            ctx.beginPath();
            ctx.moveTo(padding, endY);
            ctx.lineTo(attackX, peakY);
            ctx.lineTo(decayX, sustainY);
            ctx.lineTo(sustainX, sustainY);
            ctx.lineTo(clampedReleaseX, endY);
            ctx.closePath();
            ctx.fill();
            
            // Draw control points with labels
            const points = [
                {x: attackX, y: peakY, label: 'A', color: '#FF4444'},
                {x: decayX, y: sustainY, label: 'D', color: '#FFAA44'},
                {x: sustainX, y: sustainY, label: 'S', color: '#44FF44'},
                {x: clampedReleaseX, y: endY, label: 'R', color: '#4444FF'}
            ];
            
            points.forEach(pt => {
                // Outer glow
                ctx.fillStyle = pt.color;
                ctx.shadowColor = pt.color;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(pt.x, pt.y, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner circle
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(pt.x, pt.y, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Label above point
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(pt.label, pt.x, pt.y - 18);
            });
            
            // Value labels
            ctx.fillStyle = '#aaa';
            ctx.font = '11px Arial';
            ctx.textAlign = 'center';
            
            if (attackX > padding + 20) {
                ctx.fillText(`${attack}ms`, attackX, height - 22);
            }
            if (decayX > attackX + 40) {
                ctx.fillText(`${decay}ms`, (attackX + decayX) / 2, height - 22);
            }
            ctx.fillText(`${Math.round(sustain * 100)}%`, (decayX + sustainX) / 2, sustainY - 8);
            if (sustainX > decayX + 20) {
                ctx.fillText(`${sustainTime}ms`, (decayX + sustainX) / 2, height - 22);
            }
            if (clampedReleaseX > sustainX + 40) {
                ctx.fillText(`${release}ms`, (sustainX + clampedReleaseX) / 2, height - 22);
            }
            
            // Stage labels at top
            ctx.fillStyle = '#666';
            ctx.font = 'bold 10px Arial';
            if (attackX > padding + 30) {
                ctx.fillText('ATTACK', (padding + attackX) / 2, 20);
            }
            if (decayX > attackX + 30) {
                ctx.fillText('DECAY', (attackX + decayX) / 2, 20);
            }
            if (sustainX > decayX + 30) {
                ctx.fillText('SUSTAIN', (decayX + sustainX) / 2, 20);
            }
            if (clampedReleaseX > sustainX + 30) {
                ctx.fillText('RELEASE', (sustainX + clampedReleaseX) / 2, 20);
            }
            
            // Warning if release is clamped
            if (releaseX > maxReleaseX) {
                ctx.fillStyle = '#FF4444';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'right';
                ctx.fillText('⚠ Max', width - padding - 5, 20);
            }
        }
        
        // Interactive ADSR canvas
        function setupADSRCanvasInteraction() {
            const canvas = document.getElementById('adsr-canvas');
            if (!canvas) return;
            
            let dragging = null;
            let dragStartX = 0;
            let dragStartY = 0;
            let originalValue = 0;
            const FIXED_TOTAL_TIME = 10000; // Same as drawADSRCanvas
            const SUSTAIN_DISPLAY_TIME = 1000;
            
            function getMousePos(e) {
                const rect = canvas.getBoundingClientRect();
                // FIX: No need to scale since we're using rect dimensions directly
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
            
            canvas.addEventListener('mousedown', (e) => {
                const pos = getMousePos(e);
                const s = pianoRollData[currentSampleForPopup]?.soundDesign;
                if (!s) return;
                
                const rect = canvas.getBoundingClientRect();
                const padding = 40;
                const marginTop = 40;
                const marginBottom = 40;
                const availableHeight = rect.height - marginTop - marginBottom;
                
                const attack = s.envelope.attack || 0;
                const decay = s.envelope.decay || 0;
                const sustain = (s.envelope.sustain || 0) / 100;
                const release = s.envelope.release || 0;
                const sustainTime = s.envelope.sustainTime || 10; // Default 10ms for kicks
                
                // FIX: Use display sustain time for consistent hit detection
                const minSustainDisplay = 50;
                const displaySustainTime = Math.max(sustainTime, minSustainDisplay);
                
                const availableWidth = rect.width - (padding * 2);
                
                const attackX = padding + (attack / FIXED_TOTAL_TIME) * availableWidth;
                const decayX = padding + ((attack + decay) / FIXED_TOTAL_TIME) * availableWidth;
                const sustainX = padding + ((attack + decay + displaySustainTime) / FIXED_TOTAL_TIME) * availableWidth;
                const releaseX = Math.min(padding + ((attack + decay + displaySustainTime + release) / FIXED_TOTAL_TIME) * availableWidth, rect.width - padding);
                
                const peakY = marginTop;
                const sustainY = marginTop + ((1 - sustain) * availableHeight);
                const endY = rect.height - marginBottom;
                
                // FIX: Find closest point for better hit detection when points are close together
                const points = [
                    {name: 'attack', x: attackX, y: peakY, value: attack},
                    {name: 'decay', x: decayX, y: sustainY, value: {decay: decay, sustain: sustain * 100}},
                    {name: 'sustain-point', x: sustainX, y: sustainY, value: {sustainTime: sustainTime, sustain: sustain * 100}},
                    {name: 'release', x: releaseX, y: endY, value: release}
                ];
                
                let closestPoint = null;
                let minDistance = 15; // Hit detection radius
                
                points.forEach(pt => {
                    const distance = Math.sqrt(Math.pow(pos.x - pt.x, 2) + Math.pow(pos.y - pt.y, 2));
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestPoint = pt;
                    }
                });
                
                if (closestPoint) {
                    dragging = closestPoint.name;
                    dragStartX = pos.x;
                    dragStartY = pos.y;
                    originalValue = closestPoint.value;
                    e.preventDefault();
                    canvas.style.cursor = 'grabbing';
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (!dragging) return;
                
                const pos = getMousePos(e);
                const s = pianoRollData[currentSampleForPopup]?.soundDesign;
                if (!s) return;
                
                const rect = canvas.getBoundingClientRect();
                const padding = 40;
                const marginTop = 40;
                const marginBottom = 40;
                const availableHeight = rect.height - marginTop - marginBottom;
                const availableWidth = rect.width - (padding * 2);
                
                if (dragging === 'attack') {
                    // Horizontal drag for attack time using FIXED time scale
                    const deltaX = pos.x - dragStartX;
                    const deltaTime = (deltaX / availableWidth) * FIXED_TOTAL_TIME;
                    const newAttack = Math.max(0, Math.min(2000, originalValue + deltaTime));
                    document.getElementById('sd-env-attack').value = newAttack;
                    document.getElementById('sd-env-attack').dispatchEvent(new Event('input'));
                    
                } else if (dragging === 'decay') {
                    // Horizontal: decay time using FIXED time scale
                    // Vertical: sustain level
                    const deltaX = pos.x - dragStartX;
                    const deltaY = pos.y - dragStartY;
                    
                    // Horizontal: decay time
                    const deltaTime = (deltaX / availableWidth) * FIXED_TOTAL_TIME;
                    const newDecay = Math.max(0, Math.min(4000, originalValue.decay + deltaTime));
                    document.getElementById('sd-env-decay').value = newDecay;
                    document.getElementById('sd-env-decay').dispatchEvent(new Event('input'));
                    
                    // Vertical: sustain level (affects both D and S points)
                    const deltaSustain = -(deltaY / availableHeight) * 100;
                    const newSustain = Math.max(0, Math.min(100, originalValue.sustain + deltaSustain));
                    document.getElementById('sd-env-sustain').value = newSustain;
                    document.getElementById('sd-env-sustain').dispatchEvent(new Event('input'));
                    
                } else if (dragging === 'sustain-point') {
                    // Horizontal: sustain time (gap between D and S)
                    // Vertical: does nothing (to keep sustain level consistent with D point)
                    const deltaX = pos.x - dragStartX;
                    
                    // Horizontal: sustain time (how long sustain lasts)
                    const deltaTime = (deltaX / availableWidth) * FIXED_TOTAL_TIME;
                    const newSustainTime = Math.max(0, Math.min(2000, originalValue.sustainTime + deltaTime));
                    if (!s.envelope.sustainTime) s.envelope.sustainTime = 10; // Initialize if not exists
                    s.envelope.sustainTime = newSustainTime;
                    
                    // Redraw immediately
                    drawADSRCanvas();
                    
                } else if (dragging === 'release') {
                    // Horizontal drag for release time using FIXED time scale
                    const deltaX = pos.x - dragStartX;
                    const deltaTime = (deltaX / availableWidth) * FIXED_TOTAL_TIME;
                    const newRelease = Math.max(0, Math.min(4000, originalValue + deltaTime));
                    document.getElementById('sd-env-release').value = newRelease;
                    document.getElementById('sd-env-release').dispatchEvent(new Event('input'));
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                dragging = null;
                canvas.style.cursor = 'crosshair';
            });
            
            canvas.addEventListener('mouseleave', () => {
                dragging = null;
                canvas.style.cursor = 'crosshair';
            });
            
            // Show cursor feedback on hover
            canvas.addEventListener('mousemove', (e) => {
                if (dragging) return;
                
                const pos = getMousePos(e);
                const s = pianoRollData[currentSampleForPopup]?.soundDesign;
                if (!s) return;
                
                const padding = 40;
                const marginTop = 40;
                const marginBottom = 40;
                const availableHeight = canvas.height - marginTop - marginBottom;
                
                const attack = s.envelope.attack || 0;
                const decay = s.envelope.decay || 0;
                const sustain = (s.envelope.sustain || 0) / 100;
                const release = s.envelope.release || 0;
                const sustainTime = s.envelope.sustainTime || 10; // Default 10ms
                
                const availableWidth = canvas.width - (padding * 2);
                
                const attackX = padding + (attack / FIXED_TOTAL_TIME) * availableWidth;
                const decayX = padding + ((attack + decay) / FIXED_TOTAL_TIME) * availableWidth;
                const sustainX = padding + ((attack + decay + sustainTime) / FIXED_TOTAL_TIME) * availableWidth;
                const releaseX = Math.min(padding + ((attack + decay + sustainTime + release) / FIXED_TOTAL_TIME) * availableWidth, canvas.width - padding);
                
                const peakY = marginTop;
                const sustainY = marginTop + ((1 - sustain) * availableHeight);
                const endY = canvas.height - marginBottom;
                
                // Check if near any control point
                const nearPoint = 
                    (Math.abs(pos.x - attackX) < 15 && Math.abs(pos.y - peakY) < 15) ||
                    (Math.abs(pos.x - decayX) < 15 && Math.abs(pos.y - sustainY) < 15) ||
                    (Math.abs(pos.x - sustainX) < 15 && Math.abs(pos.y - sustainY) < 15) ||
                    (Math.abs(pos.x - releaseX) < 15 && Math.abs(pos.y - endY) < 15);
                
                canvas.style.cursor = nearPoint ? 'grab' : 'crosshair';
            });
        }
        
        // Redraw ADSR when sliders change
        ['sd-env-attack', 'sd-env-decay', 'sd-env-sustain', 'sd-env-release'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('input', () => {
                    setTimeout(drawADSRCanvas, 10);
                });
            }
        });
        
        // Initial draw - use requestAnimationFrame for better timing
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                drawADSRCanvas();
                setupADSRCanvasInteraction();
            });
        });
        
        gridSizeDecreaseBtn.addEventListener("click", function () {
            if (data.gridWidth > 4) {
                data.gridWidth /= 2;
                gridSizeDisplay.textContent = data.gridWidth;
                
                // Recreate bar numbers for new grid size
                pianoRollBarNumbers.innerHTML = "";
                const stepsPerBeat = 4;
                const totalBeats = Math.ceil(data.gridWidth / stepsPerBeat);
                for (let beatIdx = 0; beatIdx < totalBeats; beatIdx++) {
                    const barNumber = Math.floor(beatIdx / 4) + 1;
                    const beatNumber = (beatIdx % 4) + 1;
                    const beatDiv = document.createElement("div");
                    beatDiv.className = "piano-roll-bar-number";
                    if (beatNumber === 1) beatDiv.classList.add("bar-start");
                    
                    // Calculate width and font size based on zoom level
                    const baseCellWidth = 20;
                    const cellWidth = baseCellWidth * pianoRollZoomLevel;
                    const fontSize = Math.max(8, 10 * pianoRollZoomLevel);
                    beatDiv.style.width = `${stepsPerBeat * cellWidth}px`;
                    beatDiv.style.fontSize = `${fontSize}px`;
                    beatDiv.style.display = "flex";
                    beatDiv.style.justifyContent = "center";
                    
                    const span = document.createElement("span");
                    span.textContent = `${barNumber}.${beatNumber}`;
                    beatDiv.appendChild(span);
                    pianoRollBarNumbers.appendChild(beatDiv);
                }
                
                updatePianoRollCellWidth();
                
                // Get fresh reference to grid
                const currentGrid = document.querySelector(".piano-roll-grid");
                
                // Recreate grid with optimized rendering
                currentGrid.innerHTML = "";
                const fragment = document.createDocumentFragment();
                
                // Clear cell cache for rebuild
                pianoRollCellCache = {};
                
                // Pre-calculate note positions for better performance
                const noteMap = new Map();
                data.notes.forEach(note => {
                    for (let c = note.col; c < note.col + (note.length || 1); c++) {
                        const key = `${note.row}-${c}`;
                        noteMap.set(key, { isStart: c === note.col, isPart: true });
                    }
                });
                
                for (let row = data.gridHeight - 1; row >= 0; row--) {
                    for (let col = 0; col < data.gridWidth; col++) {
                        const cell = document.createElement("div");
                        cell.className = "piano-roll-cell";
                        if (col % 4 === 0) cell.classList.add("bar-start");
                        if ((col + 1) % 4 === 0) cell.classList.add("bar-end");
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        const noteInfo = noteMap.get(`${row}-${col}`);
                        if (noteInfo) {
                            cell.classList.add("active");
                            if (!noteInfo.isStart) {
                                cell.classList.add("note-long");
                            }
                        }
                        
                        // PERFORMANCE: Cache cell reference
                        const cacheKey = `${row}-${col}`;
                        pianoRollCellCache[cacheKey] = cell;
                        
                        fragment.appendChild(cell);
                    }
                }
                currentGrid.appendChild(fragment);
                
                // DON'T re-attach click listener here - it's handled globally below
            }
        });
        gridSizeIncreaseBtn.addEventListener("click", function () {
            // Changed maximum grid size from 256 to 128
            if (data.gridWidth < 128) {
                data.gridWidth *= 2;
                gridSizeDisplay.textContent = data.gridWidth;
                
                // Recreate bar numbers for new grid size
                pianoRollBarNumbers.innerHTML = "";
                const stepsPerBeat = 4;
                const totalBeats = Math.ceil(data.gridWidth / stepsPerBeat);
                console.log(`Creating bar numbers: gridWidth=${data.gridWidth}, totalBeats=${totalBeats}`);
                for (let beatIdx = 0; beatIdx < totalBeats; beatIdx++) {
                    const barNumber = Math.floor(beatIdx / 4) + 1;
                    const beatNumber = (beatIdx % 4) + 1;
                    const beatDiv = document.createElement("div");
                    beatDiv.className = "piano-roll-bar-number";
                    if (beatNumber === 1) beatDiv.classList.add("bar-start");
                    
                    // Calculate width and font size based on zoom level
                    const baseCellWidth = 20;
                    const cellWidth = baseCellWidth * pianoRollZoomLevel;
                    const fontSize = Math.max(8, 10 * pianoRollZoomLevel);
                    beatDiv.style.width = `${stepsPerBeat * cellWidth}px`;
                    beatDiv.style.fontSize = `${fontSize}px`;
                    beatDiv.style.display = "flex";
                    beatDiv.style.justifyContent = "center";
                    
                    const span = document.createElement("span");
                    span.textContent = `${barNumber}.${beatNumber}`;
                    beatDiv.appendChild(span);
                    pianoRollBarNumbers.appendChild(beatDiv);
                }
                console.log(`Created ${totalBeats} bar numbers`);
                
                updatePianoRollCellWidth();
                
                // Get fresh reference to grid
                const currentGrid = document.querySelector(".piano-roll-grid");
                
                // Recreate grid with optimized rendering
                currentGrid.innerHTML = "";
                const fragment = document.createDocumentFragment();
                
                // Clear cell cache for rebuild
                pianoRollCellCache = {};
                
                // Pre-calculate note positions for better performance
                const noteMap = new Map();
                data.notes.forEach(note => {
                    for (let c = note.col; c < note.col + (note.length || 1); c++) {
                        const key = `${note.row}-${c}`;
                        noteMap.set(key, { isStart: c === note.col, isPart: true });
                    }
                });
                
                for (let row = data.gridHeight - 1; row >= 0; row--) {
                    for (let col = 0; col < data.gridWidth; col++) {
                        const cell = document.createElement("div");
                        cell.className = "piano-roll-cell";
                        if (col % 4 === 0) cell.classList.add("bar-start");
                        if ((col + 1) % 4 === 0) cell.classList.add("bar-end");
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        const noteInfo = noteMap.get(`${row}-${col}`);
                        if (noteInfo) {
                            cell.classList.add("active");
                            if (!noteInfo.isStart) {
                                cell.classList.add("note-long");
                            }
                        }
                        
                        // PERFORMANCE: Cache cell reference
                        const cacheKey = `${row}-${col}`;
                        pianoRollCellCache[cacheKey] = cell;
                        
                        fragment.appendChild(cell);
                    }
                }
                currentGrid.appendChild(fragment);
                
                // DON'T re-attach click listener here - it's handled globally below
            }
        });
        const previewBtn = document.getElementById("piano-roll-preview-btn");
        const stopBtn = document.getElementById("piano-roll-stop-btn");
        const clearBtn = document.getElementById("piano-roll-clear-btn");
        previewBtn.replaceWith(previewBtn.cloneNode(true));
        stopBtn.replaceWith(stopBtn.cloneNode(true));
        clearBtn.replaceWith(clearBtn.cloneNode(true));
        const newPreviewBtn = document.getElementById("piano-roll-preview-btn");
        const newStopBtn = document.getElementById("piano-roll-stop-btn");
        const newClearBtn = document.getElementById("piano-roll-clear-btn");
        newPreviewBtn.addEventListener("click", previewPianoRoll);
        newStopBtn.addEventListener("click", stopPianoRollPreview);
        newClearBtn.addEventListener("click", function () {
            clearPianoRoll();
            stopPianoRollPreview();
        });
        
        // GLOBAL EVENT LISTENER FOR PIANO ROLL CELLS
        // This handles clicks for ALL grid sizes (8, 16, 32, 64, 128)
        // Using event delegation on the grid itself
        const globalPianoRollGrid = document.querySelector(".piano-roll-grid");
        if (globalPianoRollGrid && !globalPianoRollGrid.hasAttribute('data-click-handler-attached')) {
            globalPianoRollGrid.setAttribute('data-click-handler-attached', 'true');
            globalPianoRollGrid.addEventListener("click", function(e) {
                if (e.target.classList.contains("piano-roll-cell")) {
                    const row = parseInt(e.target.dataset.row);
                    const col = parseInt(e.target.dataset.col);
                    if (!isNaN(row) && !isNaN(col)) {
                        togglePianoRollCell(row, col);
                    }
                }
            });
        }
        
        initPianoRollVisualizer();
    }

    function initPianoRollVisualizer() {
        if (!currentSampleForPopup) return;
        pianoRollVisualizer = document.getElementById("piano-roll-visualizer");
        pianoRollVisualizerCtx = pianoRollVisualizer.getContext("2d");
        const container = pianoRollVisualizer.parentElement;
        pianoRollVisualizer.width = container.clientWidth;
        pianoRollVisualizer.height = container.clientHeight;
        if (pianoRollVisualizerAnimationId) {
            cancelAnimationFrame(pianoRollVisualizerAnimationId);
            pianoRollVisualizerAnimationId = null;
        }
        pianoRollVisualizerHistory = [];
        drawPianoRollVisualizer();
    }

    function drawPianoRollVisualizer() {
        if (!pianoRollVisualizer || !pianoRollVisualizerCtx) return;
        const width = pianoRollVisualizer.width;
        const height = pianoRollVisualizer.height;
        
        // Clear canvas with professional dark background
        pianoRollVisualizerCtx.fillStyle = "#0a0a0a";
        pianoRollVisualizerCtx.fillRect(0, 0, width, height);
        
        // Add subtle grid lines for professional look
        pianoRollVisualizerCtx.strokeStyle = "rgba(255, 255, 255, 0.05)";
        pianoRollVisualizerCtx.lineWidth = 1;
        for (let i = 0; i <= 4; i++) {
            const y = (height / 4) * i;
            pianoRollVisualizerCtx.beginPath();
            pianoRollVisualizerCtx.moveTo(0, y);
            pianoRollVisualizerCtx.lineTo(width, y);
            pianoRollVisualizerCtx.stroke();
        }
        
        if (pianoRollVisualizerHistory.length > 0) {
            // Professional frequency spectrum gradient
            const gradient = pianoRollVisualizerCtx.createLinearGradient(0, height, 0, 0);
            gradient.addColorStop(0, "rgba(0, 150, 255, 0.8)");    // Deep blue for bass
            gradient.addColorStop(0.2, "rgba(0, 200, 100, 0.7)");  // Green for low-mid
            gradient.addColorStop(0.4, "rgba(255, 200, 0, 0.6)");  // Yellow for mid
            gradient.addColorStop(0.6, "rgba(255, 100, 0, 0.7)");  // Orange for high-mid
            gradient.addColorStop(0.8, "rgba(255, 0, 150, 0.8)");  // Pink for high
            gradient.addColorStop(1, "rgba(200, 0, 255, 0.9)");    // Purple for very high
            
            const sliceWidth = width / pianoRollVisualizerHistorySize;
            for (let h = 0; h < pianoRollVisualizerHistory.length; h++) {
                const dataArray = pianoRollVisualizerHistory[h];
                const x = h * sliceWidth;
                const alpha = 0.3 + h / pianoRollVisualizerHistory.length * 0.4;
                
                pianoRollVisualizerCtx.beginPath();
                pianoRollVisualizerCtx.moveTo(x, height);
                
                const maxFreq = audioContext.sampleRate / 2;
                const minLogFreq = Math.log10(20);
                const maxLogFreq = Math.log10(maxFreq);
                
                for (let i = 0; i < dataArray.length; i++) {
                    const freq = i * maxFreq / dataArray.length;
                    const logFreq = Math.log10(Math.max(20, freq));
                    const normalizedLogFreq = (logFreq - minLogFreq) / (maxLogFreq - minLogFreq);
                    const y = height - normalizedLogFreq * height;
                    const amplitude = dataArray[i] / 255;
                    const enhancedAmplitude = Math.pow(amplitude, 0.3); // Smoother curve
                    const ampHeight = enhancedAmplitude * height * 0.85;
                    pianoRollVisualizerCtx.lineTo(x, y - ampHeight);
                }
                
                pianoRollVisualizerCtx.lineTo(x + sliceWidth, height);
                pianoRollVisualizerCtx.closePath();
                pianoRollVisualizerCtx.globalAlpha = alpha;
                pianoRollVisualizerCtx.fillStyle = gradient;
                pianoRollVisualizerCtx.fill();
            }
            
            pianoRollVisualizerCtx.globalAlpha = 1;
            
            // Professional frequency response line
            if (pianoRollVisualizerHistory.length > 0) {
                const latestData = pianoRollVisualizerHistory[pianoRollVisualizerHistory.length - 1];
                
                // Main frequency line with glow effect
                pianoRollVisualizerCtx.shadowColor = "rgba(0, 200, 255, 0.8)";
                pianoRollVisualizerCtx.shadowBlur = 8;
                pianoRollVisualizerCtx.strokeStyle = "rgba(0, 200, 255, 1)";
                pianoRollVisualizerCtx.lineWidth = 2;
                pianoRollVisualizerCtx.beginPath();
                
                const maxFreq = audioContext.sampleRate / 2;
                const minLogFreq = Math.log10(20);
                const maxLogFreq = Math.log10(maxFreq);
                
                for (let i = 0; i < latestData.length; i++) {
                    const freq = i * maxFreq / latestData.length;
                    const logFreq = Math.log10(Math.max(20, freq));
                    const normalizedLogFreq = (logFreq - minLogFreq) / (maxLogFreq - minLogFreq);
                    const x = normalizedLogFreq * width;
                    const amplitude = latestData[i] / 255;
                    const enhancedAmplitude = Math.pow(amplitude, 0.3);
                    const y = height - enhancedAmplitude * height * 0.85;
                    
                    if (i === 0) {
                        pianoRollVisualizerCtx.moveTo(x, y);
                    } else {
                        pianoRollVisualizerCtx.lineTo(x, y);
                    }
                }
                pianoRollVisualizerCtx.stroke();
                
                // Reset shadow
                pianoRollVisualizerCtx.shadowBlur = 0;
            }
        }
    }

    function startPianoRollVisualizerAnimation() {
        if (!pianoRollVisualizerAnalyzer) return;
        const bufferLength = pianoRollVisualizerAnalyzer.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);

        function animate() {
            pianoRollVisualizerAnimationId = requestAnimationFrame(animate);
            pianoRollVisualizerAnalyzer.getByteFrequencyData(dataArray);
            pianoRollVisualizerHistory.push([...dataArray]);
            if (pianoRollVisualizerHistory.length > pianoRollVisualizerHistorySize) {
                pianoRollVisualizerHistory.shift();
            }
            drawPianoRollVisualizer();
        }
        animate();
    }

    function stopPianoRollVisualizerAnimation() {
        if (pianoRollVisualizerAnimationId) {
            cancelAnimationFrame(pianoRollVisualizerAnimationId);
            pianoRollVisualizerAnimationId = null;
        }
        pianoRollVisualizerHistory = [];
        drawPianoRollVisualizer();
    }

    function playPianoKey(noteName, octave) {
        const frequency = getNoteFrequency(noteName, octave);
        const oscillator = audioContext.createOscillator();
        oscillator.type = "sine";
        const gainNode = audioContext.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(masterOutputNode);
        oscillator.frequency.value = frequency;
        const now = audioContext.currentTime;
        const attackTime = .01;
        const decayTime = .1;
        const sustainLevel = .7;
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(1, now + attackTime);
        gainNode.gain.linearRampToValueAtTime(sustainLevel, now + attackTime + decayTime);
        gainNode.gain.linearRampToValueAtTime(0, now + attackTime + decayTime + 0.3); // Added release time
        oscillator.start(now);
        oscillator.stop(now + attackTime + decayTime + 0.3); // Added release time
    }

    function togglePianoRollCell(row, col) {
        if (!currentSampleForPopup) return;
        const data = pianoRollData[currentSampleForPopup];
        const existingNoteIndex = data.notes.findIndex(note => note.row === row && note.col === col);
        
        if (existingNoteIndex !== -1) {
            // Removing a note
            const note = data.notes[existingNoteIndex];
            
            // ULTRA-FAST: Use cached cell references - NO DOM QUERIES!
            for (let c = col; c < col + (note.length || 1); c++) {
                const cacheKey = `${row}-${c}`;
                const cell = pianoRollCellCache[cacheKey];
                if (cell) {
                    cell.classList.remove("active", "note-long");
                }
            }
            data.notes.splice(existingNoteIndex, 1);
        } else {
            // Adding a note
            const noteLength = pianoRollNoteLength;
            const note = {
                row: row,
                col: col,
                length: noteLength
            };
            data.notes.push(note);
            
            // ULTRA-FAST: Use cached cell references - NO DOM QUERIES!
            for (let c = col; c < col + noteLength; c++) {
                const cacheKey = `${row}-${c}`;
                const cell = pianoRollCellCache[cacheKey];
                if (cell) {
                    cell.classList.add("active");
                    if (c > col) {
                        cell.classList.add("note-long");
                    }
                }
            }
        }
    }

    function clearPianoRoll() {
        if (!currentSampleForPopup) return;
        const data = pianoRollData[currentSampleForPopup];
        data.notes = [];
        const cells = document.querySelectorAll(".piano-roll-cell.active");
        cells.forEach(cell => {
            cell.classList.remove("active", "note-long");
        });
    }

    function previewPianoRoll() {
        if (!currentSampleForPopup || isPreviewingPianoRoll) return;
        isPreviewingPianoRoll = true;
        currentPianoRollSample = currentSampleForPopup;
        const data = pianoRollData[currentSampleForPopup];
        const sortedNotes = [...data.notes].sort((a, b) => a.col - b.col);
        if (sortedNotes.length === 0) return;
        if (audioContext.state === "suspended") {
            audioContext.resume()["catch"](e => console.error("Error resuming audio context:", e));
        }
        const soundSource = data.soundSource;
        const isLongSample = currentSampleForPopup > 60;
        let beatDuration, barDuration;
        if (isLongSample) {
            beatDuration = 60 / longLoopTempo;
            barDuration = beatDuration * 4;
        } else {
            const effectiveTempo = tempo + highTempo;
            beatDuration = 60 / effectiveTempo;
            barDuration = beatDuration * 4;
        }
        const sixteenthDuration = barDuration / 16;
        const previewGain = audioContext.createGain();
        const lowShelfFilter = audioContext.createBiquadFilter();
        lowShelfFilter.type = "lowshelf";
        lowShelfFilter.frequency.value = 200;
        lowShelfFilter.gain.value = data.filters.lowShelf || 0;
        const lowMidFilter = audioContext.createBiquadFilter();
        lowMidFilter.type = "peaking";
        lowMidFilter.frequency.value = 500;
        lowMidFilter.Q.value = 1;
        lowMidFilter.gain.value = data.filters.lowMid || 0;
        const midFilter = audioContext.createBiquadFilter();
        midFilter.type = "peaking";
        midFilter.frequency.value = 1500;
        midFilter.Q.value = 1;
        midFilter.gain.value = data.filters.mid || 0;
        const highMidFilter = audioContext.createBiquadFilter();
        highMidFilter.type = "peaking";
        highMidFilter.frequency.value = 4e3;
        highMidFilter.Q.value = 1;
        highMidFilter.gain.value = data.filters.highMid || 0;
        const highShelfFilter = audioContext.createBiquadFilter();
        highShelfFilter.type = "highshelf";
        highShelfFilter.frequency.value = 8e3;
        highShelfFilter.gain.value = data.filters.highShelf || 0;
        const delayNode = audioContext.createDelay(1);
        delayNode.delayTime.value = (data.filters.delay.time || 0) / 1e3;
        const delayFeedbackNode = audioContext.createGain();
        delayFeedbackNode.gain.value = (data.filters.delay.feedback || 0) / 100;
        previewGain.connect(lowShelfFilter);
        lowShelfFilter.connect(lowMidFilter);
        lowMidFilter.connect(midFilter);
        midFilter.connect(highMidFilter);
        highMidFilter.connect(highShelfFilter);
        highShelfFilter.connect(delayNode);
        delayNode.connect(delayFeedbackNode);
        delayFeedbackNode.connect(delayNode);
        delayNode.connect(audioContext.destination);
        pianoRollVisualizerAnalyzer = audioContext.createAnalyser();
        pianoRollVisualizerAnalyzer.fftSize = 4096;
        pianoRollVisualizerAnalyzer.smoothingTimeConstant = .7;
        delayNode.connect(pianoRollVisualizerAnalyzer);
        pianoRollFilterNodes = {
            lowShelf: lowShelfFilter,
            lowMid: lowMidFilter,
            mid: midFilter,
            highMid: highMidFilter,
            highShelf: highShelfFilter,
            delay: delayNode,
            delayFeedback: delayFeedbackNode
        };
        
        const loopDuration = data.gridWidth * sixteenthDuration;
        pianoRollPreviewNodes[currentSampleForPopup] = {
            gain: previewGain,
            loopDuration: loopDuration,
            sixteenthDuration: sixteenthDuration,
            soundSource: soundSource,
            sampleRange: data.sampleRange,
            filters: data.filters,
            soundDesign: data.soundDesign
        };
        startPianoRollVisualizerAnimation();
        startPianoRollLoop();
    }

    function startPianoRollLoop() {
        if (!isPreviewingPianoRoll || !currentPianoRollSample || !pianoRollPreviewNodes[currentPianoRollSample]) return;
        const nodes = pianoRollPreviewNodes[currentPianoRollSample];
        const currentTime = audioContext.currentTime;
        const currentNotes = pianoRollData[currentPianoRollSample].notes;
        const sortedNotes = [...currentNotes].sort((a, b) => a.col - b.col);
        sortedNotes.forEach(note => {
            const noteTime = currentTime + note.col * nodes.sixteenthDuration;
            const noteDuration = (note.length || 1) * nodes.sixteenthDuration;
            if (nodes.soundSource === "piano") {
                playPianoNoteForPreview(note.row, noteTime, noteDuration, nodes.gain);
            } else if (nodes.soundSource === "synth") {
                playSynthNoteForPreview(note.row, noteTime, noteDuration, nodes.gain);
            } else if (nodes.soundSource === "strings") {
                playStringsNoteForPreview(note.row, noteTime, noteDuration, nodes.gain);
            } else if (nodes.soundSource === "bass") {
                playBassNoteForPreview(note.row, noteTime, noteDuration, nodes.gain);
            } else if (nodes.soundSource === "lead") {
                playLeadNoteForPreview(note.row, noteTime, noteDuration, nodes.gain);
            } else if (nodes.soundSource === "pad") {
                playPadNoteForPreview(note.row, noteTime, noteDuration, nodes.gain);
            } else if (nodes.soundSource === "pluck") {
                playPluckNoteForPreview(note.row, noteTime, noteDuration, nodes.gain);
            } else if (nodes.soundSource === "sounddesign") {
                const latestDesign = (pianoRollData[currentPianoRollSample] && pianoRollData[currentPianoRollSample].soundDesign) || nodes.soundDesign;
                const voiceId = `${note.row}-${noteTime.toFixed(3)}`;
                const voice = playSoundDesignNoteForPreview(note.row, noteTime, noteDuration, nodes.gain, latestDesign);
                pianoRollPreviewActiveVoices[voiceId] = voice;
                // Cleanup this voice after it finishes
                const cleanupMs = Math.max(0, (voice.stopAt - audioContext.currentTime) * 1e3) + 20;
                setTimeout(() => { delete pianoRollPreviewActiveVoices[voiceId]; }, cleanupMs);
            } else {
                playSampleNoteForPreview(note.row, noteTime, noteDuration, nodes.gain, currentPianoRollSample, nodes.sampleRange);
            }
        });
        pianoRollLoopInterval = setTimeout(() => {
            if (isPreviewingPianoRoll && currentPianoRollSample) {
                startPianoRollLoop();
            }
        }, nodes.loopDuration * 1e3);
    }

    function playPianoNoteForPreview(row, time, duration, gainNode) {
        const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const noteIndex = row % 12;
        const octave = Math.floor(row / 12);
        const noteName = noteNames[noteIndex];
        const frequency = getNoteFrequency(noteName, octave);
        const oscillator = audioContext.createOscillator();
        oscillator.type = "sine";
        const noteGain = audioContext.createGain();
        oscillator.connect(noteGain);
        noteGain.connect(gainNode);
        oscillator.frequency.value = frequency;
        const now = time;
        const attackTime = .01;
        const decayTime = .1;
        const sustainLevel = .7;
        noteGain.gain.setValueAtTime(0, now);
        noteGain.gain.linearRampToValueAtTime(1, now + attackTime);
        noteGain.gain.linearRampToValueAtTime(sustainLevel, now + attackTime + decayTime);
        noteGain.gain.linearRampToValueAtTime(0, now + duration);
        oscillator.start(now);
        oscillator.stop(now + duration);
    }

    function playSynthNoteForPreview(row, time, duration, gainNode) {
        const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const noteIndex = row % 12;
        const octave = Math.floor(row / 12);
        const noteName = noteNames[noteIndex];
        const frequency = getNoteFrequency(noteName, octave);
        const oscillator1 = audioContext.createOscillator();
        oscillator1.type = "sawtooth";
        const oscillator2 = audioContext.createOscillator();
        oscillator2.type = "square";
        const noteGain = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.value = frequency * 4;
        filter.Q.value = 10;
        oscillator1.connect(filter);
        oscillator2.connect(filter);
        filter.connect(noteGain);
        noteGain.connect(gainNode);
        oscillator1.frequency.value = frequency;
        oscillator2.frequency.value = frequency * .5;
        const now = time;
        const attackTime = .05;
        const decayTime = .2;
        const sustainLevel = .6;
        noteGain.gain.setValueAtTime(0, now);
        noteGain.gain.linearRampToValueAtTime(1, now + attackTime);
        noteGain.gain.linearRampToValueAtTime(sustainLevel, now + attackTime + decayTime);
        noteGain.gain.linearRampToValueAtTime(0, now + duration);
        oscillator1.start(now);
        oscillator2.start(now);
        oscillator1.stop(now + duration);
        oscillator2.stop(now + duration);
    }

    function playStringsNoteForPreview(row, time, duration, gainNode) {
        const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const noteIndex = row % 12;
        const octave = Math.floor(row / 12);
        const noteName = noteNames[noteIndex];
        const frequency = getNoteFrequency(noteName, octave);
        const oscillator = audioContext.createOscillator();
        oscillator.type = "triangle";
        const noteGain = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.value = frequency * 2;
        filter.Q.value = 5;
        oscillator.connect(filter);
        filter.connect(noteGain);
        noteGain.connect(gainNode);
        oscillator.frequency.value = frequency;
        const now = time;
        const attackTime = .1;
        const decayTime = .3;
        const sustainLevel = .7;
        noteGain.gain.setValueAtTime(0, now);
        noteGain.gain.linearRampToValueAtTime(1, now + attackTime);
        noteGain.gain.linearRampToValueAtTime(sustainLevel, now + attackTime + decayTime);
        noteGain.gain.linearRampToValueAtTime(0, now + duration);
        oscillator.start(now);
        oscillator.stop(now + duration);
    }

    function playBassNoteForPreview(row, time, duration, gainNode) {
        const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const noteIndex = row % 12;
        const octave = Math.floor(row / 12);
        const noteName = noteNames[noteIndex];
        const frequency = getNoteFrequency(noteName, octave);
        const oscillator = audioContext.createOscillator();
        oscillator.type = "sawtooth";
        const noteGain = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.value = frequency * 1.5;
        filter.Q.value = 5;
        oscillator.connect(filter);
        filter.connect(noteGain);
        noteGain.connect(gainNode);
        oscillator.frequency.value = frequency * .5;
        const now = time;
        const attackTime = .05;
        const decayTime = .2;
        const sustainLevel = .8;
        noteGain.gain.setValueAtTime(0, now);
        noteGain.gain.linearRampToValueAtTime(1, now + attackTime);
        noteGain.gain.linearRampToValueAtTime(sustainLevel, now + attackTime + decayTime);
        noteGain.gain.linearRampToValueAtTime(0, now + duration);
        oscillator.start(now);
        oscillator.stop(now + duration);
    }

    function playLeadNoteForPreview(row, time, duration, gainNode) {
        const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const noteIndex = row % 12;
        const octave = Math.floor(row / 12);
        const noteName = noteNames[noteIndex];
        const frequency = getNoteFrequency(noteName, octave);
        const oscillator = audioContext.createOscillator();
        oscillator.type = "sawtooth";
        const noteGain = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.value = frequency * 3;
        filter.Q.value = 2;
        oscillator.connect(filter);
        filter.connect(noteGain);
        noteGain.connect(gainNode);
        oscillator.frequency.value = frequency;
        const now = time;
        const attackTime = .02;
        const decayTime = .1;
        const sustainLevel = .7;
        noteGain.gain.setValueAtTime(0, now);
        noteGain.gain.linearRampToValueAtTime(1, now + attackTime);
        noteGain.gain.linearRampToValueAtTime(sustainLevel, now + attackTime + decayTime);
        noteGain.gain.linearRampToValueAtTime(0, now + duration);
        oscillator.start(now);
        oscillator.stop(now + duration);
    }

    function playPadNoteForPreview(row, time, duration, gainNode) {
        const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const noteIndex = row % 12;
        const octave = Math.floor(row / 12);
        const noteName = noteNames[noteIndex];
        const frequency = getNoteFrequency(noteName, octave);
        const oscillator = audioContext.createOscillator();
        oscillator.type = "sine";
        const noteGain = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.value = frequency * 1.2;
        filter.Q.value = 3;
        oscillator.connect(filter);
        filter.connect(noteGain);
        noteGain.connect(gainNode);
        oscillator.frequency.value = frequency;
        const now = time;
        const attackTime = .3;
        const decayTime = .5;
        const sustainLevel = .8;
        noteGain.gain.setValueAtTime(0, now);
        noteGain.gain.linearRampToValueAtTime(1, now + attackTime);
        noteGain.gain.linearRampToValueAtTime(sustainLevel, now + attackTime + decayTime);
        noteGain.gain.linearRampToValueAtTime(0, now + duration);
        oscillator.start(now);
        oscillator.stop(now + duration);
    }

    function playPluckNoteForPreview(row, time, duration, gainNode) {
        const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const noteIndex = row % 12;
        const octave = Math.floor(row / 12);
        const noteName = noteNames[noteIndex];
        const frequency = getNoteFrequency(noteName, octave);
        const oscillator = audioContext.createOscillator();
        oscillator.type = "square";
        const noteGain = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();
        filter.type = "highpass";
        filter.frequency.value = frequency * .8;
        filter.Q = 5;
        oscillator.connect(filter);
        filter.connect(noteGain);
        noteGain.connect(gainNode);
        oscillator.frequency.value = frequency;
        const now = time;
        const attackTime = .01;
        const decayTime = .1;
        const sustainLevel = .5;
        noteGain.gain.setValueAtTime(0, now);
        noteGain.gain.linearRampToValueAtTime(1, now + attackTime);
        noteGain.gain.linearRampToValueAtTime(sustainLevel, now + attackTime + decayTime);
        noteGain.gain.linearRampToValueAtTime(0, now + duration);
        oscillator.start(now);
        oscillator.stop(now + duration);
    }

    function playSampleNoteForPreview(row, time, duration, gainNode, sampleNumber, sampleRange) {
        if (!currentPlaying[sampleNumber] || !currentPlaying[sampleNumber].buffer) return;
        const source = audioContext.createBufferSource();
        source.buffer = currentPlaying[sampleNumber].buffer;
        const noteGain = audioContext.createGain();
        source.connect(noteGain);
        noteGain.connect(gainNode);
        const semitoneRatio = Math.pow(2, 1 / 12);
        const middleRow = 42;
        const pitchMultiplier = Math.pow(semitoneRatio, row - middleRow);
        source.playbackRate.value = pitchMultiplier;
        const now = time;
        const attackTime = .01;
        const decayTime = .1;
        const sustainLevel = .7;
        noteGain.gain.setValueAtTime(0, now);
        noteGain.gain.linearRampToValueAtTime(1, now + attackTime);
        noteGain.gain.linearRampToValueAtTime(sustainLevel, now + attackTime + decayTime);
        noteGain.gain.linearRampToValueAtTime(0, now + duration);
        const bufferDuration = currentPlaying[sampleNumber].buffer.duration;
        const startTime = bufferDuration * (sampleRange.start / 100);
        const endTime = bufferDuration * (sampleRange.end / 100);
        source.start(now, startTime);
        source.stop(now + duration, endTime);
    }

    function stopPianoRollPreview() {
        if (!isPreviewingPianoRoll || !currentPianoRollSample) return;
        isPreviewingPianoRoll = false;
        if (pianoRollLoopInterval) {
            clearTimeout(pianoRollLoopInterval);
            pianoRollLoopInterval = null;
        }
        if (pianoRollPreviewNodes[currentPianoRollSample]) {
            const {
                gain
            } = pianoRollPreviewNodes[currentPianoRollSample];
            gain.gain.cancelScheduledValues(audioContext.currentTime);
            gain.gain.setValueAtTime(gain.gain.value, audioContext.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + .1);
            setTimeout(() => {
                gain.disconnect();
            }, 200);
            delete pianoRollPreviewNodes[currentPianoRollSample];
        }
        if (pianoRollFilterNodes.lowShelf) {
            pianoRollFilterNodes.lowShelf.disconnect();
            pianoRollFilterNodes.lowShelf = null;
        }
        if (pianoRollFilterNodes.lowMid) {
            pianoRollFilterNodes.lowMid.disconnect();
            pianoRollFilterNodes.lowMid = null;
        }
        if (pianoRollFilterNodes.mid) {
            pianoRollFilterNodes.mid.disconnect();
            pianoRollFilterNodes.mid = null;
        }
        if (pianoRollFilterNodes.highMid) {
            pianoRollFilterNodes.highMid.disconnect();
            pianoRollFilterNodes.highMid = null;
        }
        if (pianoRollFilterNodes.highShelf) {
            pianoRollFilterNodes.highShelf.disconnect();
            pianoRollFilterNodes.highShelf = null;
        }
        if (pianoRollFilterNodes.delay) {
            pianoRollFilterNodes.delay.disconnect();
            pianoRollFilterNodes.delay = null;
        }
        if (pianoRollFilterNodes.delayFeedback) {
            pianoRollFilterNodes.delayFeedback.disconnect();
            pianoRollFilterNodes.delayFeedback = null;
        }
        if (pianoRollVisualizerAnalyzer) {
            pianoRollVisualizerAnalyzer.disconnect();
            pianoRollVisualizerAnalyzer = null;
        }
        stopPianoRollVisualizerAnimation();
        currentPianoRollSample = null;
    }
    async function savePianoRollAsSampleForCurrentButton() {
        if (!currentSampleForPopup) return;
        const data = pianoRollData[currentSampleForPopup];
        if (data.notes.length === 0) {
            console.log("No notes to save");
            return;
        }
        const sortedNotes = [...data.notes].sort((a, b) => a.col - b.col);
        const soundSource = data.soundSource;
        const isLongSample = currentSampleForPopup > 60;
        let beatDuration, barDuration;
        if (isLongSample) {
            beatDuration = 60 / longLoopTempo;
            barDuration = beatDuration * 4;
        } else {
            const effectiveTempo = tempo + highTempo;
            beatDuration = 60 / effectiveTempo;
            barDuration = beatDuration * 4;
        }
        const sixteenthDuration = barDuration / 16;
        
        // Calculate the base buffer length
        const baseBufferLength = data.gridWidth * sixteenthDuration;
        
        // Calculate the delay tail length
        const delayTime = (data.filters.delay.time || 0) / 1000;
        const delayFeedback = (data.filters.delay.feedback || 0) / 100;
        
        // Calculate the number of repetitions needed for the delay to decay to near silence
        // We'll consider it decayed when it's below -60dB (about 0.001 of the original amplitude)
        const decayThreshold = 0.001;
        let delayTailLength = 0;
        
        if (delayTime > 0 && delayFeedback > 0) {
            // Calculate how many repetitions are needed for the delay to decay
            const repetitionsNeeded = Math.ceil(Math.log(decayThreshold) / Math.log(delayFeedback));
            delayTailLength = delayTime * repetitionsNeeded;
            
            // Add a small buffer to ensure complete decay
            delayTailLength += 0.1; // 100ms additional buffer
        }
        
        // Calculate the total buffer length including the delay tail
        const bufferLength = baseBufferLength + delayTailLength;
        
        const offlineContext = new OfflineAudioContext(2, audioContext.sampleRate * bufferLength, audioContext.sampleRate);
        const masterGain = offlineContext.createGain();
        const lowShelfFilter = offlineContext.createBiquadFilter();
        lowShelfFilter.type = "lowshelf";
        lowShelfFilter.frequency.value = 200;
        lowShelfFilter.gain.value = data.filters.lowShelf || 0;
        const lowMidFilter = offlineContext.createBiquadFilter();
        lowMidFilter.type = "peaking";
        lowMidFilter.frequency.value = 500;
        lowMidFilter.Q.value = 1;
        lowMidFilter.gain.value = data.filters.lowMid || 0;
        const midFilter = offlineContext.createBiquadFilter();
        midFilter.type = "peaking";
        midFilter.frequency.value = 1500;
        midFilter.Q.value = 1;
        midFilter.gain.value = data.filters.mid || 0;
        const highMidFilter = offlineContext.createBiquadFilter();
        highMidFilter.type = "peaking";
        highMidFilter.frequency.value = 4000;
        highMidFilter.Q.value = 1;
        highMidFilter.gain.value = data.filters.highMid || 0;
        const highShelfFilter = offlineContext.createBiquadFilter();
        highShelfFilter.type = "highshelf";
        highShelfFilter.frequency.value = 8000;
        highShelfFilter.gain.value = data.filters.highShelf || 0;
        const delayNode = offlineContext.createDelay(1);
        delayNode.delayTime.value = delayTime;
        const delayFeedbackNode = offlineContext.createGain();
        delayFeedbackNode.gain.value = delayFeedback;
        masterGain.connect(lowShelfFilter);
        lowShelfFilter.connect(lowMidFilter);
        lowMidFilter.connect(midFilter);
        midFilter.connect(highMidFilter);
        highMidFilter.connect(highShelfFilter);
        highShelfFilter.connect(delayNode);
        delayNode.connect(delayFeedbackNode);
        delayFeedbackNode.connect(delayNode);
        delayNode.connect(offlineContext.destination);
        
        sortedNotes.forEach(note => {
            const noteTime = note.col * sixteenthDuration;
            const noteDuration = (note.length || 1) * sixteenthDuration;
            if (soundSource === "piano") {
                renderPianoNote(offlineContext, note.row, noteTime, noteDuration, masterGain);
            } else if (soundSource === "synth") {
                renderSynthNote(offlineContext, note.row, noteTime, noteDuration, masterGain);
            } else if (soundSource === "strings") {
                renderStringsNote(offlineContext, note.row, noteTime, noteDuration, masterGain);
            } else if (soundSource === "bass") {
                renderBassNote(offlineContext, note.row, noteTime, noteDuration, masterGain);
            } else if (soundSource === "lead") {
                renderLeadNote(offlineContext, note.row, noteTime, noteDuration, masterGain);
            } else if (soundSource === "pad") {
                renderPadNote(offlineContext, note.row, noteTime, noteDuration, masterGain);
            } else if (soundSource === "pluck") {
                renderPluckNote(offlineContext, note.row, noteTime, noteDuration, masterGain);
            } else if (soundSource === "sounddesign") {
                renderSoundDesignNote(offlineContext, note.row, noteTime, noteDuration, masterGain, data.soundDesign);
            } else {
                renderSampleNote(offlineContext, note.row, noteTime, noteDuration, masterGain, currentSampleForPopup, data.sampleRange);
            }
        });
        try {
            const renderedBuffer = await offlineContext.startRendering();
            if (!renderedBuffer || renderedBuffer.length === 0) {
                console.error("Error: Rendered buffer is empty or invalid");
                return;
            }
            
            // If we have a delay tail, we need to create a loopable version of the buffer
            if (delayTailLength > 0) {
                // Create a new buffer that's just the original loop length
                const loopableBuffer = audioContext.createBuffer(
                    renderedBuffer.numberOfChannels,
                    Math.floor(audioContext.sampleRate * baseBufferLength),
                    audioContext.sampleRate
                );
                
                // Copy the original loop portion
                for (let channel = 0; channel < renderedBuffer.numberOfChannels; channel++) {
                    const sourceData = renderedBuffer.getChannelData(channel);
                    const targetData = loopableBuffer.getChannelData(channel);
                    
                    // Copy the original loop portion
                    for (let i = 0; i < targetData.length; i++) {
                        targetData[i] = sourceData[i];
                    }
                    
                    // Add the delay tail that would overlap with the next loop
                    const delayTailSamples = Math.floor(audioContext.sampleRate * delayTailLength);
                    for (let i = 0; i < Math.min(delayTailSamples, targetData.length); i++) {
                        targetData[i] += sourceData[targetData.length + i];
                    }
                }
                
                currentPlaying[currentSampleForPopup].buffer = loopableBuffer;
                currentPlaying[currentSampleForPopup].loopDuration = baseBufferLength;
            } else {
                currentPlaying[currentSampleForPopup].buffer = renderedBuffer;
                currentPlaying[currentSampleForPopup].loopDuration = renderedBuffer.duration;
            }
            
            currentPlaying[currentSampleForPopup].bufferSampleNumber = currentSampleForPopup;
            currentPlaying[currentSampleForPopup].isCustomSample = true;
            const button = currentPlaying[currentSampleForPopup].button;
            if (button) {
                addCustomIndicator(button);
                button.classList.remove("no-sample");
            }
            if (currentPlaying[currentSampleForPopup].isScheduled && currentPlaying[currentSampleForPopup].isActive) {
                stopSample(currentSampleForPopup);
                currentPlaying[currentSampleForPopup].scheduledForNextBar = true;
                scheduleSampleForNextBar(currentSampleForPopup);
            }
            console.log(`Piano roll saved as sample for ${currentSampleForPopup}`);
        } catch (error) {
            console.error("Error rendering piano roll:", error);
            throw error;
        }
    }

    function renderPianoNote(offlineContext, row, time, duration, outputNode) {
        const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const noteIndex = row % 12;
        const octave = Math.floor(row / 12);
        const noteName = noteNames[noteIndex];
        const frequency = getNoteFrequency(noteName, octave);
        const oscillator = offlineContext.createOscillator();
        oscillator.type = "sine";
        const noteGain = offlineContext.createGain();
        oscillator.connect(noteGain);
        noteGain.connect(outputNode);
        oscillator.frequency.value = frequency;
        const attackTime = .01;
        const decayTime = .1;
        const sustainLevel = .7;
        noteGain.gain.setValueAtTime(0, time);
        noteGain.gain.linearRampToValueAtTime(1, time + attackTime);
        noteGain.gain.linearRampToValueAtTime(sustainLevel, time + attackTime + decayTime);
        noteGain.gain.linearRampToValueAtTime(0, time + duration);
        oscillator.start(time);
        oscillator.stop(time + duration);
    }

    function renderSynthNote(offlineContext, row, time, duration, outputNode) {
        const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const noteIndex = row % 12;
        const octave = Math.floor(row / 12);
        const noteName = noteNames[noteIndex];
        const frequency = getNoteFrequency(noteName, octave);
        const oscillator1 = offlineContext.createOscillator();
        oscillator1.type = "sawtooth";
        const oscillator2 = offlineContext.createOscillator();
        oscillator2.type = "square";
        const noteGain = offlineContext.createGain();
        const filter = offlineContext.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.value = frequency * 4;
        filter.Q.value = 10;
        oscillator1.connect(filter);
        oscillator2.connect(filter);
        filter.connect(noteGain);
        noteGain.connect(outputNode);
        oscillator1.frequency.value = frequency;
        oscillator2.frequency.value = frequency * .5;
        const attackTime = .05;
        const decayTime = .2;
        const sustainLevel = .6;
        noteGain.gain.setValueAtTime(0, time);
        noteGain.gain.linearRampToValueAtTime(1, time + attackTime);
        noteGain.gain.linearRampToValueAtTime(sustainLevel, time + attackTime + decayTime);
        noteGain.gain.linearRampToValueAtTime(0, time + duration);
        oscillator1.start(time);
        oscillator2.start(time);
        oscillator1.stop(time + duration);
        oscillator2.stop(time + duration);
    }

    function renderStringsNote(offlineContext, row, time, duration, outputNode) {
        const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const noteIndex = row % 12;
        const octave = Math.floor(row / 12);
        const noteName = noteNames[noteIndex];
        const frequency = getNoteFrequency(noteName, octave);
        const oscillator = offlineContext.createOscillator();
        oscillator.type = "triangle";
        const noteGain = offlineContext.createGain();
        const filter = offlineContext.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.value = frequency * 2;
        filter.Q.value = 5;
        oscillator.connect(filter);
        filter.connect(noteGain);
        noteGain.connect(outputNode);
        oscillator.frequency.value = frequency;
        const attackTime = .1;
        const decayTime = .3;
        const sustainLevel = .7;
        noteGain.gain.setValueAtTime(0, time);
        noteGain.gain.linearRampToValueAtTime(1, time + attackTime);
        noteGain.gain.linearRampToValueAtTime(sustainLevel, time + attackTime + decayTime);
        noteGain.gain.linearRampToValueAtTime(0, time + duration);
        oscillator.start(time);
        oscillator.stop(time + duration);
    }

    function renderBassNote(offlineContext, row, time, duration, outputNode) {
        const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const noteIndex = row % 12;
        const octave = Math.floor(row / 12);
        const noteName = noteNames[noteIndex];
        const frequency = getNoteFrequency(noteName, octave);
        const oscillator = offlineContext.createOscillator();
        oscillator.type = "sawtooth";
        const noteGain = offlineContext.createGain();
        const filter = offlineContext.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.value = frequency * 1.5;
        filter.Q.value = 5;
        oscillator.connect(filter);
        filter.connect(noteGain);
        noteGain.connect(outputNode);
        oscillator.frequency.value = frequency * .5;
        const attackTime = .05;
        const decayTime = .2;
        const sustainLevel = .8;
        noteGain.gain.setValueAtTime(0, time);
        noteGain.gain.linearRampToValueAtTime(1, time + attackTime);
        noteGain.gain.linearRampToValueAtTime(sustainLevel, time + attackTime + decayTime);
        noteGain.gain.linearRampToValueAtTime(0, time + duration);
        oscillator.start(time);
        oscillator.stop(time + duration);
    }

    function renderLeadNote(offlineContext, row, time, duration, outputNode) {
        const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const noteIndex = row % 12;
        const octave = Math.floor(row / 12);
        const noteName = noteNames[noteIndex];
        const frequency = getNoteFrequency(noteName, octave);
        const oscillator = offlineContext.createOscillator();
        oscillator.type = "sawtooth";
        const noteGain = offlineContext.createGain();
        const filter = offlineContext.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.value = frequency * 3;
        filter.Q.value = 2;
        oscillator.connect(filter);
        filter.connect(noteGain);
        noteGain.connect(outputNode);
        oscillator.frequency.value = frequency;
        const attackTime = .02;
        const decayTime = .1;
        const sustainLevel = .7;
        noteGain.gain.setValueAtTime(0, time);
        noteGain.gain.linearRampToValueAtTime(1, time + attackTime);
        noteGain.gain.linearRampToValueAtTime(sustainLevel, time + attackTime + decayTime);
        noteGain.gain.linearRampToValueAtTime(0, time + duration);
        oscillator.start(time);
        oscillator.stop(time + duration);
    }

    function renderPadNote(offlineContext, row, time, duration, outputNode) {
        const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const noteIndex = row % 12;
        const octave = Math.floor(row / 12);
        const noteName = noteNames[noteIndex];
        const frequency = getNoteFrequency(noteName, octave);
        const oscillator = offlineContext.createOscillator();
        oscillator.type = "sine";
        const noteGain = offlineContext.createGain();
        const filter = offlineContext.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.value = frequency * 1.2;
        filter.Q.value = 3;
        oscillator.connect(filter);
        filter.connect(noteGain);
        noteGain.connect(outputNode);
        oscillator.frequency.value = frequency;
        const attackTime = .3;
        const decayTime = .5;
        const sustainLevel = .8;
        noteGain.gain.setValueAtTime(0, time);
        noteGain.gain.linearRampToValueAtTime(1, time + attackTime);
        noteGain.gain.linearRampToValueAtTime(sustainLevel, time + attackTime + decayTime);
        noteGain.gain.linearRampToValueAtTime(0, time + duration);
        oscillator.start(time);
        oscillator.stop(time + duration);
    }

    function renderPluckNote(offlineContext, row, time, duration, outputNode) {
        const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const noteIndex = row % 12;
        const octave = Math.floor(row / 12);
        const noteName = noteNames[noteIndex];
        const frequency = getNoteFrequency(noteName, octave);
        const oscillator = offlineContext.createOscillator();
        oscillator.type = "square";
        const noteGain = offlineContext.createGain();
        const filter = offlineContext.createBiquadFilter();
        filter.type = "highpass";
        filter.frequency.value = frequency * .8;
        filter.Q = 5;
        oscillator.connect(filter);
        filter.connect(noteGain);
        noteGain.connect(outputNode);
        oscillator.frequency.value = frequency;
        const attackTime = .01;
        const decayTime = .1;
        const sustainLevel = .5;
        noteGain.gain.setValueAtTime(0, time);
        noteGain.gain.linearRampToValueAtTime(1, time + attackTime);
        noteGain.gain.linearRampToValueAtTime(sustainLevel, time + attackTime + decayTime);
        noteGain.gain.linearRampToValueAtTime(0, time + duration);
        oscillator.start(time);
        oscillator.stop(time + duration);
    }

    function renderSampleNote(offlineContext, row, time, duration, outputNode, sampleNumber, sampleRange) {
        if (!currentPlaying[sampleNumber] || !currentPlaying[sampleNumber].buffer) return;
        const source = offlineContext.createBufferSource();
        source.buffer = currentPlaying[sampleNumber].buffer;
        const noteGain = offlineContext.createGain();
        source.connect(noteGain);
        noteGain.connect(outputNode);
        const semitoneRatio = Math.pow(2, 1 / 12);
        const middleRow = 42;
        const pitchMultiplier = Math.pow(semitoneRatio, row - middleRow);
        source.playbackRate.value = pitchMultiplier;
        const now = time;
        const attackTime = .01;
        const decayTime = .1;
        const sustainLevel = .7;
        noteGain.gain.setValueAtTime(0, now);
        noteGain.gain.linearRampToValueAtTime(1, now + attackTime);
        noteGain.gain.linearRampToValueAtTime(sustainLevel, now + attackTime + decayTime);
        noteGain.gain.linearRampToValueAtTime(0, now + duration);
        const bufferDuration = currentPlaying[sampleNumber].buffer.duration;
        const startTime = bufferDuration * (sampleRange.start / 100);
        const endTime = bufferDuration * (sampleRange.end / 100);
        source.start(now, startTime);
        source.stop(now + duration, endTime);
    }

    function playPianoNoteForSample(row, time, duration, outputNode, sampleNumber) {
        const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const noteIndex = row % 12;
        const octave = Math.floor(row / 12);
        const noteName = noteNames[noteIndex];
        const frequency = getNoteFrequency(noteName, octave);
        const oscillator = audioContext.createOscillator();
        oscillator.type = "sine";
        const noteGain = audioContext.createGain();
        oscillator.connect(noteGain);
        noteGain.connect(outputNode);
        oscillator.frequency.value = frequency;
        const now = time;
        const attackTime = .01;
        const decayTime = .1;
        const sustainLevel = .7;
        noteGain.gain.setValueAtTime(0, now);
        noteGain.gain.linearRampToValueAtTime(1, now + attackTime);
        noteGain.gain.linearRampToValueAtTime(sustainLevel, now + attackTime + decayTime);
        noteGain.gain.linearRampToValueAtTime(0, now + duration);
        oscillator.start(now);
        oscillator.stop(now + duration);
    }

    function playSynthNoteForSample(row, time, duration, outputNode, sampleNumber) {
        const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const noteIndex = row % 12;
        const octave = Math.floor(row / 12);
        const noteName = noteNames[noteIndex];
        const frequency = getNoteFrequency(noteName, octave);
        const oscillator1 = audioContext.createOscillator();
        oscillator1.type = "sawtooth";
        const oscillator2 = audioContext.createOscillator();
        oscillator2.type = "square";
        const noteGain = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.value = frequency * 4;
        filter.Q.value = 10;
        oscillator1.connect(filter);
        oscillator2.connect(filter);
        filter.connect(noteGain);
        noteGain.connect(outputNode);
        oscillator1.frequency.value = frequency;
        oscillator2.frequency.value = frequency * .5;
        const now = time;
        const attackTime = .05;
        const decayTime = .2;
        const sustainLevel = .6;
        noteGain.gain.setValueAtTime(0, now);
        noteGain.gain.linearRampToValueAtTime(1, now + attackTime);
        noteGain.gain.linearRampToValueAtTime(sustainLevel, now + attackTime + decayTime);
        noteGain.gain.linearRampToValueAtTime(0, now + duration);
        oscillator1.start(now);
        oscillator2.start(now);
        oscillator1.stop(now + duration);
        oscillator2.stop(now + duration);
    }

    function playStringsNoteForSample(row, time, duration, outputNode, sampleNumber) {
        const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const noteIndex = row % 12;
        const octave = Math.floor(row / 12);
        const noteName = noteNames[noteIndex];
        const frequency = getNoteFrequency(noteName, octave);
        const oscillator = audioContext.createOscillator();
        oscillator.type = "triangle";
        const noteGain = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.value = frequency * 2;
        filter.Q.value = 5;
        oscillator.connect(filter);
        filter.connect(noteGain);
        noteGain.connect(outputNode);
        oscillator.frequency.value = frequency;
        const now = time;
        const attackTime = .1;
        const decayTime = .3;
        const sustainLevel = .7;
        noteGain.gain.setValueAtTime(0, now);
        noteGain.gain.linearRampToValueAtTime(1, now + attackTime);
        noteGain.gain.linearRampToValueAtTime(sustainLevel, now + attackTime + decayTime);
        noteGain.gain.linearRampToValueAtTime(0, now + duration);
        oscillator.start(now);
        oscillator.stop(now + duration);
    }

    function playBassNoteForSample(row, time, duration, outputNode, sampleNumber) {
        const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const noteIndex = row % 12;
        const octave = Math.floor(row / 12);
        const noteName = noteNames[noteIndex];
        const frequency = getNoteFrequency(noteName, octave);
        const oscillator = audioContext.createOscillator();
        oscillator.type = "sawtooth";
        const noteGain = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.value = frequency * 1.5;
        filter.Q.value = 5;
        oscillator.connect(filter);
        filter.connect(noteGain);
        noteGain.connect(outputNode);
        oscillator.frequency.value = frequency * .5;
        const now = time;
        const attackTime = .05;
        const decayTime = .2;
        const sustainLevel = .8;
        noteGain.gain.setValueAtTime(0, now);
        noteGain.gain.linearRampToValueAtTime(1, now + attackTime);
        noteGain.gain.linearRampToValueAtTime(sustainLevel, now + attackTime + decayTime);
        noteGain.gain.linearRampToValueAtTime(0, now + duration);
        oscillator.start(now);
        oscillator.stop(now + duration);
    }

    function playLeadNoteForSample(row, time, duration, outputNode, sampleNumber) {
        const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const noteIndex = row % 12;
        const octave = Math.floor(row / 12);
        const noteName = noteNames[noteIndex];
        const frequency = getNoteFrequency(noteName, octave);
        const oscillator = audioContext.createOscillator();
        oscillator.type = "sawtooth";
        const noteGain = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.value = frequency * 3;
        filter.Q.value = 2;
        oscillator.connect(filter);
        filter.connect(noteGain);
        noteGain.connect(outputNode);
        oscillator.frequency.value = frequency;
        const now = time;
        const attackTime = .02;
        const decayTime = .1;
        const sustainLevel = .7;
        noteGain.gain.setValueAtTime(0, now);
        noteGain.gain.linearRampToValueAtTime(1, now + attackTime);
        noteGain.gain.linearRampToValueAtTime(sustainLevel, now + attackTime + decayTime);
        noteGain.gain.linearRampToValueAtTime(0, now + duration);
        oscillator.start(now);
        oscillator.stop(now + duration);
    }

    function playPadNoteForSample(row, time, duration, outputNode, sampleNumber) {
        const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const noteIndex = row % 12;
        const octave = Math.floor(row / 12);
        const noteName = noteNames[noteIndex];
        const frequency = getNoteFrequency(noteName, octave);
        const oscillator = audioContext.createOscillator();
        oscillator.type = "sine";
        const noteGain = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();
        filter.type = "lowpass";
        filter.frequency.value = frequency * 1.2;
        filter.Q.value = 3;
        oscillator.connect(filter);
        filter.connect(noteGain);
        noteGain.connect(outputNode);
        oscillator.frequency.value = frequency;
        const now = time;
        const attackTime = .3;
        const decayTime = .5;
        const sustainLevel = .8;
        noteGain.gain.setValueAtTime(0, now);
        noteGain.gain.linearRampToValueAtTime(1, now + attackTime);
        noteGain.gain.linearRampToValueAtTime(sustainLevel, now + attackTime + decayTime);
        noteGain.gain.linearRampToValueAtTime(0, now + duration);
        oscillator.start(now);
        oscillator.stop(now + duration);
    }

    function playPluckNoteForSample(row, time, duration, outputNode, sampleNumber) {
        const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const noteIndex = row % 12;
        const octave = Math.floor(row / 12);
        const noteName = noteNames[noteIndex];
        const frequency = getNoteFrequency(noteName, octave);
        const oscillator = audioContext.createOscillator();
        oscillator.type = "square";
        const noteGain = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();
        filter.type = "highpass";
        filter.frequency.value = frequency * .8;
        filter.Q = 5;
        oscillator.connect(filter);
        filter.connect(noteGain);
        noteGain.connect(outputNode);
        oscillator.frequency.value = frequency;
        const now = time;
        const attackTime = .01;
        const decayTime = .1;
        const sustainLevel = .5;
        noteGain.gain.setValueAtTime(0, now);
        noteGain.gain.linearRampToValueAtTime(1, now + attackTime);
        noteGain.gain.linearRampToValueAtTime(sustainLevel, now + attackTime + decayTime);
        noteGain.gain.linearRampToValueAtTime(0, now + duration);
        oscillator.start(now);
        oscillator.stop(now + duration);
    }

function playSoundDesignNoteForSample(row, time, duration, outputNode, sampleNumber) {
    const data = (currentPlaying[sampleNumber] && currentPlaying[sampleNumber].effects && currentPlaying[sampleNumber].effects.pianoRoll && currentPlaying[sampleNumber].effects.pianoRoll.soundDesign)
        || (pianoRollData[sampleNumber] && pianoRollData[sampleNumber].soundDesign);
    if (!data) return playPianoNoteForSample(row, time, duration, outputNode, sampleNumber);

    const noteNames = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
    const noteIndex = row % 12;
    const octave = Math.floor(row / 12);
    const frequency = getNoteFrequency(noteNames[noteIndex], octave);

    const osc1 = audioContext.createOscillator();
    const osc2 = audioContext.createOscillator();
    const osc1Gain = audioContext.createGain();
    const osc2Gain = audioContext.createGain();
    const filter = audioContext.createBiquadFilter();
    const env = audioContext.createGain();

    osc1.type = data.osc1.wave;
    osc2.type = data.osc2.wave;
    osc1.detune.value = data.osc1.detune;
    osc2.detune.value = data.osc2.detune;
    osc1Gain.gain.value = (data.osc1.level || 0) / 100;
    osc2Gain.gain.value = (data.osc2.level || 0) / 100;

    filter.type = data.filter.type;
    filter.frequency.value = Math.max(20, (data.filter.cutoff || 2000));
    filter.Q.value = (data.filter.resonance || 0) / 10;

    osc1.connect(osc1Gain);
    osc2.connect(osc2Gain);
    osc1Gain.connect(filter);
    osc2Gain.connect(filter);
    filter.connect(env);
    env.connect(outputNode);

    const now = Math.max(time, audioContext.currentTime);
    const attack = (data.envelope.attack || 0) / 1000;
    const decay = (data.envelope.decay || 0) / 1000;
    const sustain = (data.envelope.sustain || 0) / 100;
    const release = (data.envelope.release || 0) / 1000;

    env.gain.setValueAtTime(0, now);
    env.gain.linearRampToValueAtTime(1, now + attack);
    env.gain.linearRampToValueAtTime(sustain, now + attack + decay);
    // Hold sustain until note-off, then release
    env.gain.setValueAtTime(sustain, now + duration);
    env.gain.linearRampToValueAtTime(0, now + duration + release);

    // ENVELOPE → PITCH MODULATION (Serum style!)
    if (data.envToPitch && data.envToPitch.enabled && data.envToPitch.amount !== 0) {
        const pitchAmount = data.envToPitch.amount; // in semitones
        const startFreq = frequency * Math.pow(2, pitchAmount / 12); // Start at pitch + amount
        const endFreq = frequency; // End at base pitch
        
        // Create pitch envelope that follows ADSR shape
        osc1.frequency.setValueAtTime(startFreq, now);
        if (attack + decay > 0) {
            osc1.frequency.exponentialRampToValueAtTime(Math.max(20, endFreq), now + attack + decay);
        } else {
            osc1.frequency.setValueAtTime(endFreq, now + 0.001);
        }
        osc1.frequency.setValueAtTime(endFreq, now + duration);
        
        osc2.frequency.setValueAtTime(startFreq, now);
        if (attack + decay > 0) {
            osc2.frequency.exponentialRampToValueAtTime(Math.max(20, endFreq), now + attack + decay);
        } else {
            osc2.frequency.setValueAtTime(endFreq, now + 0.001);
        }
        osc2.frequency.setValueAtTime(endFreq, now + duration);
    } else {
        osc1.frequency.setValueAtTime(frequency, now);
        osc2.frequency.setValueAtTime(frequency, now);
    }

    osc1.start(now);
    osc2.start(now);
    const stopAt = now + duration + Math.max(0, release);
    osc1.stop(stopAt);
    osc2.stop(stopAt);
}

function renderSoundDesignNote(offlineContext, row, time, duration, outputNode, design) {
    const data = design || { osc1:{wave:"sine",detune:0,level:50}, osc2:{wave:"sawtooth",detune:0,level:50}, filter:{type:"lowpass",cutoff:2000,resonance:0}, envelope:{attack:10,decay:100,sustain:70,release:200}, envToPitch:{enabled:false,amount:0} };
    const noteNames = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
    const noteIndex = row % 12; const octave = Math.floor(row / 12);
    const frequency = getNoteFrequency(noteNames[noteIndex], octave);
    const osc1 = offlineContext.createOscillator(); osc1.type = data.osc1.wave; osc1.detune.value = data.osc1.detune;
    const osc2 = offlineContext.createOscillator(); osc2.type = data.osc2.wave; osc2.detune.value = data.osc2.detune;
    const g1 = offlineContext.createGain(); g1.gain.value = (data.osc1.level||0)/100;
    const g2 = offlineContext.createGain(); g2.gain.value = (data.osc2.level||0)/100;
    const filter = offlineContext.createBiquadFilter(); filter.type = data.filter.type; filter.frequency.value = Math.max(20, data.filter.cutoff||2000); filter.Q.value = (data.filter.resonance||0)/10;
    const env = offlineContext.createGain();
    osc1.connect(g1); osc2.connect(g2); g1.connect(filter); g2.connect(filter); filter.connect(env); env.connect(outputNode);
    const attack=(data.envelope.attack||0)/1000, decay=(data.envelope.decay||0)/1000, sustain=(data.envelope.sustain||0)/100, release=(data.envelope.release||0)/1000;
    env.gain.setValueAtTime(0, time);
    env.gain.linearRampToValueAtTime(1, time+attack);
    env.gain.linearRampToValueAtTime(sustain, time+attack+decay);
    // Hold sustain until note-off, then release
    env.gain.setValueAtTime(sustain, time+duration);
    env.gain.linearRampToValueAtTime(0, time+duration+release);
    
    // ENVELOPE → PITCH MODULATION
    if (data.envToPitch && data.envToPitch.enabled && data.envToPitch.amount !== 0) {
        const pitchAmount = data.envToPitch.amount;
        const startFreq = frequency * Math.pow(2, pitchAmount / 12);
        const endFreq = frequency;
        osc1.frequency.setValueAtTime(startFreq, time);
        if (attack + decay > 0) {
            osc1.frequency.exponentialRampToValueAtTime(Math.max(20, endFreq), time + attack + decay);
        } else {
            osc1.frequency.setValueAtTime(endFreq, time + 0.001);
        }
        osc1.frequency.setValueAtTime(endFreq, time + duration);
        osc2.frequency.setValueAtTime(startFreq, time);
        if (attack + decay > 0) {
            osc2.frequency.exponentialRampToValueAtTime(Math.max(20, endFreq), time + attack + decay);
        } else {
            osc2.frequency.setValueAtTime(endFreq, time + 0.001);
        }
        osc2.frequency.setValueAtTime(endFreq, time + duration);
    } else {
        osc1.frequency.setValueAtTime(frequency, time); 
        osc2.frequency.setValueAtTime(frequency, time);
    }
    
    osc1.start(time); osc2.start(time);
    const stopAt = time + duration + Math.max(0, release);
    osc1.stop(stopAt); osc2.stop(stopAt);
}

function playSoundDesignNoteForPreview(row, time, duration, gainNode, design) {
    const data = design || { osc1:{wave:"sine",detune:0,level:50}, osc2:{wave:"sawtooth",detune:0,level:50}, filter:{type:"lowpass",cutoff:2000,resonance:0}, envelope:{attack:10,decay:100,sustain:70,release:200}, envToPitch:{enabled:false,amount:0} };
    const noteNames = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
    const noteIndex = row % 12;
    const octave = Math.floor(row / 12);
    const frequency = getNoteFrequency(noteNames[noteIndex], octave);
    const osc1 = audioContext.createOscillator();
    const osc2 = audioContext.createOscillator();
    const g1 = audioContext.createGain();
    const g2 = audioContext.createGain();
    const filter = audioContext.createBiquadFilter();
    const env = audioContext.createGain();
    osc1.type = data.osc1.wave; osc2.type = data.osc2.wave;
    osc1.detune.value = data.osc1.detune; osc2.detune.value = data.osc2.detune;
    g1.gain.value = (data.osc1.level||0)/100; g2.gain.value = (data.osc2.level||0)/100;
    filter.type = data.filter.type; filter.frequency.value = Math.max(20, data.filter.cutoff||2000); filter.Q.value = (data.filter.resonance||0)/10;
    osc1.connect(g1); osc2.connect(g2); g1.connect(filter); g2.connect(filter); filter.connect(env); env.connect(gainNode);
    const now = Math.max(time, audioContext.currentTime);
    const attack=(data.envelope.attack||0)/1000, decay=(data.envelope.decay||0)/1000, sustain=(data.envelope.sustain||0)/100, release=(data.envelope.release||0)/1000;
    env.gain.setValueAtTime(0, now);
    env.gain.linearRampToValueAtTime(1, now+attack);
    env.gain.linearRampToValueAtTime(sustain, now+attack+decay);
    // Hold sustain until note-off, then release
    env.gain.setValueAtTime(sustain, now+duration);
    env.gain.linearRampToValueAtTime(0, now+duration+release);
    
    // ENVELOPE → PITCH MODULATION (Serum style!)
    if (data.envToPitch && data.envToPitch.enabled && data.envToPitch.amount !== 0) {
        const pitchAmount = data.envToPitch.amount; // in semitones
        const startFreq = frequency * Math.pow(2, pitchAmount / 12); // Start at pitch + amount
        const endFreq = frequency; // End at base pitch
        
        console.log('🎯 Pitch Mod Active:', {pitchAmount, startFreq, endFreq, frequency, attack, decay});
        
        // Create pitch envelope that follows ADSR shape
        // Attack+Decay: pitch drops from (base + amount) to base
        osc1.frequency.setValueAtTime(startFreq, now);
        if (attack + decay > 0) {
            osc1.frequency.exponentialRampToValueAtTime(Math.max(20, endFreq), now + attack + decay);
        } else {
            osc1.frequency.setValueAtTime(endFreq, now + 0.001); // Instant if no attack/decay
        }
        // Sustain: hold at base frequency
        osc1.frequency.setValueAtTime(endFreq, now + duration);
        
        osc2.frequency.setValueAtTime(startFreq, now);
        if (attack + decay > 0) {
            osc2.frequency.exponentialRampToValueAtTime(Math.max(20, endFreq), now + attack + decay);
        } else {
            osc2.frequency.setValueAtTime(endFreq, now + 0.001);
        }
        osc2.frequency.setValueAtTime(endFreq, now + duration);
    } else {
        osc1.frequency.setValueAtTime(frequency, now); 
        osc2.frequency.setValueAtTime(frequency, now);
    }
    
    osc1.start(now); osc2.start(now);
    const stopAt = now + duration + Math.max(0, release);
    osc1.stop(stopAt); osc2.stop(stopAt);
    // Return live nodes so we can modulate mid-note during preview
    return { osc1, osc2, g1, g2, filter, env, stopAt };
}

    function playSampleNoteForSample(row, time, duration, outputNode, sampleNumber, sampleRange) {
        if (!currentPlaying[sampleNumber] || !currentPlaying[sampleNumber].buffer) return;
        const source = audioContext.createBufferSource();
        source.buffer = currentPlaying[sampleNumber].buffer;
        const noteGain = audioContext.createGain();
        source.connect(noteGain);
        noteGain.connect(outputNode);
        const semitoneRatio = Math.pow(2, 1 / 12);
        const middleRow = 42;
        const pitchMultiplier = Math.pow(semitoneRatio, row - middleRow);
        source.playbackRate.value = pitchMultiplier;
        const now = time;
        const attackTime = .01;
        const decayTime = .1;
        const sustainLevel = .7;
        noteGain.gain.setValueAtTime(0, now);
        noteGain.gain.linearRampToValueAtTime(1, now + attackTime);
        noteGain.gain.linearRampToValueAtTime(sustainLevel, now + attackTime + decayTime);
        noteGain.gain.linearRampToValueAtTime(0, now + duration);
        const bufferDuration = currentPlaying[sampleNumber].buffer.duration;
        const startTime = bufferDuration * (sampleRange.start / 100);
        const endTime = bufferDuration * (sampleRange.end / 100);
        source.start(now, startTime);
        source.stop(now + duration, endTime);
    }

    function getNoteFrequency(noteName, octave) {
        const A4 = 440;
        const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G", "G#", "A", "A#", "B"];
        const noteIndex = noteNames.indexOf(noteName);
        const semitoneDistance = (octave - 4) * 12 + (noteIndex - 9);
        return A4 * Math.pow(2, semitoneDistance / 12);
    }

    function applyPianoRollSettings() {
        if (!currentSampleForPopup) return;
        if (!currentPlaying[currentSampleForPopup].effects) {
            currentPlaying[currentSampleForPopup].effects = {};
        }
        currentPlaying[currentSampleForPopup].effects.pianoRoll = JSON.parse(JSON.stringify(pianoRollData[currentSampleForPopup]));
    }

    function openSampleSelectionPopup() {
        if (!currentSampleForPopup) return;
        currentSampleForSelection = currentSampleForPopup;
        const sample = currentPlaying[currentSampleForPopup];
        if (!sample.buffer) {
            console.error("No sample buffer available for selection");
            return;
        }
        const data = pianoRollData[currentSampleForPopup];
        sampleSelectionStart = data.sampleRange.start;
        sampleSelectionEnd = data.sampleRange.end;
        sampleSelectionZoomLevel = 1;
        document.getElementById("sample-selection-start").value = sampleSelectionStart;
        document.getElementById("sample-selection-end").value = sampleSelectionEnd;
        updateSampleSelectionDisplay();
        document.getElementById("sample-name").textContent = `Sample ${currentSampleForPopup}`;
        document.getElementById("sample-duration").textContent = `${sample.buffer.duration.toFixed(2)}s`;
        drawSampleWaveform();
        sampleSelectionPopup.style.display = "block";
    }
});